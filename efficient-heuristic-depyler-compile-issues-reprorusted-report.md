# Efficient Heuristics for Debugging Depyler Compilation Issues

Based on an analysis of the project's git history, this document outlines a set of heuristics for efficiently debugging and resolving compilation errors in code transpiled by Depyler.

## 1. Isolate the Error with a Minimal Reproducible Example

The most common and effective pattern observed is the "Red-Green" testing approach. When a compilation error is encountered in a larger transpiled file:

1.  **Isolate the problematic Python code:** Create a new, minimal Python script that contains only the code necessary to reproduce the compilation error after transpilation. This avoids noise from other parts of the code.
2.  **Create a failing test:** Add a new test case to the test suite that transpiles and attempts to compile the minimal Python script. This test should fail, demonstrating the bug. Commit this with a `[RED]` prefix in the commit message.
3.  **Iterate on the fix:** With the failing test in place, you can now work on the transpiler logic in `depyler-core` to fix the issue. Rerunning the test provides a fast feedback loop.

## 2. Common Sources of Compilation Errors

The git history points to several recurring categories of bugs:

*   **Type Mismatches:** These are the most frequent cause of issues.
    *   **`Option<T>` vs. `T`:** Look for Python code where a variable is assigned `None` in some branches but a value of a specific type in others. The transpiler should correctly wrap the type in `Option<T>`.
    *   **Result-unwrapping:** Functions that can fail and return a `Result<T, E>` might be used in contexts where a `T` is expected (e.g., inside a list comprehension or dictionary access). The transpiler may need to automatically insert `.unwrap()` or `.expect()`.
*   **F-string and `__repr__` Formatting:** Python's f-strings use the `__repr__` of objects, which maps to Rust's `Debug` trait. If a type doesn't implement `Debug`, f-string-like expressions will fail to compile. Ensure the corresponding Rust types have `#[derive(Debug)]`.
*   **Stdlib Function Mappings:** Python standard library functions often have specific Rust equivalents. Check the `stdlib_mappings` in the code generation context to ensure the correct Rust function or crate is being used. For example, issues with CSV reading suggest that the `csv` crate's iterator behavior might differ from Python's.
*   **Clippy and Linter Warnings:** The project enforces a strict set of linter rules. Run `cargo clippy` on the generated code, as it can often pinpoint the root cause of an error more clearly than the compiler itself.

## 3. The `reprorusted` CLI Tool

The presence of a `reprorusted` CLI tool suggests it may be a purpose-built utility for reproducing and debugging these compilation issues. Investigate its usage and see if it can automate parts of the process described above, such as creating the minimal failing test case.

## 4. General Debugging Workflow

1.  **Examine the failing Rust code:** Don't just look at the Python source. Read the `.rs` file generated by the transpiler. The Rust compiler's error message will point to the exact line and character that is causing the problem.
2.  **Consult `cargo clippy`:** As mentioned, `clippy` provides excellent, actionable advice for fixing common Rust errors.
3.  **Trace the code generation:** If the error in the Rust code is not obvious, use a debugger or print statements in the `depyler-core` crate to trace how the Python AST is being converted into Rust tokens. Look at the context stack and the generated `TokenStream`.
