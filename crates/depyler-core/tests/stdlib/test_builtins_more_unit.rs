// Generated by: DEPYLER stdlib validation Phase 1
// Module: builtins - Additional built-in functions
// Status: GREEN phase - Tests enabled

use depyler_core::transpile_python_to_rust;

// DEPYLER-STDLIB-BUILTINS-MORE-001: All predicate
#[test]
fn test_all() {
    let python = r#"
def all_true(items: list) -> bool:
    return all(items)
"#;

    let result = transpile_python_to_rust(python).expect("Transpilation failed");

    // Should check if all elements are truthy
    assert!(result.contains("all"));
}

// DEPYLER-STDLIB-BUILTINS-MORE-002: Any predicate
#[test]
fn test_any() {
    let python = r#"
def any_true(items: list) -> bool:
    return any(items)
"#;

    let result = transpile_python_to_rust(python).expect("Transpilation failed");

    // Should check if any element is truthy
    assert!(result.contains("any"));
}

// DEPYLER-STDLIB-BUILTINS-MORE-003: Divmod
#[test]
fn test_divmod() {
    let python = r#"
def div_and_mod(a: int, b: int) -> tuple:
    return divmod(a, b)
"#;

    let result = transpile_python_to_rust(python).expect("Transpilation failed");

    // Should return quotient and remainder
    assert!(result.contains("/") && result.contains("%"));
}

// DEPYLER-STDLIB-BUILTINS-MORE-004: Enumerate
#[test]
fn test_enumerate() {
    let python = r#"
def with_indices(items: list) -> list:
    return list(enumerate(items))
"#;

    let result = transpile_python_to_rust(python).expect("Transpilation failed");

    // Should enumerate with indices
    assert!(result.contains("enumerate"));
}

// DEPYLER-STDLIB-BUILTINS-MORE-005: Zip
#[test]
fn test_zip() {
    let python = r#"
def zip_lists(a: list, b: list) -> list:
    return list(zip(a, b))
"#;

    let result = transpile_python_to_rust(python).expect("Transpilation failed");

    // Should zip two lists
    assert!(result.contains("zip"));
}

// DEPYLER-STDLIB-BUILTINS-MORE-006: Reversed
#[test]
fn test_reversed() {
    let python = r#"
def reverse_iter(items: list) -> list:
    return list(reversed(items))
"#;

    let result = transpile_python_to_rust(python).expect("Transpilation failed");

    // Should reverse iterator
    assert!(result.contains("rev"));
}

// DEPYLER-STDLIB-BUILTINS-MORE-007: Sorted
#[test]
fn test_sorted() {
    let python = r#"
def sort_items(items: list) -> list:
    return sorted(items)
"#;

    let result = transpile_python_to_rust(python).expect("Transpilation failed");

    // Should return sorted copy
    assert!(result.contains("sort"));
}

// DEPYLER-STDLIB-BUILTINS-MORE-008: Filter
#[test]
fn test_filter() {
    let python = r#"
def filter_positive(items: list) -> list:
    return list(filter(lambda x: x > 0, items))
"#;

    let result = transpile_python_to_rust(python).expect("Transpilation failed");

    // Should filter with predicate
    assert!(result.contains("filter"));
}

// DEPYLER-STDLIB-BUILTINS-MORE-009: Map (already tested elsewhere, keeping for completeness)
#[test]
fn test_map() {
    let python = r#"
def double_items(items: list) -> list:
    return list(map(lambda x: x * 2, items))
"#;

    let result = transpile_python_to_rust(python).expect("Transpilation failed");

    // Should map with function
    assert!(result.contains("map"));
}

// DEPYLER-STDLIB-BUILTINS-MORE-010: Sum with start value
#[test]
fn test_sum_with_start() {
    let python = r#"
def sum_plus(items: list, start: int) -> int:
    return sum(items, start)
"#;

    let result = transpile_python_to_rust(python).expect("Transpilation failed");

    // Should sum with starting value
    assert!(result.contains("fold") || result.contains("sum"));
}

// Total: 9 NEW builtin functions (map already existed)
// Coverage: all(), any(), divmod(), enumerate(), zip(), reversed(), sorted(), filter(), sum(start)
