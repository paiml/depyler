//! DEPYLER-0355: documentation.rs Coverage Tests
//!
//! **EXTREME TDD Protocol - Coverage Boost**
//!
//! Target: documentation.rs 55-60% â†’ 85%+ coverage
//! TDG Score: B+/A- - Clean structure with good helper functions
//!
//! This test suite complements existing tests (11) with additional coverage for:
//! - DocConfig custom configurations
//! - All Type variant formatting (Unknown, Bool, Float, Dict, Tuple, Set, Union, Generic, Function, TypeVar, Array)
//! - example_value_for_type all branches
//! - Method signature formatting (static, classmethod, property)
//! - Performance notes branches
//! - Edge cases (empty modules, no docstrings, config combinations)

use depyler_core::documentation::*;
use depyler_core::hir::*;
use smallvec::smallvec;

// ============================================================================
// DOC CONFIG TESTS
// ============================================================================

#[test]
fn test_DEPYLER_0355_doc_config_default_values() {
    let config = DocConfig::default();

    assert!(config.include_python_source);
    assert!(config.generate_examples);
    assert!(config.include_migration_notes);
    assert!(config.generate_module_docs);
    assert!(!config.include_performance_notes);
}

#[test]
fn test_DEPYLER_0355_doc_config_all_disabled() {
    let config = DocConfig {
        include_python_source: false,
        generate_examples: false,
        include_migration_notes: false,
        generate_module_docs: false,
        include_performance_notes: false,
    };

    let generator = DocGenerator::new(config);
    let module = HirModule {
        functions: vec![],
        imports: vec![],
        type_aliases: vec![],
        protocols: vec![],
        classes: vec![],
    };

    let docs = generator.generate_docs(&module);

    // Should only contain header
    assert!(docs.contains("# Generated Rust Documentation"));
    assert!(!docs.contains("## Module Overview"));
    assert!(!docs.contains("## Migration Notes"));
}

#[test]
fn test_DEPYLER_0355_doc_config_performance_notes_enabled() {
    let config = DocConfig {
        include_performance_notes: true,
        ..Default::default()
    };

    let generator = DocGenerator::new(config);

    let func = HirFunction {
        name: "process".to_string(),
        params: smallvec![HirParam::new("text".to_string(), Type::String)],
        ret_type: Type::None,
        body: vec![],
        properties: FunctionProperties::default(),
        annotations: Default::default(),
        docstring: None,
    };

    let module = HirModule {
        functions: vec![func],
        imports: vec![],
        type_aliases: vec![],
        protocols: vec![],
        classes: vec![],
    };

    let docs = generator.generate_docs(&module);
    assert!(docs.contains("**Performance Notes:**"));
    assert!(docs.contains("String parameters use `&str` for zero-copy performance"));
}

#[test]
fn test_DEPYLER_0355_doc_config_no_examples() {
    let config = DocConfig {
        generate_examples: false,
        ..Default::default()
    };

    let generator = DocGenerator::new(config);

    let func = HirFunction {
        name: "test_func".to_string(),
        params: smallvec![],
        ret_type: Type::Int,
        body: vec![],
        properties: FunctionProperties::default(),
        annotations: Default::default(),
        docstring: None,
    };

    let module = HirModule {
        functions: vec![func],
        imports: vec![],
        type_aliases: vec![],
        protocols: vec![],
        classes: vec![],
    };

    let docs = generator.generate_docs(&module);
    assert!(!docs.contains("**Example:**"));
}

// ============================================================================
// TYPE FORMATTING TESTS - UNCOVERED VARIANTS
// ============================================================================

#[test]
fn test_DEPYLER_0355_format_type_unknown() {
    let generator = DocGenerator::new(DocConfig::default());
    assert_eq!(generator.format_type(&Type::Unknown), "?");
}

#[test]
fn test_DEPYLER_0355_format_type_bool() {
    let generator = DocGenerator::new(DocConfig::default());
    assert_eq!(generator.format_type(&Type::Bool), "bool");
}

#[test]
fn test_DEPYLER_0355_format_type_float() {
    let generator = DocGenerator::new(DocConfig::default());
    assert_eq!(generator.format_type(&Type::Float), "f64");
}

#[test]
fn test_DEPYLER_0355_format_type_none() {
    let generator = DocGenerator::new(DocConfig::default());
    assert_eq!(generator.format_type(&Type::None), "()");
}

#[test]
fn test_DEPYLER_0355_format_type_dict() {
    let generator = DocGenerator::new(DocConfig::default());
    let dict_type = Type::Dict(Box::new(Type::String), Box::new(Type::Int));
    assert_eq!(generator.format_type(&dict_type), "HashMap<&str, i32>");
}

#[test]
fn test_DEPYLER_0355_format_type_tuple_single() {
    let generator = DocGenerator::new(DocConfig::default());
    let tuple_type = Type::Tuple(vec![Type::Int]);
    assert_eq!(generator.format_type(&tuple_type), "(i32)");
}

#[test]
fn test_DEPYLER_0355_format_type_tuple_multiple() {
    let generator = DocGenerator::new(DocConfig::default());
    let tuple_type = Type::Tuple(vec![Type::Int, Type::String, Type::Bool]);
    assert_eq!(generator.format_type(&tuple_type), "(i32, &str, bool)");
}

#[test]
fn test_DEPYLER_0355_format_type_set() {
    let generator = DocGenerator::new(DocConfig::default());
    let set_type = Type::Set(Box::new(Type::Int));
    assert_eq!(generator.format_type(&set_type), "HashSet<i32>");
}

#[test]
fn test_DEPYLER_0355_format_type_union() {
    let generator = DocGenerator::new(DocConfig::default());
    let union_type = Type::Union(vec![Type::Int, Type::String]);
    assert_eq!(generator.format_type(&union_type), "Union<i32, &str>");
}

#[test]
fn test_DEPYLER_0355_format_type_custom() {
    let generator = DocGenerator::new(DocConfig::default());
    let custom_type = Type::Custom("MyClass".to_string());
    assert_eq!(generator.format_type(&custom_type), "MyClass");
}

#[test]
fn test_DEPYLER_0355_format_type_generic_no_params() {
    let generator = DocGenerator::new(DocConfig::default());
    let generic_type = Type::Generic {
        base: "List".to_string(),
        params: vec![],
    };
    assert_eq!(generator.format_type(&generic_type), "List");
}

#[test]
fn test_DEPYLER_0355_format_type_generic_with_params() {
    let generator = DocGenerator::new(DocConfig::default());
    let generic_type = Type::Generic {
        base: "Result".to_string(),
        params: vec![Type::Int, Type::String],
    };
    assert_eq!(generator.format_type(&generic_type), "Result<i32, &str>");
}

#[test]
fn test_DEPYLER_0355_format_type_function() {
    let generator = DocGenerator::new(DocConfig::default());
    let func_type = Type::Function {
        params: vec![Type::Int, Type::String],
        ret: Box::new(Type::Bool),
    };
    assert_eq!(generator.format_type(&func_type), "fn(i32, &str) -> bool");
}

#[test]
fn test_DEPYLER_0355_format_type_function_no_params() {
    let generator = DocGenerator::new(DocConfig::default());
    let func_type = Type::Function {
        params: vec![],
        ret: Box::new(Type::None),
    };
    assert_eq!(generator.format_type(&func_type), "fn() -> ()");
}

#[test]
fn test_DEPYLER_0355_format_type_typevar() {
    let generator = DocGenerator::new(DocConfig::default());
    let typevar = Type::TypeVar("T".to_string());
    assert_eq!(generator.format_type(&typevar), "T");
}

#[test]
fn test_DEPYLER_0355_format_type_array() {
    let generator = DocGenerator::new(DocConfig::default());
    let array_type = Type::Array {
        element_type: Box::new(Type::Int),
        size: Some(10),
    };
    assert_eq!(generator.format_type(&array_type), "&[i32]");
}

#[test]
fn test_DEPYLER_0355_format_type_array_no_size() {
    let generator = DocGenerator::new(DocConfig::default());
    let array_type = Type::Array {
        element_type: Box::new(Type::Float),
        size: None,
    };
    assert_eq!(generator.format_type(&array_type), "&[f64]");
}

// ============================================================================
// EXAMPLE VALUE GENERATION TESTS
// ============================================================================

#[test]
fn test_DEPYLER_0355_example_value_bool() {
    let generator = DocGenerator::new(DocConfig::default());
    let value = generator.example_value_for_type("flag", &Type::Bool);
    assert_eq!(value, "true");
}

#[test]
fn test_DEPYLER_0355_example_value_float() {
    let generator = DocGenerator::new(DocConfig::default());
    let value = generator.example_value_for_type("pi", &Type::Float);
    assert_eq!(value, "3.14");
}

#[test]
fn test_DEPYLER_0355_example_value_dict() {
    let generator = DocGenerator::new(DocConfig::default());
    let dict_type = Type::Dict(Box::new(Type::String), Box::new(Type::Int));
    let value = generator.example_value_for_type("map", &dict_type);
    assert_eq!(value, "&HashMap::new()");
}

#[test]
fn test_DEPYLER_0355_example_value_optional() {
    let generator = DocGenerator::new(DocConfig::default());
    let opt_type = Type::Optional(Box::new(Type::Int));
    let value = generator.example_value_for_type("maybe", &opt_type);
    assert_eq!(value, "Some(value)");
}

#[test]
fn test_DEPYLER_0355_example_value_default_fallback() {
    let generator = DocGenerator::new(DocConfig::default());
    let custom_type = Type::Custom("MyClass".to_string());
    let value = generator.example_value_for_type("instance", &custom_type);
    assert_eq!(value, "instance");
}

// ============================================================================
// METHOD SIGNATURE FORMATTING TESTS
// ============================================================================

#[test]
fn test_DEPYLER_0355_method_signature_static() {
    let generator = DocGenerator::new(DocConfig::default());

    let method = HirMethod {
        name: "create".to_string(),
        params: smallvec![HirParam::new("value".to_string(), Type::Int)],
        ret_type: Type::Custom("Self".to_string()),
        body: vec![],
        is_static: true,
        is_classmethod: false,
        is_property: false,
        is_async: false,
        docstring: None,
    };

    let sig = generator.format_method_signature(&method);
    assert_eq!(sig, "fn create(value: i32) -> Self");
}

#[test]
fn test_DEPYLER_0355_method_signature_instance_no_params() {
    let generator = DocGenerator::new(DocConfig::default());

    let method = HirMethod {
        name: "get_value".to_string(),
        params: smallvec![],
        ret_type: Type::Int,
        body: vec![],
        is_static: false,
        is_classmethod: false,
        is_property: false,
        is_async: false,
        docstring: None,
    };

    let sig = generator.format_method_signature(&method);
    assert_eq!(sig, "fn get_value(&self) -> i32");
}

#[test]
fn test_DEPYLER_0355_method_signature_instance_with_params() {
    let generator = DocGenerator::new(DocConfig::default());

    let method = HirMethod {
        name: "set_value".to_string(),
        params: smallvec![HirParam::new("new_val".to_string(), Type::Int)],
        ret_type: Type::None,
        body: vec![],
        is_static: false,
        is_classmethod: false,
        is_property: false,
        is_async: false,
        docstring: None,
    };

    let sig = generator.format_method_signature(&method);
    assert_eq!(sig, "fn set_value(&self, new_val: i32)");
}

#[test]
fn test_DEPYLER_0355_method_docs_static() {
    let generator = DocGenerator::new(DocConfig::default());

    let class = HirClass {
        name: "Builder".to_string(),
        fields: vec![],
        methods: vec![HirMethod {
            name: "new".to_string(),
            params: smallvec![],
            ret_type: Type::Custom("Self".to_string()),
            body: vec![],
            is_static: true,
            is_classmethod: false,
            is_property: false,
            is_async: false,
            docstring: Some("Create a new builder.".to_string()),
        }],
        base_classes: vec![],
        is_dataclass: false,
        docstring: None,
    };

    let module = HirModule {
        functions: vec![],
        imports: vec![],
        type_aliases: vec![],
        protocols: vec![],
        classes: vec![class],
    };

    let docs = generator.generate_docs(&module);

    assert!(docs.contains("#### `new`"));
    assert!(docs.contains("- **Static method**"));
    assert!(docs.contains("Create a new builder."));
}

#[test]
fn test_DEPYLER_0355_method_docs_classmethod() {
    let generator = DocGenerator::new(DocConfig::default());

    let class = HirClass {
        name: "Factory".to_string(),
        fields: vec![],
        methods: vec![HirMethod {
            name: "from_config".to_string(),
            params: smallvec![HirParam::new("config".to_string(), Type::String)],
            ret_type: Type::Custom("Self".to_string()),
            body: vec![],
            is_static: false,
            is_classmethod: true,
            is_property: false,
            is_async: false,
            docstring: None,
        }],
        base_classes: vec![],
        is_dataclass: false,
        docstring: None,
    };

    let module = HirModule {
        functions: vec![],
        imports: vec![],
        type_aliases: vec![],
        protocols: vec![],
        classes: vec![class],
    };

    let docs = generator.generate_docs(&module);

    assert!(docs.contains("#### `from_config`"));
    assert!(docs.contains("- **Class method**"));
}

#[test]
fn test_DEPYLER_0355_method_docs_property() {
    let generator = DocGenerator::new(DocConfig::default());

    let class = HirClass {
        name: "Container".to_string(),
        fields: vec![],
        methods: vec![HirMethod {
            name: "size".to_string(),
            params: smallvec![],
            ret_type: Type::Int,
            body: vec![],
            is_static: false,
            is_classmethod: false,
            is_property: true,
            is_async: false,
            docstring: Some("Get the size.".to_string()),
        }],
        base_classes: vec![],
        is_dataclass: false,
        docstring: None,
    };

    let module = HirModule {
        functions: vec![],
        imports: vec![],
        type_aliases: vec![],
        protocols: vec![],
        classes: vec![class],
    };

    let docs = generator.generate_docs(&module);

    assert!(docs.contains("#### `size`"));
    assert!(docs.contains("- **Property getter**"));
    assert!(docs.contains("Get the size."));
}

// ============================================================================
// PERFORMANCE NOTES TESTS
// ============================================================================

#[test]
fn test_DEPYLER_0355_performance_notes_max_stack_depth() {
    let config = DocConfig {
        include_performance_notes: true,
        ..Default::default()
    };
    let generator = DocGenerator::new(config);

    let func = HirFunction {
        name: "recursive_func".to_string(),
        params: smallvec![],
        ret_type: Type::Int,
        body: vec![],
        properties: FunctionProperties {
            max_stack_depth: Some(100),
            ..Default::default()
        },
        annotations: Default::default(),
        docstring: None,
    };

    let module = HirModule {
        functions: vec![func],
        imports: vec![],
        type_aliases: vec![],
        protocols: vec![],
        classes: vec![],
    };

    let docs = generator.generate_docs(&module);

    assert!(docs.contains("**Performance Notes:**"));
    assert!(docs.contains("May have deep recursion, consider iterative implementation"));
}

// ============================================================================
// EDGE CASE TESTS
// ============================================================================

#[test]
fn test_DEPYLER_0355_empty_module() {
    let generator = DocGenerator::new(DocConfig::default());

    let module = HirModule {
        functions: vec![],
        imports: vec![],
        type_aliases: vec![],
        protocols: vec![],
        classes: vec![],
    };

    let docs = generator.generate_docs(&module);

    assert!(docs.contains("# Generated Rust Documentation"));
    assert!(!docs.contains("## Functions"));
    assert!(!docs.contains("## Classes"));
}

#[test]
fn test_DEPYLER_0355_function_no_params() {
    let generator = DocGenerator::new(DocConfig::default());

    let func = HirFunction {
        name: "get_constant".to_string(),
        params: smallvec![],
        ret_type: Type::Int,
        body: vec![],
        properties: FunctionProperties::default(),
        annotations: Default::default(),
        docstring: Some("Returns a constant value.".to_string()),
    };

    let sig = generator.format_function_signature(&func);
    assert_eq!(sig, "fn get_constant() -> i32");
}

#[test]
fn test_DEPYLER_0355_function_no_docstring() {
    let generator = DocGenerator::new(DocConfig::default());

    let func = HirFunction {
        name: "helper".to_string(),
        params: smallvec![],
        ret_type: Type::None,
        body: vec![],
        properties: FunctionProperties::default(),
        annotations: Default::default(),
        docstring: None,
    };

    let module = HirModule {
        functions: vec![func],
        imports: vec![],
        type_aliases: vec![],
        protocols: vec![],
        classes: vec![],
    };

    let docs = generator.generate_docs(&module);

    assert!(docs.contains("### `helper`"));
    // Docstring section should not appear
    let lines: Vec<&str> = docs.lines().collect();
    let helper_idx = lines.iter().position(|&l| l.contains("### `helper`")).unwrap();
    let next_line = lines[helper_idx + 1];
    // Next line should be code block start, not docstring
    assert!(next_line.is_empty() || next_line.starts_with("```"));
}

#[test]
fn test_DEPYLER_0355_class_no_fields() {
    let generator = DocGenerator::new(DocConfig::default());

    let class = HirClass {
        name: "EmptyClass".to_string(),
        fields: vec![],
        methods: vec![],
        base_classes: vec![],
        is_dataclass: false,
        docstring: Some("An empty class.".to_string()),
    };

    let module = HirModule {
        functions: vec![],
        imports: vec![],
        type_aliases: vec![],
        protocols: vec![],
        classes: vec![class],
    };

    let docs = generator.generate_docs(&module);

    assert!(docs.contains("### `EmptyClass`"));
    assert!(docs.contains("An empty class."));
    assert!(!docs.contains("**Fields:**"));
    assert!(!docs.contains("**Methods:**"));
}

#[test]
fn test_DEPYLER_0355_class_no_methods() {
    let generator = DocGenerator::new(DocConfig::default());

    let class = HirClass {
        name: "DataOnly".to_string(),
        fields: vec![HirField {
            name: "value".to_string(),
            field_type: Type::Int,
            default_value: None,
            is_class_var: false,
        }],
        methods: vec![],
        base_classes: vec![],
        is_dataclass: true,
        docstring: None,
    };

    let module = HirModule {
        functions: vec![],
        imports: vec![],
        type_aliases: vec![],
        protocols: vec![],
        classes: vec![class],
    };

    let docs = generator.generate_docs(&module);

    assert!(docs.contains("### `DataOnly`"));
    assert!(docs.contains("**Fields:**"));
    assert!(docs.contains("- `value`: i32"));
    assert!(!docs.contains("**Methods:**"));
}

#[test]
fn test_DEPYLER_0355_module_with_imports_only() {
    let generator = DocGenerator::new(DocConfig::default());

    let module = HirModule {
        functions: vec![],
        imports: vec![
            HirImport {
                module: "std::collections".to_string(),
                items: vec![],
            },
            HirImport {
                module: "std::io".to_string(),
                items: vec![],
            },
        ],
        type_aliases: vec![],
        protocols: vec![],
        classes: vec![],
    };

    let docs = generator.generate_docs(&module);

    assert!(docs.contains("## Module Overview"));
    assert!(docs.contains("- **Functions**: 0"));
    assert!(docs.contains("- **Classes**: 0"));
    assert!(docs.contains("- **Imports**: 2"));
    assert!(docs.contains("### Dependencies"));
    assert!(docs.contains("- `std::collections`"));
    assert!(docs.contains("- `std::io`"));
}

#[test]
fn test_DEPYLER_0355_function_properties_all_set() {
    let generator = DocGenerator::new(DocConfig::default());

    let func = HirFunction {
        name: "pure_func".to_string(),
        params: smallvec![],
        ret_type: Type::Int,
        body: vec![],
        properties: FunctionProperties {
            is_pure: true,
            always_terminates: true,
            panic_free: true,
            is_async: true,
            ..Default::default()
        },
        annotations: Default::default(),
        docstring: None,
    };

    let module = HirModule {
        functions: vec![func],
        imports: vec![],
        type_aliases: vec![],
        protocols: vec![],
        classes: vec![],
    };

    let docs = generator.generate_docs(&module);

    assert!(docs.contains("**Properties:**"));
    assert!(docs.contains("- Pure function (no side effects)"));
    assert!(docs.contains("- Always terminates"));
    assert!(docs.contains("- Panic-free"));
    assert!(docs.contains("- Async function"));
}

#[test]
fn test_DEPYLER_0355_function_void_return() {
    let generator = DocGenerator::new(DocConfig::default());

    let func = HirFunction {
        name: "print_hello".to_string(),
        params: smallvec![],
        ret_type: Type::None,
        body: vec![],
        properties: FunctionProperties::default(),
        annotations: Default::default(),
        docstring: None,
    };

    let module = HirModule {
        functions: vec![func],
        imports: vec![],
        type_aliases: vec![],
        protocols: vec![],
        classes: vec![],
    };

    let docs = generator.generate_docs(&module);

    // Should not contain "**Returns:**" section for void functions
    let func_section_start = docs.find("### `print_hello`").unwrap();
    let func_section = &docs[func_section_start..];
    let next_func_or_end = func_section.find("---").unwrap_or(func_section.len());
    let func_section_only = &func_section[..next_func_or_end];

    assert!(!func_section_only.contains("**Returns:**"));
}

#[test]
fn test_DEPYLER_0355_api_reference_empty_module() {
    let generator = DocGenerator::new(DocConfig::default());

    let module = HirModule {
        functions: vec![],
        imports: vec![],
        type_aliases: vec![],
        protocols: vec![],
        classes: vec![],
    };

    let api_ref = generator.generate_api_reference(&module);

    assert!(api_ref.contains("# API Reference"));
    assert!(api_ref.contains("## Table of Contents"));
    assert!(!api_ref.contains("### Functions"));
    assert!(!api_ref.contains("### Classes"));
}

#[test]
fn test_DEPYLER_0355_usage_guide_empty_functions() {
    let generator = DocGenerator::new(DocConfig::default());

    let module = HirModule {
        functions: vec![],
        imports: vec![],
        type_aliases: vec![],
        protocols: vec![],
        classes: vec![],
    };

    let guide = generator.generate_usage_guide(&module);

    assert!(guide.contains("# Usage Guide"));
    assert!(guide.contains("## Quick Start"));
    assert!(guide.contains("use generated_module::*;"));
}

#[test]
fn test_DEPYLER_0355_usage_guide_single_function() {
    let generator = DocGenerator::new(DocConfig::default());

    let func = HirFunction {
        name: "calculate".to_string(),
        params: smallvec![HirParam::new("x".to_string(), Type::Int)],
        ret_type: Type::Int,
        body: vec![],
        properties: FunctionProperties::default(),
        annotations: Default::default(),
        docstring: None,
    };

    let module = HirModule {
        functions: vec![func],
        imports: vec![],
        type_aliases: vec![],
        protocols: vec![],
        classes: vec![],
    };

    let guide = generator.generate_usage_guide(&module);

    assert!(guide.contains("// Using calculate"));
    assert!(guide.contains("let result = calculate(42);"));
}

// ============================================================================
// NESTED TYPE FORMATTING TESTS
// ============================================================================

#[test]
fn test_DEPYLER_0355_format_type_nested_dict_in_list() {
    let generator = DocGenerator::new(DocConfig::default());
    let nested_type = Type::List(Box::new(Type::Dict(
        Box::new(Type::String),
        Box::new(Type::Int),
    )));
    assert_eq!(generator.format_type(&nested_type), "&[HashMap<&str, i32>]");
}

#[test]
fn test_DEPYLER_0355_format_type_nested_optional_list() {
    let generator = DocGenerator::new(DocConfig::default());
    let nested_type = Type::Optional(Box::new(Type::List(Box::new(Type::String))));
    assert_eq!(generator.format_type(&nested_type), "Option<&[&str]>");
}

#[test]
fn test_DEPYLER_0355_format_type_complex_generic() {
    let generator = DocGenerator::new(DocConfig::default());
    let complex_type = Type::Generic {
        base: "Result".to_string(),
        params: vec![
            Type::List(Box::new(Type::Int)),
            Type::Custom("Error".to_string()),
        ],
    };
    assert_eq!(generator.format_type(&complex_type), "Result<&[i32], Error>");
}

// ============================================================================
// PROPERTY-BASED TESTS - ROBUSTNESS VALIDATION
// ============================================================================

#[cfg(test)]
mod property_tests {
    use super::*;
    use proptest::prelude::*;

    proptest! {
        #[test]
        fn prop_doc_generation_never_panics(
            func_count in 0usize..10,
            class_count in 0usize..10,
        ) {
            let config = DocConfig::default();
            let generator = DocGenerator::new(config);

            let functions: Vec<HirFunction> = (0..func_count)
                .map(|i| HirFunction {
                    name: format!("func_{}", i),
                    params: smallvec![],
                    ret_type: Type::Int,
                    body: vec![],
                    properties: FunctionProperties::default(),
                    annotations: Default::default(),
                    docstring: Some(format!("Function {}", i)),
                })
                .collect();

            let classes: Vec<HirClass> = (0..class_count)
                .map(|i| HirClass {
                    name: format!("Class_{}", i),
                    fields: vec![],
                    methods: vec![],
                    base_classes: vec![],
                    is_dataclass: false,
                    docstring: Some(format!("Class {}", i)),
                })
                .collect();

            let module = HirModule {
                functions,
                imports: vec![],
                type_aliases: vec![],
                protocols: vec![],
                classes,
            };

            let _docs = generator.generate_docs(&module);
        }

        #[test]
        fn prop_type_formatting_never_panics(type_idx in 0usize..17) {
            let generator = DocGenerator::new(DocConfig::default());

            let test_type = match type_idx {
                0 => Type::Unknown,
                1 => Type::None,
                2 => Type::Bool,
                3 => Type::Int,
                4 => Type::Float,
                5 => Type::String,
                6 => Type::List(Box::new(Type::Int)),
                7 => Type::Dict(Box::new(Type::String), Box::new(Type::Int)),
                8 => Type::Tuple(vec![Type::Int, Type::String]),
                9 => Type::Set(Box::new(Type::Int)),
                10 => Type::Optional(Box::new(Type::Int)),
                11 => Type::Custom("Test".to_string()),
                12 => Type::Union(vec![Type::Int, Type::String]),
                13 => Type::Generic { base: "List".to_string(), params: vec![Type::Int] },
                14 => Type::Function { params: vec![Type::Int], ret: Box::new(Type::Bool) },
                15 => Type::TypeVar("T".to_string()),
                16 => Type::Array { element_type: Box::new(Type::Int), size: Some(10) },
                _ => Type::Int,
            };

            let _formatted = generator.format_type(&test_type);
        }
    }
}
