# Generated by: depyler corpus generator
# Source: hard_cp_graph_shortest_cycle.py
#
# Shortest cycle and related problems for transpiler stress testing.


def shortest_cycle_bfs(n: int, edges: list[list[int]]) -> int:
    """Find shortest cycle in undirected graph using BFS from each node."""
    adj: list[list[int]] = []
    i: int = 0
    while i < n:
        adj.append([])
        i = i + 1
    e: int = 0
    while e < len(edges):
        u: int = edges[e][0]
        v: int = edges[e][1]
        adj[u].append(v)
        adj[v].append(u)
        e = e + 1
    best: int = 999999999
    src: int = 0
    while src < n:
        dist: list[int] = [0 - 1] * n
        dist[src] = 0
        queue: list[int] = [src]
        qi: int = 0
        while qi < len(queue):
            u2: int = queue[qi]
            ni: int = 0
            while ni < len(adj[u2]):
                v2: int = adj[u2][ni]
                if dist[v2] == 0 - 1:
                    dist[v2] = dist[u2] + 1
                    queue.append(v2)
                elif dist[v2] >= dist[u2]:
                    cycle_len: int = dist[u2] + dist[v2] + 1
                    if cycle_len < best:
                        best = cycle_len
                ni = ni + 1
            qi = qi + 1
        src = src + 1
    if best >= 999999999:
        return 0 - 1
    return best


def has_cycle_undirected(n: int, edges: list[list[int]]) -> bool:
    """Check if undirected graph has any cycle using union-find."""
    parent: list[int] = [0] * n
    rank_arr: list[int] = [0] * n
    i: int = 0
    while i < n:
        parent[i] = i
        i = i + 1
    e: int = 0
    while e < len(edges):
        u: int = edges[e][0]
        v: int = edges[e][1]
        ru: int = u
        while parent[ru] != ru:
            parent[ru] = parent[parent[ru]]
            ru = parent[ru]
        rv: int = v
        while parent[rv] != rv:
            parent[rv] = parent[parent[rv]]
            rv = parent[rv]
        if ru == rv:
            return True
        if rank_arr[ru] < rank_arr[rv]:
            parent[ru] = rv
        elif rank_arr[ru] > rank_arr[rv]:
            parent[rv] = ru
        else:
            parent[rv] = ru
            rank_arr[ru] = rank_arr[ru] + 1
        e = e + 1
    return False


def girth(n: int, edges: list[list[int]]) -> int:
    """Girth of graph (length of shortest cycle), -1 if acyclic."""
    return shortest_cycle_bfs(n, edges)


def count_triangles(n: int, edges: list[list[int]]) -> int:
    """Count triangles in undirected graph using adjacency matrix."""
    mat: list[list[int]] = []
    i: int = 0
    while i < n:
        row: list[int] = [0] * n
        mat.append(row)
        i = i + 1
    e: int = 0
    while e < len(edges):
        u: int = edges[e][0]
        v: int = edges[e][1]
        mat[u][v] = 1
        mat[v][u] = 1
        e = e + 1
    tri: int = 0
    a: int = 0
    while a < n:
        b: int = a + 1
        while b < n:
            if mat[a][b] == 1:
                c: int = b + 1
                while c < n:
                    if mat[b][c] == 1 and mat[a][c] == 1:
                        tri = tri + 1
                    c = c + 1
            b = b + 1
        a = a + 1
    return tri


def test_module() -> int:
    passed: int = 0
    edges1: list[list[int]] = [[0, 1], [1, 2], [2, 0]]
    if shortest_cycle_bfs(3, edges1) == 3:
        passed = passed + 1
    if has_cycle_undirected(3, edges1) == True:
        passed = passed + 1
    edges2: list[list[int]] = [[0, 1], [1, 2]]
    if has_cycle_undirected(3, edges2) == False:
        passed = passed + 1
    if girth(3, edges2) == 0 - 1:
        passed = passed + 1
    edges3: list[list[int]] = [[0, 1], [1, 2], [2, 0], [1, 3], [2, 3]]
    if count_triangles(4, edges3) == 2:
        passed = passed + 1
    return passed
