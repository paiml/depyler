# Generated by: depyler corpus generator
# Source: hard_adv_sys_allocator.py
#
# Memory allocator simulation: first fit, best fit, worst fit, buddy system.


def first_fit(blocks: list[int], request: int) -> int:
    """Find first block >= request size. Returns index or -1."""
    i: int = 0
    n: int = len(blocks)
    while i < n:
        bv: int = blocks[i]
        if bv >= request:
            return i
        i = i + 1
    return -1


def best_fit(blocks: list[int], request: int) -> int:
    """Find smallest block >= request size. Returns index or -1."""
    best_idx: int = -1
    best_size: int = 999999999
    i: int = 0
    n: int = len(blocks)
    while i < n:
        bv: int = blocks[i]
        if bv >= request and bv < best_size:
            best_size = bv
            best_idx = i
        i = i + 1
    return best_idx


def worst_fit(blocks: list[int], request: int) -> int:
    """Find largest block >= request size. Returns index or -1."""
    worst_idx: int = -1
    worst_size: int = -1
    i: int = 0
    n: int = len(blocks)
    while i < n:
        bv: int = blocks[i]
        if bv >= request and bv > worst_size:
            worst_size = bv
            worst_idx = i
        i = i + 1
    return worst_idx


def allocate(blocks: list[int], idx: int, request: int) -> list[int]:
    """Allocate from block at idx. Splits block if larger than request."""
    bv: int = blocks[idx]
    remainder: int = bv - request
    blocks[idx] = 0
    if remainder > 0:
        blocks.append(remainder)
    return blocks


def free_block(blocks: list[int], idx: int, size: int) -> list[int]:
    """Free a previously allocated block by restoring its size."""
    blocks[idx] = size
    return blocks


def compact(blocks: list[int]) -> list[int]:
    """Compact free blocks: merge all free space into one block at end."""
    total_free: int = 0
    result: list[int] = []
    i: int = 0
    n: int = len(blocks)
    while i < n:
        bv: int = blocks[i]
        if bv == 0:
            pass
        else:
            total_free = total_free + bv
        i = i + 1
    if total_free > 0:
        result.append(total_free)
    return result


def fragmentation_ratio(blocks: list[int]) -> int:
    """Compute external fragmentation as percentage.
    100 * (1 - largest_free / total_free)."""
    total: int = 0
    largest: int = 0
    i: int = 0
    n: int = len(blocks)
    while i < n:
        bv: int = blocks[i]
        if bv > 0:
            total = total + bv
            if bv > largest:
                largest = bv
        i = i + 1
    if total == 0:
        return 0
    return 100 - (largest * 100) // total


def test_module() -> int:
    """Test memory allocator functions."""
    passed: int = 0

    blocks: list[int] = [100, 200, 50, 300]

    ff: int = first_fit(blocks, 150)
    if ff == 1:
        passed = passed + 1

    bf: int = best_fit(blocks, 150)
    if bf == 1:
        passed = passed + 1

    wf: int = worst_fit(blocks, 150)
    if wf == 3:
        passed = passed + 1

    b2: list[int] = [100, 200, 50]
    b2 = allocate(b2, 1, 120)
    if len(b2) == 4:
        passed = passed + 1

    fr: int = fragmentation_ratio([100, 50, 200])
    if fr >= 0:
        passed = passed + 1

    nf: int = first_fit([10, 20], 50)
    if nf == -1:
        passed = passed + 1

    return passed
