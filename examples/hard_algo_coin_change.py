# Generated by: depyler corpus generator
# Source: hard_algo_coin_change.py
#
# Coin change problem variants using dynamic programming.


def coin_change_min(coins: List[int], amount: int) -> int:
    """Minimum coins needed to make amount. Returns -1 if impossible."""
    if amount == 0:
        return 0
    big: int = amount + 1
    dp: List[int] = [big] * (amount + 1)
    dp[0] = 0
    i: int = 1
    while i <= amount:
        j: int = 0
        while j < len(coins):
            c: int = coins[j]
            if c <= i:
                prev: int = dp[i - c]
                candidate: int = prev + 1
                if candidate < dp[i]:
                    dp[i] = candidate
            j = j + 1
        i = i + 1
    result: int = dp[amount]
    if result > amount:
        return -1
    return result


def coin_change_ways(coins: List[int], amount: int) -> int:
    """Count number of distinct ways to make amount with given coins."""
    dp: List[int] = [0] * (amount + 1)
    dp[0] = 1
    j: int = 0
    while j < len(coins):
        c: int = coins[j]
        i: int = c
        while i <= amount:
            dp[i] = dp[i] + dp[i - c]
            i = i + 1
        j = j + 1
    return dp[amount]


def coin_change_with_trace(coins: List[int], amount: int) -> List[int]:
    """Return the actual coins used in minimum coin change."""
    if amount == 0:
        return []
    big: int = amount + 1
    dp: List[int] = [big] * (amount + 1)
    parent: List[int] = [-1] * (amount + 1)
    dp[0] = 0
    i: int = 1
    while i <= amount:
        j: int = 0
        while j < len(coins):
            c: int = coins[j]
            if c <= i:
                prev: int = dp[i - c]
                candidate: int = prev + 1
                if candidate < dp[i]:
                    dp[i] = candidate
                    parent[i] = c
            j = j + 1
        i = i + 1
    if dp[amount] > amount:
        return []
    result: List[int] = []
    pos: int = amount
    while pos > 0:
        coin_used: int = parent[pos]
        result.append(coin_used)
        pos = pos - coin_used
    return result


def min_coins_unlimited(denominations: List[int], target: int) -> int:
    """Minimum coins with unlimited supply (same as coin_change_min, alternative impl)."""
    big: int = target + 1
    dp: List[int] = [big] * (target + 1)
    dp[0] = 0
    i: int = 1
    while i <= target:
        j: int = 0
        while j < len(denominations):
            d: int = denominations[j]
            if d <= i and dp[i - d] + 1 < dp[i]:
                dp[i] = dp[i - d] + 1
            j = j + 1
        i = i + 1
    if dp[target] > target:
        return -1
    return dp[target]


def can_make_change(coins: List[int], amount: int) -> int:
    """Check if amount can be made. Returns 1 if yes, 0 if no."""
    dp: List[int] = [0] * (amount + 1)
    dp[0] = 1
    j: int = 0
    while j < len(coins):
        c: int = coins[j]
        i: int = c
        while i <= amount:
            if dp[i - c] == 1:
                dp[i] = 1
            i = i + 1
        j = j + 1
    return dp[amount]


def test_module() -> int:
    """Test all coin change functions."""
    passed: int = 0

    r1: int = coin_change_min([1, 5, 10], 11)
    if r1 == 2:
        passed = passed + 1

    r2: int = coin_change_min([2], 3)
    if r2 == -1:
        passed = passed + 1

    r3: int = coin_change_ways([1, 2, 5], 5)
    if r3 == 4:
        passed = passed + 1

    trace: List[int] = coin_change_with_trace([1, 5, 10], 11)
    trace_sum: int = 0
    k: int = 0
    while k < len(trace):
        trace_sum = trace_sum + trace[k]
        k = k + 1
    if trace_sum == 11:
        passed = passed + 1

    r4: int = min_coins_unlimited([1, 5, 10, 25], 30)
    if r4 == 2:
        passed = passed + 1

    r5: int = can_make_change([2, 5], 3)
    if r5 == 0:
        passed = passed + 1

    r6: int = can_make_change([1, 2, 5], 11)
    if r6 == 1:
        passed = passed + 1

    return passed
