# Generated by: depyler corpus generator
# Source: hard_adv_parse_bracket.py
#
# Advanced bracket matching with error reporting and auto-correction hints.


def find_mismatch(chars: list[int]) -> int:
    """Find position of first mismatched bracket, or -1 if all balanced."""
    stack: list[int] = []
    stack_pos: list[int] = []
    i: int = 0
    n: int = len(chars)
    while i < n:
        ch: int = chars[i]
        if ch == 40 or ch == 91 or ch == 123:
            stack.append(ch)
            stack_pos.append(i)
        elif ch == 41 or ch == 93 or ch == 125:
            if len(stack) == 0:
                return i
            top: int = stack[len(stack) - 1]
            expected: int = -1
            if top == 40:
                expected = 41
            elif top == 91:
                expected = 93
            elif top == 123:
                expected = 125
            if ch != expected:
                return i
            stack.pop()
            stack_pos.pop()
        i = i + 1
    if len(stack) > 0:
        last_pos: int = stack_pos[len(stack_pos) - 1]
        return last_pos
    return -1


def count_unclosed(chars: list[int]) -> int:
    """Count unclosed opening brackets."""
    depth: int = 0
    i: int = 0
    n: int = len(chars)
    while i < n:
        ch: int = chars[i]
        if ch == 40 or ch == 91 or ch == 123:
            depth = depth + 1
        elif ch == 41 or ch == 93 or ch == 125:
            if depth > 0:
                depth = depth - 1
        i = i + 1
    return depth


def extract_innermost(chars: list[int]) -> list[int]:
    """Extract content between the innermost bracket pair."""
    n: int = len(chars)
    last_open: int = -1
    i: int = 0
    while i < n:
        ch: int = chars[i]
        if ch == 40 or ch == 91 or ch == 123:
            last_open = i
        i = i + 1
    if last_open == -1:
        return []
    close_pos: int = last_open + 1
    while close_pos < n:
        ch2: int = chars[close_pos]
        if ch2 == 41 or ch2 == 93 or ch2 == 125:
            break
        close_pos = close_pos + 1
    result: list[int] = []
    j: int = last_open + 1
    while j < close_pos:
        val: int = chars[j]
        result.append(val)
        j = j + 1
    return result


def bracket_depth_at(chars: list[int], target_pos: int) -> int:
    """Get bracket depth at a specific position."""
    depth: int = 0
    i: int = 0
    while i <= target_pos and i < len(chars):
        ch: int = chars[i]
        if ch == 40 or ch == 91 or ch == 123:
            depth = depth + 1
        elif ch == 41 or ch == 93 or ch == 125:
            depth = depth - 1
        i = i + 1
    return depth


def remove_outermost(chars: list[int]) -> list[int]:
    """Remove outermost bracket pair if present."""
    n: int = len(chars)
    if n < 2:
        return chars
    first: int = chars[0]
    last: int = chars[n - 1]
    is_pair: int = 0
    if first == 40 and last == 41:
        is_pair = 1
    elif first == 91 and last == 93:
        is_pair = 1
    elif first == 123 and last == 125:
        is_pair = 1
    if is_pair == 0:
        return chars
    result: list[int] = []
    i: int = 1
    while i < n - 1:
        val: int = chars[i]
        result.append(val)
        i = i + 1
    return result


def test_module() -> int:
    """Test bracket matching functions."""
    passed: int = 0

    mm1: int = find_mismatch([40, 41])
    if mm1 == -1:
        passed = passed + 1

    mm2: int = find_mismatch([40, 93])
    if mm2 == 1:
        passed = passed + 1

    uc: int = count_unclosed([40, 40, 41])
    if uc == 1:
        passed = passed + 1

    inner: list[int] = extract_innermost([40, 91, 65, 93, 41])
    if len(inner) == 1:
        passed = passed + 1

    dep: int = bracket_depth_at([40, 40, 41, 41], 1)
    if dep == 2:
        passed = passed + 1

    rem: list[int] = remove_outermost([40, 65, 66, 41])
    if len(rem) == 2:
        passed = passed + 1

    return passed
