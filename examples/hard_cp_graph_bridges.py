# Generated by: depyler corpus generator
# Source: hard_cp_graph_bridges.py
#
# Bridge finding in graphs for transpiler stress testing.


def find_bridges(n: int, edges: list[list[int]]) -> list[list[int]]:
    """Find all bridges in an undirected graph using iterative DFS."""
    adj: list[list[int]] = []
    i: int = 0
    while i < n:
        adj.append([])
        i = i + 1
    e: int = 0
    while e < len(edges):
        u: int = edges[e][0]
        v: int = edges[e][1]
        adj[u].append(v)
        adj[v].append(u)
        e = e + 1
    disc: list[int] = [0 - 1] * n
    low: list[int] = [0 - 1] * n
    parent: list[int] = [0 - 1] * n
    bridges: list[list[int]] = []
    timer: int = 0
    stack: list[int] = []
    child_idx: list[int] = [0] * n
    start: int = 0
    while start < n:
        if disc[start] == 0 - 1:
            stack.append(start)
            disc[start] = timer
            low[start] = timer
            timer = timer + 1
            child_idx[start] = 0
            while len(stack) > 0:
                u2: int = stack[len(stack) - 1]
                if child_idx[u2] < len(adj[u2]):
                    v2: int = adj[u2][child_idx[u2]]
                    child_idx[u2] = child_idx[u2] + 1
                    if disc[v2] == 0 - 1:
                        parent[v2] = u2
                        disc[v2] = timer
                        low[v2] = timer
                        timer = timer + 1
                        child_idx[v2] = 0
                        stack.append(v2)
                    elif v2 != parent[u2]:
                        if disc[v2] < low[u2]:
                            low[u2] = disc[v2]
                else:
                    stack.pop()
                    if len(stack) > 0:
                        p: int = stack[len(stack) - 1]
                        if low[u2] < low[p]:
                            low[p] = low[u2]
                        if low[u2] > disc[p]:
                            bridges.append([p, u2])
        start = start + 1
    return bridges


def count_bridges(n: int, edges: list[list[int]]) -> int:
    """Count number of bridges."""
    b: list[list[int]] = find_bridges(n, edges)
    return len(b)


def is_bridge_free(n: int, edges: list[list[int]]) -> bool:
    """Check if graph has no bridges (2-edge-connected)."""
    b: list[list[int]] = find_bridges(n, edges)
    if len(b) == 0:
        return True
    return False


def connected_components_after_removal(n: int, edges: list[list[int]], rm_u: int, rm_v: int) -> int:
    """Count connected components after removing edge (rm_u, rm_v)."""
    adj: list[list[int]] = []
    i: int = 0
    while i < n:
        adj.append([])
        i = i + 1
    e: int = 0
    while e < len(edges):
        u: int = edges[e][0]
        v: int = edges[e][1]
        if (u == rm_u and v == rm_v) or (u == rm_v and v == rm_u):
            e = e + 1
        else:
            adj[u].append(v)
            adj[v].append(u)
            e = e + 1
    visited: list[bool] = [False] * n
    comp: int = 0
    s: int = 0
    while s < n:
        if not visited[s]:
            stack: list[int] = [s]
            visited[s] = True
            while len(stack) > 0:
                curr: int = stack.pop()
                ni: int = 0
                while ni < len(adj[curr]):
                    nb: int = adj[curr][ni]
                    if not visited[nb]:
                        visited[nb] = True
                        stack.append(nb)
                    ni = ni + 1
            comp = comp + 1
        s = s + 1
    return comp


def test_module() -> int:
    passed: int = 0
    edges1: list[list[int]] = [[0, 1], [1, 2], [2, 0], [1, 3], [3, 4]]
    if count_bridges(5, edges1) == 2:
        passed = passed + 1
    edges2: list[list[int]] = [[0, 1], [1, 2], [2, 0]]
    if is_bridge_free(3, edges2) == True:
        passed = passed + 1
    if count_bridges(3, edges2) == 0:
        passed = passed + 1
    if connected_components_after_removal(5, edges1, 1, 3) == 2:
        passed = passed + 1
    if connected_components_after_removal(3, edges2, 0, 1) == 1:
        passed = passed + 1
    return passed
