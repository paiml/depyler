# Generated by: depyler corpus generator
# Source: hard_adv_sys_scheduler.py
#
# Process scheduler algorithms: FCFS, SJF, Round Robin.


def fcfs_turnaround(burst_times: list[int]) -> list[int]:
    """Compute turnaround times for First Come First Served."""
    n: int = len(burst_times)
    result: list[int] = []
    cumulative: int = 0
    i: int = 0
    while i < n:
        bt: int = burst_times[i]
        cumulative = cumulative + bt
        result.append(cumulative)
        i = i + 1
    return result


def fcfs_waiting(burst_times: list[int]) -> list[int]:
    """Compute waiting times for FCFS."""
    n: int = len(burst_times)
    result: list[int] = []
    wait: int = 0
    i: int = 0
    while i < n:
        result.append(wait)
        bt: int = burst_times[i]
        wait = wait + bt
        i = i + 1
    return result


def sjf_order(burst_times: list[int]) -> list[int]:
    """Compute execution order for Shortest Job First (non-preemptive). Returns indices."""
    n: int = len(burst_times)
    scheduled: list[int] = []
    done: list[int] = []
    i: int = 0
    while i < n:
        done.append(0)
        i = i + 1
    step: int = 0
    while step < n:
        best_idx: int = -1
        best_bt: int = 999999999
        j: int = 0
        while j < n:
            dv: int = done[j]
            if dv == 0:
                bt2: int = burst_times[j]
                if bt2 < best_bt:
                    best_bt = bt2
                    best_idx = j
            j = j + 1
        if best_idx >= 0:
            scheduled.append(best_idx)
            done[best_idx] = 1
        step = step + 1
    return scheduled


def round_robin_wait(burst_times: list[int], quantum: int) -> list[int]:
    """Compute waiting times for Round Robin scheduling."""
    n: int = len(burst_times)
    remaining: list[int] = []
    waiting: list[int] = []
    i: int = 0
    while i < n:
        bt: int = burst_times[i]
        remaining.append(bt)
        waiting.append(0)
        i = i + 1
    current_time: int = 0
    all_done: int = 0
    while all_done == 0:
        all_done = 1
        j: int = 0
        while j < n:
            rv: int = remaining[j]
            if rv > 0:
                all_done = 0
                if rv > quantum:
                    current_time = current_time + quantum
                    remaining[j] = rv - quantum
                else:
                    current_time = current_time + rv
                    remaining[j] = 0
                    orig: int = burst_times[j]
                    waiting[j] = current_time - orig
            j = j + 1
    return waiting


def average_turnaround(turnarounds: list[int]) -> int:
    """Compute average turnaround time (integer division)."""
    total: int = 0
    i: int = 0
    n: int = len(turnarounds)
    while i < n:
        tv: int = turnarounds[i]
        total = total + tv
        i = i + 1
    if n == 0:
        return 0
    return total // n


def test_module() -> int:
    """Test scheduler functions."""
    passed: int = 0

    bt: list[int] = [3, 5, 2, 4]
    ta: list[int] = fcfs_turnaround(bt)
    ta0: int = ta[0]
    if ta0 == 3:
        passed = passed + 1

    ta3: int = ta[3]
    if ta3 == 14:
        passed = passed + 1

    wt: list[int] = fcfs_waiting(bt)
    wt0: int = wt[0]
    if wt0 == 0:
        passed = passed + 1

    order: list[int] = sjf_order(bt)
    first: int = order[0]
    if first == 2:
        passed = passed + 1

    avg: int = average_turnaround(ta)
    if avg > 0:
        passed = passed + 1

    rr_wt: list[int] = round_robin_wait([4, 3, 2], 2)
    if len(rr_wt) == 3:
        passed = passed + 1

    return passed
