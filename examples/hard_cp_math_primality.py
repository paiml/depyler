# Generated by: depyler corpus generator
# Source: hard_cp_math_primality.py
#
# Primality testing (Miller-Rabin-like deterministic) for transpiler stress testing.


def mod_pow(base_val: int, exp: int, mod: int) -> int:
    """Modular exponentiation."""
    result: int = 1
    b: int = base_val % mod
    e: int = exp
    while e > 0:
        if e % 2 == 1:
            result = (result * b) % mod
        e = e // 2
        b = (b * b) % mod
    return result


def is_prime_trial(n: int) -> int:
    """Trial division primality test. Returns 1=prime, 0=composite."""
    if n < 2:
        return 0
    if n < 4:
        return 1
    if n % 2 == 0:
        return 0
    if n % 3 == 0:
        return 0
    i: int = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return 0
        i = i + 6
    return 1


def miller_rabin_witness(n: int, a: int) -> int:
    """Check if a is a witness for n being composite. Returns 1=composite, 0=probably prime."""
    if n % a == 0:
        if n == a:
            return 0
        return 1
    d: int = n - 1
    r: int = 0
    while d % 2 == 0:
        d = d // 2
        r = r + 1
    x: int = mod_pow(a, d, n)
    if x == 1 or x == n - 1:
        return 0
    i: int = 0
    while i < r - 1:
        x = (x * x) % n
        if x == n - 1:
            return 0
        i = i + 1
    return 1


def is_prime_miller(n: int) -> int:
    """Deterministic Miller-Rabin for n < 3,215,031,751. Returns 1=prime, 0=composite."""
    if n < 2:
        return 0
    if n < 4:
        return 1
    if n % 2 == 0:
        return 0
    witnesses: list[int] = [2, 3, 5, 7]
    wi: int = 0
    while wi < len(witnesses):
        a: int = witnesses[wi]
        if a >= n:
            wi = wi + 1
        else:
            if miller_rabin_witness(n, a) == 1:
                return 0
            wi = wi + 1
    return 1


def count_primes_up_to(n: int) -> int:
    """Count primes up to n using sieve of Eratosthenes."""
    if n < 2:
        return 0
    sieve: list[int] = [1] * (n + 1)
    sieve[0] = 0
    sieve[1] = 0
    p: int = 2
    while p * p <= n:
        if sieve[p] == 1:
            multiple: int = p * p
            while multiple <= n:
                sieve[multiple] = 0
                multiple = multiple + p
        p = p + 1
    count: int = 0
    i: int = 0
    while i <= n:
        count = count + sieve[i]
        i = i + 1
    return count


def test_module() -> int:
    passed: int = 0
    if is_prime_trial(17) == 1:
        passed = passed + 1
    if is_prime_trial(15) == 0:
        passed = passed + 1
    if is_prime_miller(97) == 1:
        passed = passed + 1
    if is_prime_miller(91) == 0:
        passed = passed + 1
    if count_primes_up_to(30) == 10:
        passed = passed + 1
    return passed
