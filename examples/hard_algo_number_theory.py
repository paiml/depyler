# Generated by: depyler corpus generator
# Source: hard_algo_number_theory.py
#
# Prime checking, sieve of Eratosthenes, GCD, LCM, and related.


def is_prime(n: int) -> int:
    """Check if n is prime. Returns 1 if prime, 0 otherwise."""
    if n <= 1:
        return 0
    if n <= 3:
        return 1
    if n % 2 == 0 or n % 3 == 0:
        return 0
    i: int = 5
    while i * i <= n:
        if n % i == 0 or n % (i + 2) == 0:
            return 0
        i = i + 6
    return 1


def sieve_of_eratosthenes(limit: int) -> List[int]:
    """Return all primes up to limit using sieve."""
    if limit < 2:
        return []
    is_comp: List[int] = [0] * (limit + 1)
    i: int = 2
    while i * i <= limit:
        if is_comp[i] == 0:
            j: int = i * i
            while j <= limit:
                is_comp[j] = 1
                j = j + i
        i = i + 1
    primes: List[int] = []
    k: int = 2
    while k <= limit:
        if is_comp[k] == 0:
            primes.append(k)
        k = k + 1
    return primes


def gcd(a: int, b: int) -> int:
    """Greatest common divisor using Euclidean algorithm."""
    x: int = a
    y: int = b
    if x < 0:
        x = 0 - x
    if y < 0:
        y = 0 - y
    while y != 0:
        temp: int = y
        y = x % y
        x = temp
    return x


def lcm(a: int, b: int) -> int:
    """Least common multiple."""
    if a == 0 or b == 0:
        return 0
    g: int = gcd(a, b)
    x: int = a
    if x < 0:
        x = 0 - x
    y: int = b
    if y < 0:
        y = 0 - y
    return (x // g) * y


def count_primes(n: int) -> int:
    """Count primes less than n."""
    if n <= 2:
        return 0
    primes: List[int] = sieve_of_eratosthenes(n - 1)
    return len(primes)


def prime_factorization(n: int) -> List[int]:
    """Return prime factors of n in ascending order (with repetition)."""
    factors: List[int] = []
    if n <= 1:
        return factors
    val: int = n
    d: int = 2
    while d * d <= val:
        while val % d == 0:
            factors.append(d)
            val = val // d
        d = d + 1
    if val > 1:
        factors.append(val)
    return factors


def euler_totient(n: int) -> int:
    """Euler's totient function: count of integers 1..n coprime to n."""
    if n <= 0:
        return 0
    result: int = n
    val: int = n
    d: int = 2
    while d * d <= val:
        if val % d == 0:
            while val % d == 0:
                val = val // d
            result = result - result // d
        d = d + 1
    if val > 1:
        result = result - result // val
    return result


def mod_power(num: int, exp: int, modulus: int) -> int:
    """Modular exponentiation: (num^exp) % modulus."""
    result: int = 1
    b: int = num % modulus
    e: int = exp
    while e > 0:
        if e % 2 == 1:
            result = (result * b) % modulus
        e = e // 2
        b = (b * b) % modulus
    return result


def test_module() -> int:
    """Test all number theory functions."""
    passed: int = 0

    r1: int = is_prime(17)
    if r1 == 1:
        passed = passed + 1

    r2: int = is_prime(15)
    if r2 == 0:
        passed = passed + 1

    primes: List[int] = sieve_of_eratosthenes(20)
    if primes == [2, 3, 5, 7, 11, 13, 17, 19]:
        passed = passed + 1

    r3: int = gcd(12, 8)
    if r3 == 4:
        passed = passed + 1

    r4: int = lcm(4, 6)
    if r4 == 12:
        passed = passed + 1

    r5: int = count_primes(10)
    if r5 == 4:
        passed = passed + 1

    factors: List[int] = prime_factorization(60)
    if factors == [2, 2, 3, 5]:
        passed = passed + 1

    r6: int = euler_totient(12)
    if r6 == 4:
        passed = passed + 1

    r7: int = mod_power(2, 10, 1000)
    if r7 == 24:
        passed = passed + 1

    return passed
