# Generated by: depyler corpus generator
# Source: hard_cp_ds_minstack.py
#
# Min stack and related operations for transpiler stress testing.


def minstack_push(stack: list[int], min_stack: list[int], val: int) -> int:
    """Push value onto min stack. Returns new size."""
    stack.append(val)
    if len(min_stack) == 0:
        min_stack.append(val)
    else:
        top_min: int = min_stack[len(min_stack) - 1]
        if val <= top_min:
            min_stack.append(val)
        else:
            min_stack.append(top_min)
    return len(stack)


def minstack_pop(stack: list[int], min_stack: list[int]) -> int:
    """Pop from min stack. Returns popped value or -1 if empty."""
    if len(stack) == 0:
        return 0 - 1
    val: int = stack.pop()
    min_stack.pop()
    return val


def minstack_get_min(min_stack: list[int]) -> int:
    """Get current minimum. Returns -1 if empty."""
    if len(min_stack) == 0:
        return 0 - 1
    return min_stack[len(min_stack) - 1]


def minstack_top(stack: list[int]) -> int:
    """Peek at top element."""
    if len(stack) == 0:
        return 0 - 1
    return stack[len(stack) - 1]


def simulate_minstack(operations: list[int]) -> list[int]:
    """Simulate min stack: positive = push, 0 = pop, -1 = get_min, -2 = top.
    Returns list of results for query operations."""
    stack: list[int] = []
    min_stack: list[int] = []
    results: list[int] = []
    i: int = 0
    while i < len(operations):
        op: int = operations[i]
        if op > 0:
            minstack_push(stack, min_stack, op)
        elif op == 0:
            popped: int = minstack_pop(stack, min_stack)
            results.append(popped)
        elif op == 0 - 1:
            min_val: int = minstack_get_min(min_stack)
            results.append(min_val)
        elif op == 0 - 2:
            top_val: int = minstack_top(stack)
            results.append(top_val)
        i = i + 1
    return results


def test_module() -> int:
    passed: int = 0
    stack: list[int] = []
    min_st: list[int] = []
    minstack_push(stack, min_st, 5)
    minstack_push(stack, min_st, 3)
    minstack_push(stack, min_st, 7)
    if minstack_get_min(min_st) == 3:
        passed = passed + 1
    minstack_pop(stack, min_st)
    if minstack_get_min(min_st) == 3:
        passed = passed + 1
    minstack_pop(stack, min_st)
    if minstack_get_min(min_st) == 5:
        passed = passed + 1
    ops: list[int] = [10, 5, 8, 0 - 1, 0, 0 - 1]
    results: list[int] = simulate_minstack(ops)
    if results[0] == 5:
        passed = passed + 1
    if results[2] == 5:
        passed = passed + 1
    return passed
