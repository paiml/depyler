# Generated by: depyler corpus generator
# Source: hard_cp_string_superstring.py
#
# Shortest superstring approximation for transpiler stress testing.


def overlap_length(a: str, b: str) -> int:
    """Find max overlap: suffix of a matching prefix of b."""
    max_overlap: int = len(a)
    if len(b) < max_overlap:
        max_overlap = len(b)
    k: int = max_overlap
    while k > 0:
        matched: int = 1
        i: int = 0
        while i < k:
            a_idx: int = len(a) - k + i
            if a[a_idx] != b[i]:
                matched = 0
                i = k
            i = i + 1
        if matched == 1:
            return k
        k = k - 1
    return 0


def merge_with_overlap(a: str, b: str, overlap: int) -> str:
    """Merge two strings given their overlap."""
    result: str = a
    i: int = overlap
    while i < len(b):
        result = result + b[i]
        i = i + 1
    return result


def greedy_superstring(words: list[str]) -> int:
    """Greedy shortest superstring approximation. Returns length."""
    n: int = len(words)
    if n == 0:
        return 0
    if n == 1:
        return len(words[0])
    active: list[int] = [1] * n
    merged: list[str] = []
    wi: int = 0
    while wi < n:
        merged.append(words[wi])
        wi = wi + 1
    remaining: int = n
    while remaining > 1:
        best_overlap: int = 0 - 1
        best_i: int = 0
        best_j: int = 0
        a: int = 0
        while a < n:
            if active[a] == 1:
                b: int = 0
                while b < n:
                    if b != a and active[b] == 1:
                        ov: int = overlap_length(merged[a], merged[b])
                        if ov > best_overlap:
                            best_overlap = ov
                            best_i = a
                            best_j = b
                    b = b + 1
            a = a + 1
        if best_overlap <= 0:
            best_i = 0 - 1
            a2: int = 0
            while a2 < n:
                if active[a2] == 1:
                    if best_i == 0 - 1:
                        best_i = a2
                    else:
                        best_j = a2
                        a2 = n
                a2 = a2 + 1
            best_overlap = 0
        new_str: str = merge_with_overlap(merged[best_i], merged[best_j], best_overlap)
        merged[best_i] = new_str
        active[best_j] = 0
        remaining = remaining - 1
    result_len: int = 0
    ri: int = 0
    while ri < n:
        if active[ri] == 1:
            result_len = len(merged[ri])
        ri = ri + 1
    return result_len


def test_module() -> int:
    passed: int = 0
    if overlap_length("abc", "bcd") == 2:
        passed = passed + 1
    if overlap_length("abc", "xyz") == 0:
        passed = passed + 1
    if merge_with_overlap("abc", "bcd", 2) == "abcd":
        passed = passed + 1
    result: int = greedy_superstring(["abc", "bcd", "cde"])
    if result <= 5:
        passed = passed + 1
    if greedy_superstring(["a"]) == 1:
        passed = passed + 1
    return passed
