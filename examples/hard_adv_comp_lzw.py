# Generated by: depyler corpus generator
# Source: hard_adv_comp_lzw.py
#
# LZW-like dictionary compression using integer sequences.


def init_dictionary(alphabet_size: int) -> list[int]:
    """Initialize dictionary: first alphabet_size entries map to themselves.
    Flat representation: [entry0_len, entry0_val0, entry1_len, entry1_val0, ...]."""
    dictionary: list[int] = []
    i: int = 0
    while i < alphabet_size:
        dictionary.append(1)
        dictionary.append(i)
        i = i + 1
    return dictionary


def dict_entry_count(dictionary: list[int]) -> int:
    """Count entries in flat dictionary."""
    cnt: int = 0
    pos: int = 0
    n: int = len(dictionary)
    while pos < n:
        entry_len: int = dictionary[pos]
        pos = pos + 1 + entry_len
        cnt = cnt + 1
    return cnt


def lzw_compress_simple(data: list[int], alphabet_size: int) -> list[int]:
    """Simple LZW-like compression. Outputs dictionary indices."""
    output: list[int] = []
    n: int = len(data)
    if n == 0:
        return output
    next_code: int = alphabet_size
    i: int = 0
    while i < n:
        current: int = data[i]
        output.append(current)
        if i + 1 < n:
            next_code = next_code + 1
        i = i + 1
    return output


def lzw_decompress_simple(codes: list[int], alphabet_size: int) -> list[int]:
    """Simple LZW-like decompression from codes back to data."""
    result: list[int] = []
    i: int = 0
    n: int = len(codes)
    while i < n:
        code_val: int = codes[i]
        if code_val < alphabet_size:
            result.append(code_val)
        i = i + 1
    return result


def estimate_dict_size(data: list[int], alphabet_size: int) -> int:
    """Estimate how large the LZW dictionary would grow."""
    seen_pairs: list[int] = []
    n: int = len(data)
    new_entries: int = 0
    i: int = 0
    while i < n - 1:
        a: int = data[i]
        b: int = data[i + 1]
        pair_code: int = a * 256 + b
        found: int = 0
        j: int = 0
        while j < len(seen_pairs):
            sp: int = seen_pairs[j]
            if sp == pair_code:
                found = 1
            j = j + 1
        if found == 0:
            seen_pairs.append(pair_code)
            new_entries = new_entries + 1
        i = i + 1
    return alphabet_size + new_entries


def test_module() -> int:
    """Test LZW functions."""
    passed: int = 0

    d: list[int] = init_dictionary(4)
    cnt: int = dict_entry_count(d)
    if cnt == 4:
        passed = passed + 1

    comp: list[int] = lzw_compress_simple([0, 1, 2, 1, 0], 4)
    if len(comp) == 5:
        passed = passed + 1

    decomp: list[int] = lzw_decompress_simple(comp, 4)
    if len(decomp) == 5:
        passed = passed + 1

    d0: int = decomp[0]
    d2: int = decomp[2]
    if d0 == 0 and d2 == 2:
        passed = passed + 1

    est: int = estimate_dict_size([0, 1, 0, 1, 0], 4)
    if est >= 4:
        passed = passed + 1

    empty: list[int] = lzw_compress_simple([], 4)
    if len(empty) == 0:
        passed = passed + 1

    return passed
