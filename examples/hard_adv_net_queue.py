# Generated by: depyler corpus generator
# Source: hard_adv_net_queue.py
#
# Message queue simulation: enqueue, dequeue, priority queue, dead letter queue.


def enqueue(queue: list[int], msg: int) -> list[int]:
    """Add a message to the end of the queue."""
    queue.append(msg)
    return queue


def dequeue(queue: list[int]) -> tuple[int, int]:
    """Remove and return the first message. Returns (msg, new_size) or (-1, size) if empty."""
    n: int = len(queue)
    if n == 0:
        return (-1, 0)
    first: int = queue[0]
    new_queue: list[int] = []
    i: int = 1
    while i < n:
        val: int = queue[i]
        new_queue.append(val)
        i = i + 1
    j: int = 0
    while j < len(queue):
        queue.pop()
        j = j + 1
    k: int = 0
    while k < len(new_queue):
        nv: int = new_queue[k]
        queue.append(nv)
        k = k + 1
    return (first, len(queue))


def peek(queue: list[int]) -> int:
    """Look at front of queue without removing. Returns -1 if empty."""
    if len(queue) == 0:
        return -1
    return queue[0]


def priority_insert(queue: list[int], msg: int) -> list[int]:
    """Insert message maintaining sorted order (lower = higher priority)."""
    n: int = len(queue)
    if n == 0:
        queue.append(msg)
        return queue
    pos: int = 0
    while pos < n:
        qv: int = queue[pos]
        if msg <= qv:
            break
        pos = pos + 1
    temp: list[int] = []
    i: int = 0
    while i < pos:
        tv: int = queue[i]
        temp.append(tv)
        i = i + 1
    temp.append(msg)
    while i < n:
        tv2: int = queue[i]
        temp.append(tv2)
        i = i + 1
    while len(queue) > 0:
        queue.pop()
    j: int = 0
    while j < len(temp):
        tv3: int = temp[j]
        queue.append(tv3)
        j = j + 1
    return queue


def process_batch(queue: list[int], batch_size: int) -> tuple[int, int]:
    """Process up to batch_size messages. Returns (processed_count, remaining)."""
    processed: int = 0
    while processed < batch_size and len(queue) > 0:
        result: tuple[int, int] = dequeue(queue)
        processed = processed + 1
    return (processed, len(queue))


def queue_stats(queue: list[int]) -> tuple[int, int]:
    """Return (min_val, max_val) of queue, or (-1, -1) if empty."""
    n: int = len(queue)
    if n == 0:
        return (-1, -1)
    min_v: int = queue[0]
    max_v: int = queue[0]
    i: int = 1
    while i < n:
        qv: int = queue[i]
        if qv < min_v:
            min_v = qv
        if qv > max_v:
            max_v = qv
        i = i + 1
    return (min_v, max_v)


def test_module() -> int:
    """Test message queue functions."""
    passed: int = 0

    q: list[int] = []
    q = enqueue(q, 10)
    q = enqueue(q, 20)
    if len(q) == 2:
        passed = passed + 1

    p: int = peek(q)
    if p == 10:
        passed = passed + 1

    dr: tuple[int, int] = dequeue(q)
    msg: int = dr[0]
    if msg == 10:
        passed = passed + 1

    pq: list[int] = []
    pq = priority_insert(pq, 30)
    pq = priority_insert(pq, 10)
    pq = priority_insert(pq, 20)
    first_pq: int = pq[0]
    if first_pq == 10:
        passed = passed + 1

    stats: tuple[int, int] = queue_stats(pq)
    sv_min: int = stats[0]
    sv_max: int = stats[1]
    if sv_min == 10 and sv_max == 30:
        passed = passed + 1

    pe: int = peek([])
    if pe == -1:
        passed = passed + 1

    return passed
