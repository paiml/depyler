# Generated by: depyler corpus generator
# Source: hard_adv_opt_swarm.py
#
# Particle swarm optimization (integer-discretized).


def objective_2d(x_val: int, y_val: int) -> int:
    """Objective to minimize: (x-7)^2 + (y-3)^2."""
    dx: int = x_val - 7
    dy: int = y_val - 3
    return dx * dx + dy * dy


def clamp(val: int, lo: int, hi: int) -> int:
    """Clamp value to [lo, hi] range."""
    if val < lo:
        return lo
    if val > hi:
        return hi
    return val


def pso_step(positions_x: list[int], positions_y: list[int],
             velocities_x: list[int], velocities_y: list[int],
             best_x: list[int], best_y: list[int],
             global_bx: int, global_by: int,
             rng_seed: int) -> list[int]:
    """One PSO step. Returns flat list: [new_pos_x..., new_pos_y..., new_vel_x..., new_vel_y..., new_rng]."""
    n: int = len(positions_x)
    result: list[int] = []
    rng: int = rng_seed
    i: int = 0
    while i < n:
        px: int = positions_x[i]
        py: int = positions_y[i]
        vx: int = velocities_x[i]
        vy: int = velocities_y[i]
        bpx: int = best_x[i]
        bpy: int = best_y[i]
        rng = (rng * 1103515245 + 12345) % 2147483648
        r1: int = rng % 3
        rng = (rng * 1103515245 + 12345) % 2147483648
        r2: int = rng % 3
        new_vx: int = vx // 2 + r1 * (bpx - px) // 2 + r2 * (global_bx - px) // 2
        new_vy: int = vy // 2 + r1 * (bpy - py) // 2 + r2 * (global_by - py) // 2
        new_vx = clamp(new_vx, -5, 5)
        new_vy = clamp(new_vy, -5, 5)
        new_px: int = clamp(px + new_vx, -50, 50)
        new_py: int = clamp(py + new_vy, -50, 50)
        result.append(new_px)
        i = i + 1
    i = 0
    while i < n:
        px2: int = positions_x[i]
        py2: int = positions_y[i]
        vx2: int = velocities_x[i]
        vy2: int = velocities_y[i]
        bpx2: int = best_x[i]
        bpy2: int = best_y[i]
        rng = (rng * 1103515245 + 12345) % 2147483648
        r1b: int = rng % 3
        rng = (rng * 1103515245 + 12345) % 2147483648
        r2b: int = rng % 3
        nvy: int = vy2 // 2 + r1b * (bpy2 - py2) // 2 + r2b * (global_by - py2) // 2
        nvy = clamp(nvy, -5, 5)
        new_py2: int = clamp(py2 + nvy, -50, 50)
        result.append(new_py2)
        i = i + 1
    result.append(rng)
    return result


def find_global_best(positions_x: list[int], positions_y: list[int]) -> tuple[int, int]:
    """Find the particle closest to the optimum."""
    n: int = len(positions_x)
    best_idx: int = 0
    bx: int = positions_x[0]
    by: int = positions_y[0]
    best_obj: int = objective_2d(bx, by)
    i: int = 1
    while i < n:
        cx: int = positions_x[i]
        cy: int = positions_y[i]
        obj: int = objective_2d(cx, cy)
        if obj < best_obj:
            best_obj = obj
            best_idx = i
        i = i + 1
    gx: int = positions_x[best_idx]
    gy: int = positions_y[best_idx]
    return (gx, gy)


def test_module() -> int:
    """Test PSO functions."""
    passed: int = 0

    obj_at_opt: int = objective_2d(7, 3)
    if obj_at_opt == 0:
        passed = passed + 1

    obj_away: int = objective_2d(0, 0)
    if obj_away == 58:
        passed = passed + 1

    c1: int = clamp(10, 0, 5)
    if c1 == 5:
        passed = passed + 1

    c2: int = clamp(-3, 0, 5)
    if c2 == 0:
        passed = passed + 1

    gb: tuple[int, int] = find_global_best([0, 7, 3], [0, 3, 1])
    gbx: int = gb[0]
    gby: int = gb[1]
    if gbx == 7 and gby == 3:
        passed = passed + 1

    c3: int = clamp(3, 0, 5)
    if c3 == 3:
        passed = passed + 1

    return passed
