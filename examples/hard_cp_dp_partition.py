# Generated by: depyler corpus generator
# Source: hard_cp_dp_partition.py
#
# Partition and equal subset DP for transpiler stress testing.


def can_partition(nums: list[int]) -> bool:
    """Check if array can be partitioned into two equal-sum subsets."""
    total: int = 0
    i: int = 0
    while i < len(nums):
        total = total + nums[i]
        i = i + 1
    if total % 2 != 0:
        return False
    target: int = total // 2
    dp: list[bool] = [False] * (target + 1)
    dp[0] = True
    j: int = 0
    while j < len(nums):
        val: int = nums[j]
        k: int = target
        while k >= val:
            if dp[k - val]:
                dp[k] = True
            k = k - 1
        j = j + 1
    return dp[target]


def count_partitions(n: int) -> int:
    """Count integer partitions of n."""
    dp: list[int] = [0] * (n + 1)
    dp[0] = 1
    k: int = 1
    while k <= n:
        j: int = k
        while j <= n:
            dp[j] = dp[j] + dp[j - k]
            j = j + 1
        k = k + 1
    return dp[n]


def min_partition_diff(nums: list[int]) -> int:
    """Minimum difference between two subset sums."""
    total: int = 0
    i: int = 0
    while i < len(nums):
        total = total + nums[i]
        i = i + 1
    half: int = total // 2
    dp: list[bool] = [False] * (half + 1)
    dp[0] = True
    j: int = 0
    while j < len(nums):
        val: int = nums[j]
        k: int = half
        while k >= val:
            if dp[k - val]:
                dp[k] = True
            k = k - 1
        j = j + 1
    best: int = 0
    m: int = 0
    while m <= half:
        if dp[m]:
            best = m
        m = m + 1
    return total - 2 * best


def partition_into_k_equal(nums: list[int], num_parts: int) -> bool:
    """Check if array can be split into k subsets of equal sum."""
    total: int = 0
    i: int = 0
    while i < len(nums):
        total = total + nums[i]
        i = i + 1
    if total % num_parts != 0:
        return False
    target: int = total // num_parts
    n: int = len(nums)
    full_mask: int = (1 << n) - 1
    num_states: int = 1 << n
    dp: list[int] = [0 - 1] * num_states
    dp[0] = 0
    mask: int = 0
    while mask <= full_mask:
        if dp[mask] >= 0:
            bit: int = 0
            while bit < n:
                if (mask & (1 << bit)) == 0:
                    new_mask: int = mask | (1 << bit)
                    new_sum: int = dp[mask] + nums[bit]
                    if new_sum <= target:
                        if new_sum == target:
                            dp[new_mask] = 0
                        else:
                            if dp[new_mask] < new_sum:
                                dp[new_mask] = new_sum
                bit = bit + 1
        mask = mask + 1
    if dp[full_mask] == 0:
        return True
    return False


def test_module() -> int:
    passed: int = 0
    if can_partition([1, 5, 11, 5]) == True:
        passed = passed + 1
    if can_partition([1, 2, 3, 5]) == False:
        passed = passed + 1
    if count_partitions(5) == 7:
        passed = passed + 1
    if min_partition_diff([1, 6, 11, 5]) == 1:
        passed = passed + 1
    if partition_into_k_equal([4, 3, 2, 3, 5, 2, 1], 4) == True:
        passed = passed + 1
    if count_partitions(0) == 1:
        passed = passed + 1
    return passed
