# Generated by: depyler corpus generator
# Source: hard_adv_hash_perfect.py
#
# Perfect hashing: construct a collision-free hash for a known set of keys.


def trial_hash(keys: list[int], multiplier: int, table_size: int) -> list[int]:
    """Hash each element: (element * multiplier) % table_size."""
    result: list[int] = []
    i: int = 0
    n: int = len(keys)
    while i < n:
        val: int = keys[i]
        h: int = (val * multiplier) % table_size
        result.append(h)
        i = i + 1
    return result


def has_collision(hashes: list[int]) -> int:
    """Check if any two hashes collide. Returns 1 if collision, 0 otherwise."""
    n: int = len(hashes)
    i: int = 0
    while i < n:
        j: int = i + 1
        while j < n:
            vi: int = hashes[i]
            vj: int = hashes[j]
            if vi == vj:
                return 1
            j = j + 1
        i = i + 1
    return 0


def find_perfect_multiplier(keys: list[int], table_size: int) -> int:
    """Find a multiplier that gives collision-free hashing, or -1."""
    mult: int = 1
    while mult < table_size * 2:
        hashes: list[int] = trial_hash(keys, mult, table_size)
        collision: int = has_collision(hashes)
        if collision == 0:
            return mult
        mult = mult + 1
    return -1


def build_lookup_table(keys: list[int], values: list[int], multiplier: int, table_size: int) -> list[int]:
    """Build a direct-address table using perfect hash. Empty slots = -1."""
    tbl: list[int] = []
    i: int = 0
    while i < table_size:
        tbl.append(-1)
        i = i + 1
    j: int = 0
    n: int = len(keys)
    while j < n:
        kv: int = keys[j]
        vv: int = values[j]
        idx: int = (kv * multiplier) % table_size
        tbl[idx] = vv
        j = j + 1
    return tbl


def perfect_lookup(tbl: list[int], lookup_key: int, multiplier: int, table_size: int) -> int:
    """Look up a value from the perfect hash table."""
    idx: int = (lookup_key * multiplier) % table_size
    return tbl[idx]


def test_module() -> int:
    """Test perfect hashing functions."""
    passed: int = 0

    h1: list[int] = trial_hash([2, 5, 9], 3, 16)
    if len(h1) == 3:
        passed = passed + 1

    no_col: int = has_collision([0, 1, 2, 3])
    if no_col == 0:
        passed = passed + 1

    yes_col: int = has_collision([0, 1, 2, 1])
    if yes_col == 1:
        passed = passed + 1

    mult: int = find_perfect_multiplier([2, 5, 9], 16)
    if mult > 0:
        passed = passed + 1

    keys: list[int] = [2, 5, 9]
    vals: list[int] = [100, 200, 300]
    m2: int = find_perfect_multiplier(keys, 16)
    tbl: list[int] = build_lookup_table(keys, vals, m2, 16)
    v1: int = perfect_lookup(tbl, 2, m2, 16)
    if v1 == 100:
        passed = passed + 1

    v2: int = perfect_lookup(tbl, 9, m2, 16)
    if v2 == 300:
        passed = passed + 1

    return passed
