# Generated by: depyler corpus generator
# Source: hard_cp_dp_lis.py
#
# Longest Increasing Subsequence variants for transpiler stress testing.


def lis_length(nums: list[int]) -> int:
    """Length of longest strictly increasing subsequence via O(n^2) DP."""
    n: int = len(nums)
    if n == 0:
        return 0
    dp: list[int] = [1] * n
    i: int = 1
    while i < n:
        j: int = 0
        while j < i:
            val_j: int = nums[j]
            val_i: int = nums[i]
            if val_j < val_i:
                cand: int = dp[j] + 1
                if cand > dp[i]:
                    dp[i] = cand
            j = j + 1
        i = i + 1
    best: int = 0
    k: int = 0
    while k < n:
        if dp[k] > best:
            best = dp[k]
        k = k + 1
    return best


def lis_count(nums: list[int]) -> int:
    """Count number of distinct LIS of maximum length."""
    n: int = len(nums)
    if n == 0:
        return 0
    dp_len: list[int] = [1] * n
    dp_cnt: list[int] = [1] * n
    i: int = 1
    while i < n:
        j: int = 0
        while j < i:
            val_j: int = nums[j]
            val_i: int = nums[i]
            if val_j < val_i:
                cand: int = dp_len[j] + 1
                if cand > dp_len[i]:
                    dp_len[i] = cand
                    dp_cnt[i] = dp_cnt[j]
                elif cand == dp_len[i]:
                    dp_cnt[i] = dp_cnt[i] + dp_cnt[j]
            j = j + 1
        i = i + 1
    max_len: int = 0
    k: int = 0
    while k < n:
        if dp_len[k] > max_len:
            max_len = dp_len[k]
        k = k + 1
    total: int = 0
    m: int = 0
    while m < n:
        if dp_len[m] == max_len:
            total = total + dp_cnt[m]
        m = m + 1
    return total


def lis_binary_search(nums: list[int]) -> int:
    """LIS length via patience sorting with binary search O(n log n)."""
    tails: list[int] = []
    i: int = 0
    while i < len(nums):
        val: int = nums[i]
        lo: int = 0
        hi: int = len(tails)
        while lo < hi:
            mid: int = (lo + hi) // 2
            mid_val: int = tails[mid]
            if mid_val < val:
                lo = mid + 1
            else:
                hi = mid
        if lo == len(tails):
            tails.append(val)
        else:
            tails[lo] = val
        i = i + 1
    return len(tails)


def longest_non_decreasing(nums: list[int]) -> int:
    """Length of longest non-decreasing subsequence."""
    n: int = len(nums)
    if n == 0:
        return 0
    dp: list[int] = [1] * n
    i: int = 1
    while i < n:
        j: int = 0
        while j < i:
            val_j: int = nums[j]
            val_i: int = nums[i]
            if val_j <= val_i:
                cand: int = dp[j] + 1
                if cand > dp[i]:
                    dp[i] = cand
            j = j + 1
        i = i + 1
    best: int = 0
    k: int = 0
    while k < n:
        if dp[k] > best:
            best = dp[k]
        k = k + 1
    return best


def lis_with_path(nums: list[int]) -> list[int]:
    """Return one actual LIS sequence via parent tracking."""
    n: int = len(nums)
    if n == 0:
        return []
    dp: list[int] = [1] * n
    parent: list[int] = [0 - 1] * n
    i: int = 1
    while i < n:
        j: int = 0
        while j < i:
            val_j: int = nums[j]
            val_i: int = nums[i]
            if val_j < val_i:
                cand: int = dp[j] + 1
                if cand > dp[i]:
                    dp[i] = cand
                    parent[i] = j
            j = j + 1
        i = i + 1
    best_len: int = 0
    best_idx: int = 0
    k: int = 0
    while k < n:
        if dp[k] > best_len:
            best_len = dp[k]
            best_idx = k
        k = k + 1
    result: list[int] = []
    pos: int = best_idx
    while pos != 0 - 1:
        result.append(nums[pos])
        pos = parent[pos]
    left: int = 0
    right: int = len(result) - 1
    while left < right:
        tmp: int = result[left]
        result[left] = result[right]
        result[right] = tmp
        left = left + 1
        right = right - 1
    return result


def test_module() -> int:
    passed: int = 0
    if lis_length([10, 9, 2, 5, 3, 7, 101, 18]) == 4:
        passed = passed + 1
    if lis_length([]) == 0:
        passed = passed + 1
    if lis_count([1, 3, 5, 4, 7]) == 2:
        passed = passed + 1
    if lis_binary_search([10, 9, 2, 5, 3, 7, 101, 18]) == 4:
        passed = passed + 1
    if longest_non_decreasing([1, 2, 2, 3]) == 4:
        passed = passed + 1
    path: list[int] = lis_with_path([10, 9, 2, 5, 3, 7, 101, 18])
    if len(path) == 4:
        passed = passed + 1
    if lis_length([7, 7, 7, 7]) == 1:
        passed = passed + 1
    return passed
