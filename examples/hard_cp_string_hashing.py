# Generated by: depyler corpus generator
# Source: hard_cp_string_hashing.py
#
# String hashing (Rabin-Karp style) for transpiler stress testing.


def polynomial_hash(s: str, modulus: int) -> int:
    """Compute polynomial rolling hash of string."""
    h: int = 0
    i: int = 0
    while i < len(s):
        ch_val: int = ord(s[i])
        h = (h * 31 + ch_val) % modulus
        i = i + 1
    return h


def rabin_karp_count(text: str, pat: str) -> int:
    """Count pattern occurrences using Rabin-Karp rolling hash."""
    n: int = len(text)
    m: int = len(pat)
    if m == 0 or m > n:
        return 0
    modulus: int = 1000000007
    pat_hash: int = 0
    text_hash: int = 0
    power: int = 1
    i: int = 0
    while i < m - 1:
        power = (power * 31) % modulus
        i = i + 1
    j: int = 0
    while j < m:
        pat_hash = (pat_hash * 31 + ord(pat[j])) % modulus
        text_hash = (text_hash * 31 + ord(text[j])) % modulus
        j = j + 1
    count: int = 0
    pos: int = 0
    while pos <= n - m:
        if text_hash == pat_hash:
            matched: int = 1
            k: int = 0
            while k < m:
                if text[pos + k] != pat[k]:
                    matched = 0
                    k = m
                k = k + 1
            if matched == 1:
                count = count + 1
        if pos < n - m:
            old_ch: int = ord(text[pos])
            new_ch: int = ord(text[pos + m])
            text_hash = ((text_hash - old_ch * power) * 31 + new_ch) % modulus
            if text_hash < 0:
                text_hash = text_hash + modulus
        pos = pos + 1
    return count


def string_hash_equal(s1: str, s2: str) -> int:
    """Compare two strings by hash. Returns 1 if likely equal, 0 otherwise."""
    if len(s1) != len(s2):
        return 0
    h1: int = polynomial_hash(s1, 1000000007)
    h2: int = polynomial_hash(s2, 1000000007)
    if h1 == h2:
        return 1
    return 0


def count_distinct_substrings(s: str, sub_len: int) -> int:
    """Count distinct substrings of given length using hashing."""
    n: int = len(s)
    if sub_len > n or sub_len == 0:
        return 0
    modulus: int = 1000000007
    hashes: list[int] = []
    power: int = 1
    i: int = 0
    while i < sub_len - 1:
        power = (power * 31) % modulus
        i = i + 1
    h: int = 0
    j: int = 0
    while j < sub_len:
        h = (h * 31 + ord(s[j])) % modulus
        j = j + 1
    hashes.append(h)
    pos: int = 1
    while pos <= n - sub_len:
        old_ch: int = ord(s[pos - 1])
        new_ch: int = ord(s[pos + sub_len - 1])
        h = ((h - old_ch * power) * 31 + new_ch) % modulus
        if h < 0:
            h = h + modulus
        found: int = 0
        ki: int = 0
        while ki < len(hashes):
            if hashes[ki] == h:
                found = 1
                ki = len(hashes)
            ki = ki + 1
        if found == 0:
            hashes.append(h)
        pos = pos + 1
    return len(hashes)


def test_module() -> int:
    passed: int = 0
    if polynomial_hash("abc", 1000000007) > 0:
        passed = passed + 1
    if rabin_karp_count("ababab", "ab") == 3:
        passed = passed + 1
    if rabin_karp_count("hello", "xyz") == 0:
        passed = passed + 1
    if string_hash_equal("abc", "abc") == 1:
        passed = passed + 1
    if count_distinct_substrings("aabaa", 2) >= 2:
        passed = passed + 1
    return passed
