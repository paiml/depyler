# Generated by: depyler corpus generator
# Source: hard_cp_ds_monotonic.py
#
# Monotonic queue and stack for transpiler stress testing.


def sliding_window_max(nums: list[int], window: int) -> list[int]:
    """Maximum in each sliding window using monotonic deque (list-based)."""
    n: int = len(nums)
    if n == 0 or window == 0:
        return []
    result: list[int] = []
    deq: list[int] = []
    i: int = 0
    while i < n:
        if len(deq) > 0 and deq[0] < i - window + 1:
            new_deq: list[int] = []
            j: int = 1
            while j < len(deq):
                new_deq.append(deq[j])
                j = j + 1
            deq = new_deq
        removing: int = 1
        while removing == 1:
            if len(deq) == 0:
                removing = 0
            else:
                back: int = deq[len(deq) - 1]
                if nums[back] <= nums[i]:
                    deq.pop()
                else:
                    removing = 0
        deq.append(i)
        if i >= window - 1:
            front_idx: int = deq[0]
            result.append(nums[front_idx])
        i = i + 1
    return result


def next_greater_element(arr: list[int]) -> list[int]:
    """For each element, find next greater to the right using monotonic stack."""
    n: int = len(arr)
    result: list[int] = [0 - 1] * n
    stack: list[int] = []
    i: int = 0
    while i < n:
        removing: int = 1
        while removing == 1:
            if len(stack) == 0:
                removing = 0
            else:
                top_idx: int = stack[len(stack) - 1]
                if arr[top_idx] < arr[i]:
                    stack.pop()
                    result[top_idx] = arr[i]
                else:
                    removing = 0
        stack.append(i)
        i = i + 1
    return result


def largest_rectangle_histogram(heights: list[int]) -> int:
    """Largest rectangle in histogram using monotonic stack."""
    n: int = len(heights)
    stack: list[int] = []
    max_area: int = 0
    i: int = 0
    while i <= n:
        if i < n:
            curr_h: int = heights[i]
        else:
            curr_h = 0
        removing: int = 1
        while removing == 1:
            if len(stack) == 0:
                removing = 0
            else:
                top_idx: int = stack[len(stack) - 1]
                if heights[top_idx] > curr_h:
                    stack.pop()
                    h: int = heights[top_idx]
                    if len(stack) == 0:
                        w: int = i
                    else:
                        w = i - stack[len(stack) - 1] - 1
                    area: int = h * w
                    if area > max_area:
                        max_area = area
                else:
                    removing = 0
        stack.append(i)
        i = i + 1
    return max_area


def previous_smaller_element(arr: list[int]) -> list[int]:
    """For each element, find previous smaller element using monotonic stack."""
    n: int = len(arr)
    result: list[int] = [0 - 1] * n
    stack: list[int] = []
    i: int = 0
    while i < n:
        removing: int = 1
        while removing == 1:
            if len(stack) == 0:
                removing = 0
            else:
                top_idx: int = stack[len(stack) - 1]
                if arr[top_idx] >= arr[i]:
                    stack.pop()
                else:
                    removing = 0
        if len(stack) > 0:
            result[i] = arr[stack[len(stack) - 1]]
        stack.append(i)
        i = i + 1
    return result


def test_module() -> int:
    passed: int = 0
    maxes: list[int] = sliding_window_max([1, 3, 0 - 1, 0 - 3, 5, 3, 6, 7], 3)
    if maxes[0] == 3 and maxes[1] == 3:
        passed = passed + 1
    nge: list[int] = next_greater_element([4, 5, 2, 25])
    if nge[0] == 5 and nge[2] == 25:
        passed = passed + 1
    if largest_rectangle_histogram([2, 1, 5, 6, 2, 3]) == 10:
        passed = passed + 1
    if largest_rectangle_histogram([1]) == 1:
        passed = passed + 1
    pse: list[int] = previous_smaller_element([4, 2, 1, 5, 3])
    if pse[0] == 0 - 1 and pse[3] == 1:
        passed = passed + 1
    return passed
