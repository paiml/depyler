# Generated by: depyler corpus generator
# Source: hard_cp_dp_coinchange.py
#
# Coin change variants for transpiler stress testing.


def coin_change_min(coins: list[int], amount: int) -> int:
    """Minimum number of coins to make amount. Returns -1 if impossible."""
    if amount == 0:
        return 0
    big: int = amount + 1
    dp: list[int] = [big] * (amount + 1)
    dp[0] = 0
    i: int = 1
    while i <= amount:
        j: int = 0
        while j < len(coins):
            c: int = coins[j]
            if c <= i:
                prev: int = dp[i - c]
                cand: int = prev + 1
                if cand < dp[i]:
                    dp[i] = cand
            j = j + 1
        i = i + 1
    result: int = dp[amount]
    if result > amount:
        return 0 - 1
    return result


def coin_change_ways(coins: list[int], amount: int) -> int:
    """Count distinct ways to make amount using given coins."""
    dp: list[int] = [0] * (amount + 1)
    dp[0] = 1
    j: int = 0
    while j < len(coins):
        c: int = coins[j]
        i: int = c
        while i <= amount:
            dp[i] = dp[i] + dp[i - c]
            i = i + 1
        j = j + 1
    return dp[amount]


def coin_change_permutations(coins: list[int], amount: int) -> int:
    """Count ordered arrangements to make amount (order matters)."""
    dp: list[int] = [0] * (amount + 1)
    dp[0] = 1
    i: int = 1
    while i <= amount:
        j: int = 0
        while j < len(coins):
            c: int = coins[j]
            if c <= i:
                dp[i] = dp[i] + dp[i - c]
            j = j + 1
        i = i + 1
    return dp[amount]


def min_coins_with_limit(coins: list[int], limits: list[int], amount: int) -> int:
    """Min coins with limited supply per denomination. Returns -1 if impossible."""
    big: int = amount + 1
    dp: list[int] = [big] * (amount + 1)
    dp[0] = 0
    ci: int = 0
    while ci < len(coins):
        c: int = coins[ci]
        lim: int = limits[ci]
        j: int = amount
        while j >= c:
            k: int = 1
            while k <= lim:
                cost: int = c * k
                if cost <= j:
                    prev: int = dp[j - cost]
                    cand: int = prev + k
                    if cand < dp[j]:
                        dp[j] = cand
                k = k + 1
            j = j - 1
        ci = ci + 1
    if dp[amount] > amount:
        return 0 - 1
    return dp[amount]


def test_module() -> int:
    passed: int = 0
    if coin_change_min([1, 5, 10], 11) == 2:
        passed = passed + 1
    if coin_change_min([2], 3) == 0 - 1:
        passed = passed + 1
    if coin_change_ways([1, 2, 5], 5) == 4:
        passed = passed + 1
    if coin_change_permutations([1, 2, 3], 4) == 7:
        passed = passed + 1
    if min_coins_with_limit([1, 5], [5, 2], 11) == 3:
        passed = passed + 1
    if coin_change_min([1], 0) == 0:
        passed = passed + 1
    return passed
