# Generated by: depyler corpus generator
# Source: hard_cp_math_matexp.py
#
# Matrix exponentiation for transpiler stress testing.


def mat_mul_2x2(a: list[list[int]], b: list[list[int]], mod: int) -> list[list[int]]:
    """Multiply two 2x2 matrices modulo mod."""
    r00: int = (a[0][0] * b[0][0] + a[0][1] * b[1][0]) % mod
    r01: int = (a[0][0] * b[0][1] + a[0][1] * b[1][1]) % mod
    r10: int = (a[1][0] * b[0][0] + a[1][1] * b[1][0]) % mod
    r11: int = (a[1][0] * b[0][1] + a[1][1] * b[1][1]) % mod
    return [[r00, r01], [r10, r11]]


def mat_pow_2x2(mat: list[list[int]], exp: int, mod: int) -> list[list[int]]:
    """Raise 2x2 matrix to power exp modulo mod."""
    result: list[list[int]] = [[1, 0], [0, 1]]
    base_mat: list[list[int]] = [[mat[0][0], mat[0][1]], [mat[1][0], mat[1][1]]]
    e: int = exp
    while e > 0:
        if e % 2 == 1:
            result = mat_mul_2x2(result, base_mat, mod)
        base_mat = mat_mul_2x2(base_mat, base_mat, mod)
        e = e // 2
    return result


def fibonacci_mod(n: int, mod: int) -> int:
    """Compute F(n) mod m using matrix exponentiation."""
    if n <= 0:
        return 0
    if n == 1:
        return 1 % mod
    fib_mat: list[list[int]] = [[1, 1], [1, 0]]
    result: list[list[int]] = mat_pow_2x2(fib_mat, n - 1, mod)
    return result[0][0]


def mat_mul_nxn(a: list[list[int]], b: list[list[int]], n: int, mod: int) -> list[list[int]]:
    """Multiply two nxn matrices modulo mod."""
    result: list[list[int]] = []
    i: int = 0
    while i < n:
        row: list[int] = [0] * n
        result.append(row)
        i = i + 1
    i2: int = 0
    while i2 < n:
        j: int = 0
        while j < n:
            total: int = 0
            k: int = 0
            while k < n:
                total = (total + a[i2][k] * b[k][j]) % mod
                k = k + 1
            result[i2][j] = total
            j = j + 1
        i2 = i2 + 1
    return result


def tribonacci_mod(n: int, mod: int) -> int:
    """T(n) mod m where T(0)=0, T(1)=0, T(2)=1 using 3x3 matrix exp."""
    if n < 2:
        return 0
    if n == 2:
        return 1 % mod
    mat: list[list[int]] = [[1, 1, 1], [1, 0, 0], [0, 1, 0]]
    result: list[list[int]] = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
    e: int = n - 2
    while e > 0:
        if e % 2 == 1:
            result = mat_mul_nxn(result, mat, 3, mod)
        mat = mat_mul_nxn(mat, mat, 3, mod)
        e = e // 2
    return result[0][0]


def test_module() -> int:
    passed: int = 0
    if fibonacci_mod(10, 1000000007) == 55:
        passed = passed + 1
    if fibonacci_mod(50, 1000000007) == 586268941:
        passed = passed + 1
    if fibonacci_mod(0, 100) == 0:
        passed = passed + 1
    if tribonacci_mod(4, 1000000007) == 2:
        passed = passed + 1
    r: list[list[int]] = mat_mul_2x2([[1, 2], [3, 4]], [[5, 6], [7, 8]], 1000000007)
    if r[0][0] == 19:
        passed = passed + 1
    return passed
