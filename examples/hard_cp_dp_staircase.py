# Generated by: depyler corpus generator
# Source: hard_cp_dp_staircase.py
#
# Staircase climbing and path counting DP for transpiler stress testing.


def climb_stairs_2(n: int) -> int:
    """Count ways to climb n stairs with 1 or 2 steps."""
    if n <= 0:
        return 0
    if n == 1:
        return 1
    if n == 2:
        return 2
    prev2: int = 1
    prev1: int = 2
    i: int = 3
    while i <= n:
        curr: int = prev1 + prev2
        prev2 = prev1
        prev1 = curr
        i = i + 1
    return prev1


def climb_stairs_3(n: int) -> int:
    """Count ways to climb n stairs with 1, 2, or 3 steps."""
    if n <= 0:
        return 0
    if n == 1:
        return 1
    if n == 2:
        return 2
    if n == 3:
        return 4
    dp: list[int] = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1
    dp[2] = 2
    dp[3] = 4
    i: int = 4
    while i <= n:
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]
        i = i + 1
    return dp[n]


def climb_stairs_k(n: int, max_step: int) -> int:
    """Count ways to climb n stairs with steps 1..max_step."""
    if n <= 0:
        return 0
    dp: list[int] = [0] * (n + 1)
    dp[0] = 1
    i: int = 1
    while i <= n:
        s: int = 1
        while s <= max_step:
            if s <= i:
                dp[i] = dp[i] + dp[i - s]
            s = s + 1
        i = i + 1
    return dp[n]


def min_cost_stairs(costs: list[int]) -> int:
    """Minimum cost to reach the top of stairs."""
    n: int = len(costs)
    if n == 0:
        return 0
    if n == 1:
        return costs[0]
    dp: list[int] = [0] * n
    dp[0] = costs[0]
    dp[1] = costs[1]
    i: int = 2
    while i < n:
        a: int = dp[i - 1]
        b: int = dp[i - 2]
        if a < b:
            dp[i] = a + costs[i]
        else:
            dp[i] = b + costs[i]
        i = i + 1
    last: int = dp[n - 1]
    second_last: int = dp[n - 2]
    if last < second_last:
        return last
    return second_last


def unique_paths_grid(rows: int, cols: int) -> int:
    """Count unique paths from top-left to bottom-right."""
    dp: list[list[int]] = []
    r: int = 0
    while r < rows:
        row: list[int] = [0] * cols
        dp.append(row)
        r = r + 1
    i: int = 0
    while i < rows:
        dp[i][0] = 1
        i = i + 1
    j: int = 0
    while j < cols:
        dp[0][j] = 1
        j = j + 1
    i2: int = 1
    while i2 < rows:
        j2: int = 1
        while j2 < cols:
            dp[i2][j2] = dp[i2 - 1][j2] + dp[i2][j2 - 1]
            j2 = j2 + 1
        i2 = i2 + 1
    return dp[rows - 1][cols - 1]


def unique_paths_with_obstacles(grid: list[list[int]]) -> int:
    """Count unique paths avoiding obstacles (1 = obstacle)."""
    rows: int = len(grid)
    if rows == 0:
        return 0
    cols: int = len(grid[0])
    if cols == 0:
        return 0
    if grid[0][0] == 1:
        return 0
    dp: list[list[int]] = []
    r: int = 0
    while r < rows:
        row: list[int] = [0] * cols
        dp.append(row)
        r = r + 1
    dp[0][0] = 1
    i: int = 1
    while i < rows:
        g_val: int = grid[i][0]
        if g_val == 0 and dp[i - 1][0] == 1:
            dp[i][0] = 1
        i = i + 1
    j: int = 1
    while j < cols:
        g_val2: int = grid[0][j]
        if g_val2 == 0 and dp[0][j - 1] == 1:
            dp[0][j] = 1
        j = j + 1
    i2: int = 1
    while i2 < rows:
        j2: int = 1
        while j2 < cols:
            g_val3: int = grid[i2][j2]
            if g_val3 == 0:
                dp[i2][j2] = dp[i2 - 1][j2] + dp[i2][j2 - 1]
            j2 = j2 + 1
        i2 = i2 + 1
    return dp[rows - 1][cols - 1]


def test_module() -> int:
    passed: int = 0
    if climb_stairs_2(5) == 8:
        passed = passed + 1
    if climb_stairs_3(4) == 7:
        passed = passed + 1
    if climb_stairs_k(4, 3) == 7:
        passed = passed + 1
    if min_cost_stairs([10, 15, 20]) == 15:
        passed = passed + 1
    if unique_paths_grid(3, 7) == 28:
        passed = passed + 1
    obstacle_grid: list[list[int]] = [[0, 0, 0], [0, 1, 0], [0, 0, 0]]
    if unique_paths_with_obstacles(obstacle_grid) == 2:
        passed = passed + 1
    return passed
