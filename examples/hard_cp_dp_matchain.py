# Generated by: depyler corpus generator
# Source: hard_cp_dp_matchain.py
#
# Matrix chain multiplication and interval DP for transpiler stress testing.


def matrix_chain_min(dims: list[int]) -> int:
    """Minimum scalar multiplications for matrix chain."""
    n: int = len(dims) - 1
    if n <= 1:
        return 0
    dp: list[list[int]] = []
    r: int = 0
    while r < n:
        row: list[int] = [0] * n
        dp.append(row)
        r = r + 1
    chain_len: int = 2
    while chain_len <= n:
        i: int = 0
        while i <= n - chain_len:
            j: int = i + chain_len - 1
            dp[i][j] = 999999999
            k: int = i
            while k < j:
                dim_i: int = dims[i]
                dim_k1: int = dims[k + 1]
                dim_j1: int = dims[j + 1]
                cost: int = dp[i][k] + dp[k + 1][j] + dim_i * dim_k1 * dim_j1
                if cost < dp[i][j]:
                    dp[i][j] = cost
                k = k + 1
            i = i + 1
        chain_len = chain_len + 1
    return dp[0][n - 1]


def burst_balloons(nums: list[int]) -> int:
    """Maximum coins from bursting all balloons (interval DP)."""
    n: int = len(nums)
    if n == 0:
        return 0
    vals: list[int] = [1] * (n + 2)
    i: int = 0
    while i < n:
        vals[i + 1] = nums[i]
        i = i + 1
    sz: int = n + 2
    dp: list[list[int]] = []
    r: int = 0
    while r < sz:
        row: list[int] = [0] * sz
        dp.append(row)
        r = r + 1
    length: int = 2
    while length < sz:
        left: int = 0
        while left < sz - length:
            right: int = left + length
            k: int = left + 1
            while k < right:
                coins: int = vals[left] * vals[k] * vals[right]
                total: int = dp[left][k] + dp[k][right] + coins
                if total > dp[left][right]:
                    dp[left][right] = total
                k = k + 1
            left = left + 1
        length = length + 1
    return dp[0][n + 1]


def optimal_bst_cost(freq: list[int]) -> int:
    """Optimal binary search tree cost (similar to matrix chain)."""
    n: int = len(freq)
    if n == 0:
        return 0
    dp: list[list[int]] = []
    prefix: list[int] = [0] * (n + 1)
    i: int = 0
    while i < n:
        prefix[i + 1] = prefix[i] + freq[i]
        i = i + 1
    r: int = 0
    while r <= n:
        row: list[int] = [0] * (n + 1)
        dp.append(row)
        r = r + 1
    i2: int = 0
    while i2 < n:
        dp[i2][i2 + 1] = freq[i2]
        i2 = i2 + 1
    length: int = 2
    while length <= n:
        start: int = 0
        while start <= n - length:
            end: int = start + length
            dp[start][end] = 999999999
            range_sum: int = prefix[end] - prefix[start]
            k: int = start
            while k < end:
                cost: int = dp[start][k] + dp[k + 1][end] + range_sum
                if cost < dp[start][end]:
                    dp[start][end] = cost
                k = k + 1
            start = start + 1
        length = length + 1
    return dp[0][n]


def test_module() -> int:
    passed: int = 0
    if matrix_chain_min([10, 30, 5, 60]) == 4500:
        passed = passed + 1
    if matrix_chain_min([40, 20, 30, 10, 30]) == 26000:
        passed = passed + 1
    if burst_balloons([3, 1, 5, 8]) == 167:
        passed = passed + 1
    if burst_balloons([]) == 0:
        passed = passed + 1
    if optimal_bst_cost([34, 8, 50]) == 142:
        passed = passed + 1
    if matrix_chain_min([5, 10]) == 0:
        passed = passed + 1
    return passed
