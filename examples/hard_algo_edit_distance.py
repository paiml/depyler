# Generated by: depyler corpus generator
# Source: hard_algo_edit_distance.py
#
# Levenshtein edit distance with variants.


def edit_distance(word1: str, word2: str) -> int:
    """Compute Levenshtein edit distance between two strings."""
    m: int = len(word1)
    n: int = len(word2)
    dp: List[List[int]] = []
    r: int = 0
    while r <= m:
        row: List[int] = [0] * (n + 1)
        dp.append(row)
        r = r + 1
    i: int = 0
    while i <= m:
        dp[i][0] = i
        i = i + 1
    j: int = 0
    while j <= n:
        dp[0][j] = j
        j = j + 1
    i = 1
    while i <= m:
        j = 1
        while j <= n:
            if word1[i - 1] == word2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                replace_c: int = dp[i - 1][j - 1] + 1
                insert_c: int = dp[i][j - 1] + 1
                delete_c: int = dp[i - 1][j] + 1
                best: int = replace_c
                if insert_c < best:
                    best = insert_c
                if delete_c < best:
                    best = delete_c
                dp[i][j] = best
            j = j + 1
        i = i + 1
    return dp[m][n]


def edit_distance_space_opt(word1: str, word2: str) -> int:
    """Space-optimized edit distance using two rows."""
    m: int = len(word1)
    n: int = len(word2)
    prev: List[int] = []
    j: int = 0
    while j <= n:
        prev.append(j)
        j = j + 1
    i: int = 1
    while i <= m:
        curr: List[int] = [i]
        j = 1
        while j <= n:
            if word1[i - 1] == word2[j - 1]:
                curr.append(prev[j - 1])
            else:
                replace_c: int = prev[j - 1] + 1
                insert_c: int = curr[j - 1] + 1
                delete_c: int = prev[j] + 1
                best: int = replace_c
                if insert_c < best:
                    best = insert_c
                if delete_c < best:
                    best = delete_c
                curr.append(best)
            j = j + 1
        prev = curr
        i = i + 1
    return prev[n]


def hamming_distance(s1: str, s2: str) -> int:
    """Hamming distance between two equal-length strings."""
    n1: int = len(s1)
    n2: int = len(s2)
    if n1 != n2:
        return -1
    dist: int = 0
    i: int = 0
    while i < n1:
        if s1[i] != s2[i]:
            dist = dist + 1
        i = i + 1
    return dist


def one_edit_distance(s1: str, s2: str) -> int:
    """Check if two strings are exactly one edit apart. Returns 1 or 0."""
    m: int = len(s1)
    n: int = len(s2)
    diff: int = m - n
    if diff < 0:
        diff = 0 - diff
    if diff > 1:
        return 0
    if m > n:
        check_result: int = one_edit_check(s1, s2)
        return check_result
    elif n > m:
        check_result2: int = one_edit_check(s2, s1)
        return check_result2
    else:
        changes: int = 0
        i: int = 0
        while i < m:
            if s1[i] != s2[i]:
                changes = changes + 1
            i = i + 1
        if changes == 1:
            return 1
        return 0


def one_edit_check(longer: str, shorter: str) -> int:
    """Helper: check if removing one char from longer gives shorter."""
    m: int = len(longer)
    n: int = len(shorter)
    i: int = 0
    j: int = 0
    diffs: int = 0
    while i < m and j < n:
        if longer[i] != shorter[j]:
            diffs = diffs + 1
            if diffs > 1:
                return 0
            i = i + 1
        else:
            i = i + 1
            j = j + 1
    return 1


def test_module() -> int:
    """Test all edit distance functions."""
    passed: int = 0

    r1: int = edit_distance("kitten", "sitting")
    if r1 == 3:
        passed = passed + 1

    r2: int = edit_distance("", "abc")
    if r2 == 3:
        passed = passed + 1

    r3: int = edit_distance("abc", "abc")
    if r3 == 0:
        passed = passed + 1

    r4: int = edit_distance_space_opt("kitten", "sitting")
    if r4 == 3:
        passed = passed + 1

    r5: int = hamming_distance("karolin", "kathrin")
    if r5 == 3:
        passed = passed + 1

    r6: int = hamming_distance("abc", "ab")
    if r6 == -1:
        passed = passed + 1

    r7: int = one_edit_distance("abc", "ab")
    if r7 == 1:
        passed = passed + 1

    r8: int = one_edit_distance("abc", "xyz")
    if r8 == 0:
        passed = passed + 1

    return passed
