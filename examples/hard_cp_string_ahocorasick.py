# Generated by: depyler corpus generator
# Source: hard_cp_string_ahocorasick.py
#
# Aho-Corasick-like multi-pattern matching for transpiler stress testing.
# Simplified: uses brute-force multi-pattern search (no trie).


def multi_pattern_count(text: str, patterns: list[str]) -> int:
    """Count total occurrences of all patterns in text (brute force)."""
    total: int = 0
    pi: int = 0
    while pi < len(patterns):
        pat: str = patterns[pi]
        m: int = len(pat)
        n: int = len(text)
        if m > 0 and m <= n:
            i: int = 0
            while i <= n - m:
                matched: int = 1
                j: int = 0
                while j < m:
                    if text[i + j] != pat[j]:
                        matched = 0
                        j = m
                    j = j + 1
                if matched == 1:
                    total = total + 1
                i = i + 1
        pi = pi + 1
    return total


def multi_pattern_any(text: str, patterns: list[str]) -> int:
    """Check if any pattern occurs in text. Returns 1 if found, 0 otherwise."""
    pi: int = 0
    while pi < len(patterns):
        pat: str = patterns[pi]
        m: int = len(pat)
        n: int = len(text)
        if m > 0 and m <= n:
            i: int = 0
            while i <= n - m:
                matched: int = 1
                j: int = 0
                while j < m:
                    if text[i + j] != pat[j]:
                        matched = 0
                        j = m
                    j = j + 1
                if matched == 1:
                    return 1
                i = i + 1
        pi = pi + 1
    return 0


def count_distinct_patterns_found(text: str, patterns: list[str]) -> int:
    """Count how many distinct patterns occur at least once."""
    found: int = 0
    pi: int = 0
    while pi < len(patterns):
        pat: str = patterns[pi]
        m: int = len(pat)
        n: int = len(text)
        located: int = 0
        if m > 0 and m <= n:
            i: int = 0
            while i <= n - m and located == 0:
                matched: int = 1
                j: int = 0
                while j < m:
                    if text[i + j] != pat[j]:
                        matched = 0
                        j = m
                    j = j + 1
                if matched == 1:
                    located = 1
                i = i + 1
        if located == 1:
            found = found + 1
        pi = pi + 1
    return found


def earliest_pattern_position(text: str, patterns: list[str]) -> int:
    """Find earliest position where any pattern starts. -1 if none found."""
    best: int = len(text) + 1
    pi: int = 0
    while pi < len(patterns):
        pat: str = patterns[pi]
        m: int = len(pat)
        n: int = len(text)
        if m > 0 and m <= n:
            i: int = 0
            while i <= n - m:
                matched: int = 1
                j: int = 0
                while j < m:
                    if text[i + j] != pat[j]:
                        matched = 0
                        j = m
                    j = j + 1
                if matched == 1:
                    if i < best:
                        best = i
                    i = n
                i = i + 1
        pi = pi + 1
    if best > len(text):
        return 0 - 1
    return best


def test_module() -> int:
    passed: int = 0
    if multi_pattern_count("abcabcabc", ["abc", "bc"]) == 6:
        passed = passed + 1
    if multi_pattern_any("hello", ["xyz", "llo"]) == 1:
        passed = passed + 1
    if multi_pattern_any("hello", ["xyz", "abc"]) == 0:
        passed = passed + 1
    if count_distinct_patterns_found("abcdef", ["ab", "cd", "xyz"]) == 2:
        passed = passed + 1
    if earliest_pattern_position("hello world", ["world", "llo"]) == 2:
        passed = passed + 1
    return passed
