# Generated by: depyler corpus generator
# Source: hard_cp_ds_treap.py
#
# Treap-like BST operations (array-based) for transpiler stress testing.


def bst_insert(tree_vals: list[int], val: int) -> list[int]:
    """Insert val into sorted list (BST-like)."""
    result: list[int] = []
    inserted: int = 0
    i: int = 0
    while i < len(tree_vals):
        if inserted == 0 and val < tree_vals[i]:
            result.append(val)
            inserted = 1
        result.append(tree_vals[i])
        i = i + 1
    if inserted == 0:
        result.append(val)
    return result


def bst_search(tree_vals: list[int], val: int) -> int:
    """Binary search in sorted list. Returns 1=found, 0=not found."""
    lo: int = 0
    hi: int = len(tree_vals) - 1
    while lo <= hi:
        mid: int = (lo + hi) // 2
        if tree_vals[mid] == val:
            return 1
        elif tree_vals[mid] < val:
            lo = mid + 1
        else:
            hi = mid - 1
    return 0


def bst_delete(tree_vals: list[int], val: int) -> list[int]:
    """Delete first occurrence of val from sorted list."""
    result: list[int] = []
    removed: int = 0
    i: int = 0
    while i < len(tree_vals):
        if removed == 0 and tree_vals[i] == val:
            removed = 1
        else:
            result.append(tree_vals[i])
        i = i + 1
    return result


def bst_lower_bound(tree_vals: list[int], val: int) -> int:
    """First element >= val. Returns -1 if none."""
    lo: int = 0
    hi: int = len(tree_vals) - 1
    result: int = 0 - 1
    while lo <= hi:
        mid: int = (lo + hi) // 2
        if tree_vals[mid] >= val:
            result = tree_vals[mid]
            hi = mid - 1
        else:
            lo = mid + 1
    return result


def bst_upper_bound(tree_vals: list[int], val: int) -> int:
    """First element > val. Returns -1 if none."""
    lo: int = 0
    hi: int = len(tree_vals) - 1
    result: int = 0 - 1
    while lo <= hi:
        mid: int = (lo + hi) // 2
        if tree_vals[mid] > val:
            result = tree_vals[mid]
            hi = mid - 1
        else:
            lo = mid + 1
    return result


def bst_kth(tree_vals: list[int], k: int) -> int:
    """Return k-th smallest (0-indexed)."""
    if k < 0 or k >= len(tree_vals):
        return 0 - 1
    return tree_vals[k]


def test_module() -> int:
    passed: int = 0
    tree: list[int] = []
    tree = bst_insert(tree, 5)
    tree = bst_insert(tree, 3)
    tree = bst_insert(tree, 7)
    tree = bst_insert(tree, 1)
    if tree == [1, 3, 5, 7]:
        passed = passed + 1
    if bst_search(tree, 3) == 1:
        passed = passed + 1
    if bst_search(tree, 4) == 0:
        passed = passed + 1
    tree = bst_delete(tree, 3)
    if tree == [1, 5, 7]:
        passed = passed + 1
    if bst_lower_bound([1, 5, 7], 4) == 5:
        passed = passed + 1
    if bst_kth([1, 5, 7], 1) == 5:
        passed = passed + 1
    return passed
