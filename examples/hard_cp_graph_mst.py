# Generated by: depyler corpus generator
# Source: hard_cp_graph_mst.py
#
# Minimum spanning tree variants for transpiler stress testing.


def find_root(parent: list[int], x: int) -> int:
    """Find root with path compression (iterative)."""
    curr: int = x
    while parent[curr] != curr:
        parent[curr] = parent[parent[curr]]
        curr = parent[curr]
    return curr


def union_sets(parent: list[int], rank_arr: list[int], x: int, y: int) -> int:
    """Union by rank. Returns 1 if merged, 0 if already same set."""
    rx: int = find_root(parent, x)
    ry: int = find_root(parent, y)
    if rx == ry:
        return 0
    if rank_arr[rx] < rank_arr[ry]:
        parent[rx] = ry
    elif rank_arr[rx] > rank_arr[ry]:
        parent[ry] = rx
    else:
        parent[ry] = rx
        rank_arr[rx] = rank_arr[rx] + 1
    return 1


def kruskal_mst(n: int, edges: list[list[int]]) -> int:
    """Kruskal MST. edges[i] = [u, v, weight]. Returns total MST weight."""
    num_edges: int = len(edges)
    sorted_edges: list[list[int]] = []
    i: int = 0
    while i < num_edges:
        e: list[int] = edges[i]
        sorted_edges.append([e[0], e[1], e[2]])
        i = i + 1
    a: int = 0
    while a < num_edges:
        b: int = a + 1
        while b < num_edges:
            wa: int = sorted_edges[a][2]
            wb: int = sorted_edges[b][2]
            if wb < wa:
                tmp0: int = sorted_edges[a][0]
                tmp1: int = sorted_edges[a][1]
                tmp2: int = sorted_edges[a][2]
                sorted_edges[a][0] = sorted_edges[b][0]
                sorted_edges[a][1] = sorted_edges[b][1]
                sorted_edges[a][2] = sorted_edges[b][2]
                sorted_edges[b][0] = tmp0
                sorted_edges[b][1] = tmp1
                sorted_edges[b][2] = tmp2
            b = b + 1
        a = a + 1
    parent: list[int] = [0] * n
    rank_arr: list[int] = [0] * n
    k: int = 0
    while k < n:
        parent[k] = k
        k = k + 1
    total: int = 0
    used: int = 0
    idx: int = 0
    while idx < num_edges and used < n - 1:
        u: int = sorted_edges[idx][0]
        v: int = sorted_edges[idx][1]
        w: int = sorted_edges[idx][2]
        merged: int = union_sets(parent, rank_arr, u, v)
        if merged == 1:
            total = total + w
            used = used + 1
        idx = idx + 1
    return total


def prim_mst(graph: list[list[int]]) -> int:
    """Prim MST using adjacency matrix. Returns total MST weight."""
    n: int = len(graph)
    if n == 0:
        return 0
    in_mst: list[int] = [0] * n
    min_edge: list[int] = [999999999] * n
    min_edge[0] = 0
    total: int = 0
    count: int = 0
    while count < n:
        u: int = 0 - 1
        best: int = 999999999
        i: int = 0
        while i < n:
            if in_mst[i] == 0 and min_edge[i] < best:
                best = min_edge[i]
                u = i
            i = i + 1
        if u == 0 - 1:
            count = n
        else:
            in_mst[u] = 1
            total = total + best
            v: int = 0
            while v < n:
                w: int = graph[u][v]
                if w > 0 and in_mst[v] == 0 and w < min_edge[v]:
                    min_edge[v] = w
                v = v + 1
            count = count + 1
    return total


def test_module() -> int:
    passed: int = 0
    edges: list[list[int]] = [
        [0, 1, 10], [0, 2, 6], [0, 3, 5],
        [1, 3, 15], [2, 3, 4],
    ]
    if kruskal_mst(4, edges) == 19:
        passed = passed + 1
    g: list[list[int]] = [
        [0, 2, 0, 6, 0],
        [2, 0, 3, 8, 5],
        [0, 3, 0, 0, 7],
        [6, 8, 0, 0, 9],
        [0, 5, 7, 9, 0],
    ]
    if prim_mst(g) == 16:
        passed = passed + 1
    edges2: list[list[int]] = [[0, 1, 1], [1, 2, 2], [0, 2, 3]]
    if kruskal_mst(3, edges2) == 3:
        passed = passed + 1
    if prim_mst([[0, 5], [5, 0]]) == 5:
        passed = passed + 1
    if kruskal_mst(1, []) == 0:
        passed = passed + 1
    return passed
