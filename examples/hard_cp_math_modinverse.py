# Generated by: depyler corpus generator
# Source: hard_cp_math_modinverse.py
#
# Modular arithmetic and modular inverse for transpiler stress testing.


def gcd(a: int, b: int) -> int:
    """Greatest common divisor using Euclidean algorithm."""
    x: int = a
    y: int = b
    while y != 0:
        tmp: int = y
        y = x % y
        x = tmp
    return x


def mod_pow(base_val: int, exp: int, mod: int) -> int:
    """Modular exponentiation: base^exp mod mod."""
    result: int = 1
    b: int = base_val % mod
    e: int = exp
    while e > 0:
        if e % 2 == 1:
            result = (result * b) % mod
        e = e // 2
        b = (b * b) % mod
    return result


def mod_inverse_fermat(a: int, p: int) -> int:
    """Modular inverse using Fermat's little theorem (p must be prime)."""
    return mod_pow(a, p - 2, p)


def extended_gcd(a: int, b: int) -> list[int]:
    """Extended GCD: returns [g, x, y] where ax + by = g."""
    if a == 0:
        return [b, 0, 1]
    old_r: int = a
    curr_r: int = b
    old_s: int = 1
    curr_s: int = 0
    old_t: int = 0
    curr_t: int = 1
    while curr_r != 0:
        quotient: int = old_r // curr_r
        tmp_r: int = curr_r
        curr_r = old_r - quotient * curr_r
        old_r = tmp_r
        tmp_s: int = curr_s
        curr_s = old_s - quotient * curr_s
        old_s = tmp_s
        tmp_t: int = curr_t
        curr_t = old_t - quotient * curr_t
        old_t = tmp_t
    return [old_r, old_s, old_t]


def mod_inverse_extended(a: int, m: int) -> int:
    """Modular inverse using extended GCD. Returns -1 if no inverse."""
    result: list[int] = extended_gcd(a, m)
    g: int = result[0]
    x: int = result[1]
    if g != 1:
        return 0 - 1
    return ((x % m) + m) % m


def test_module() -> int:
    passed: int = 0
    if gcd(12, 8) == 4:
        passed = passed + 1
    if mod_pow(2, 10, 1000) == 24:
        passed = passed + 1
    if mod_inverse_fermat(3, 7) == 5:
        passed = passed + 1
    egcd: list[int] = extended_gcd(35, 15)
    if egcd[0] == 5:
        passed = passed + 1
    if mod_inverse_extended(3, 11) == 4:
        passed = passed + 1
    return passed
