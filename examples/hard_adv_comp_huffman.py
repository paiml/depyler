# Generated by: depyler corpus generator
# Source: hard_adv_comp_huffman.py
#
# Huffman-like frequency-based encoding using integer sequences.


def count_frequencies(data: list[int], max_val: int) -> list[int]:
    """Count frequency of each value 0..max_val-1."""
    freq: list[int] = []
    i: int = 0
    while i < max_val:
        freq.append(0)
        i = i + 1
    j: int = 0
    n: int = len(data)
    while j < n:
        val: int = data[j]
        if val >= 0 and val < max_val:
            old: int = freq[val]
            freq[val] = old + 1
        j = j + 1
    return freq


def find_two_smallest(freq: list[int], used: list[int]) -> tuple[int, int]:
    """Find indices of two smallest non-zero, non-used frequencies."""
    min1_idx: int = -1
    min1_val: int = 999999999
    min2_idx: int = -1
    min2_val: int = 999999999
    i: int = 0
    n: int = len(freq)
    while i < n:
        fv: int = freq[i]
        uv: int = used[i]
        if fv > 0 and uv == 0:
            if fv < min1_val:
                min2_val = min1_val
                min2_idx = min1_idx
                min1_val = fv
                min1_idx = i
            elif fv < min2_val:
                min2_val = fv
                min2_idx = i
        i = i + 1
    return (min1_idx, min2_idx)


def assign_code_lengths(freq: list[int]) -> list[int]:
    """Assign bit lengths based on frequency ranking. Higher freq = shorter code."""
    n: int = len(freq)
    lengths: list[int] = []
    i: int = 0
    while i < n:
        lengths.append(0)
        i = i + 1
    sorted_indices: list[int] = []
    used: list[int] = []
    k: int = 0
    while k < n:
        used.append(0)
        k = k + 1
    active: int = 0
    m: int = 0
    while m < n:
        fv: int = freq[m]
        if fv > 0:
            active = active + 1
        m = m + 1
    step: int = 0
    while step < active:
        best_idx: int = -1
        best_val: int = -1
        q: int = 0
        while q < n:
            fq: int = freq[q]
            uq: int = used[q]
            if fq > 0 and uq == 0:
                if fq > best_val:
                    best_val = fq
                    best_idx = q
            q = q + 1
        if best_idx >= 0:
            sorted_indices.append(best_idx)
            used[best_idx] = 1
        step = step + 1
    j: int = 0
    ns: int = len(sorted_indices)
    while j < ns:
        idx: int = sorted_indices[j]
        lengths[idx] = j + 1
        j = j + 1
    return lengths


def estimate_encoded_size(freq: list[int], code_lengths: list[int]) -> int:
    """Estimate total encoded size in bits."""
    total: int = 0
    i: int = 0
    n: int = len(freq)
    while i < n:
        fv: int = freq[i]
        cl: int = code_lengths[i]
        total = total + fv * cl
        i = i + 1
    return total


def entropy_lower_bound(freq: list[int], total_symbols: int) -> int:
    """Approximate entropy lower bound (integer approximation)."""
    if total_symbols == 0:
        return 0
    approx: int = 0
    i: int = 0
    n: int = len(freq)
    while i < n:
        fv: int = freq[i]
        if fv > 0:
            ratio: int = (total_symbols * 100) // fv
            bits: int = 0
            r: int = ratio
            while r > 1:
                bits = bits + 1
                r = r // 2
            approx = approx + fv * bits
        i = i + 1
    return approx // 100


def test_module() -> int:
    """Test Huffman-like encoding."""
    passed: int = 0

    freq: list[int] = count_frequencies([0, 1, 1, 2, 2, 2], 4)
    f0: int = freq[0]
    f1: int = freq[1]
    f2: int = freq[2]
    if f0 == 1 and f1 == 2 and f2 == 3:
        passed = passed + 1

    f3: int = freq[3]
    if f3 == 0:
        passed = passed + 1

    cl: list[int] = assign_code_lengths(freq)
    cl2: int = cl[2]
    if cl2 == 1:
        passed = passed + 1

    es: int = estimate_encoded_size(freq, cl)
    if es > 0:
        passed = passed + 1

    elb: int = entropy_lower_bound(freq, 6)
    if elb >= 0:
        passed = passed + 1

    return passed
