# Generated by: depyler corpus generator
# Source: hard_cp_ds_segtree.py
#
# Segment tree operations for transpiler stress testing.


def segtree_build(arr: list[int]) -> list[int]:
    """Build segment tree for range sum queries."""
    n: int = len(arr)
    tree: list[int] = [0] * (4 * n)
    if n > 0:
        build_helper(arr, tree, 1, 0, n - 1)
    return tree


def build_helper(arr: list[int], tree: list[int], node: int, start: int, end: int) -> int:
    """Recursive build helper."""
    if start == end:
        tree[node] = arr[start]
        return tree[node]
    mid: int = (start + end) // 2
    left_val: int = build_helper(arr, tree, 2 * node, start, mid)
    right_val: int = build_helper(arr, tree, 2 * node + 1, mid + 1, end)
    tree[node] = left_val + right_val
    return tree[node]


def segtree_query(tree: list[int], node: int, start: int, end: int, l: int, r: int) -> int:
    """Range sum query on segment tree."""
    if r < start or end < l:
        return 0
    if l <= start and end <= r:
        return tree[node]
    mid: int = (start + end) // 2
    left_sum: int = segtree_query(tree, 2 * node, start, mid, l, r)
    right_sum: int = segtree_query(tree, 2 * node + 1, mid + 1, end, l, r)
    return left_sum + right_sum


def segtree_update(tree: list[int], node: int, start: int, end: int, idx: int, val: int) -> int:
    """Point update on segment tree."""
    if start == end:
        tree[node] = val
        return val
    mid: int = (start + end) // 2
    if idx <= mid:
        segtree_update(tree, 2 * node, start, mid, idx, val)
    else:
        segtree_update(tree, 2 * node + 1, mid + 1, end, idx, val)
    tree[node] = tree[2 * node] + tree[2 * node + 1]
    return tree[node]


def segtree_range_min(arr: list[int], tree: list[int], node: int, start: int, end: int, l: int, r: int) -> int:
    """Range minimum query."""
    if r < start or end < l:
        return 999999999
    if l <= start and end <= r:
        return tree[node]
    mid: int = (start + end) // 2
    left_min: int = segtree_range_min(arr, tree, 2 * node, start, mid, l, r)
    right_min: int = segtree_range_min(arr, tree, 2 * node + 1, mid + 1, end, l, r)
    if left_min < right_min:
        return left_min
    return right_min


def test_module() -> int:
    passed: int = 0
    arr: list[int] = [1, 3, 5, 7, 9, 11]
    tree: list[int] = segtree_build(arr)
    n: int = len(arr)
    if segtree_query(tree, 1, 0, n - 1, 0, 5) == 36:
        passed = passed + 1
    if segtree_query(tree, 1, 0, n - 1, 1, 3) == 15:
        passed = passed + 1
    segtree_update(tree, 1, 0, n - 1, 2, 10)
    if segtree_query(tree, 1, 0, n - 1, 0, 5) == 41:
        passed = passed + 1
    if segtree_query(tree, 1, 0, n - 1, 2, 2) == 10:
        passed = passed + 1
    if segtree_query(tree, 1, 0, n - 1, 0, 0) == 1:
        passed = passed + 1
    return passed
