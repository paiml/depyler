# Generated by: depyler corpus generator
# Source: hard_cp_dp_editdist.py
#
# Edit distance variants for transpiler stress testing.


def edit_distance(word1: str, word2: str) -> int:
    """Levenshtein distance between two strings."""
    m: int = len(word1)
    n: int = len(word2)
    dp: list[list[int]] = []
    r: int = 0
    while r <= m:
        row: list[int] = [0] * (n + 1)
        dp.append(row)
        r = r + 1
    i: int = 0
    while i <= m:
        dp[i][0] = i
        i = i + 1
    j: int = 0
    while j <= n:
        dp[0][j] = j
        j = j + 1
    i2: int = 1
    while i2 <= m:
        j2: int = 1
        while j2 <= n:
            if word1[i2 - 1] == word2[j2 - 1]:
                dp[i2][j2] = dp[i2 - 1][j2 - 1]
            else:
                rep: int = dp[i2 - 1][j2 - 1] + 1
                ins: int = dp[i2][j2 - 1] + 1
                dele: int = dp[i2 - 1][j2] + 1
                best: int = rep
                if ins < best:
                    best = ins
                if dele < best:
                    best = dele
                dp[i2][j2] = best
            j2 = j2 + 1
        i2 = i2 + 1
    return dp[m][n]


def hamming_distance(a: str, b: str) -> int:
    """Hamming distance between two equal-length strings."""
    n: int = len(a)
    dist: int = 0
    i: int = 0
    while i < n:
        if a[i] != b[i]:
            dist = dist + 1
        i = i + 1
    return dist


def edit_distance_with_costs(word1: str, word2: str, ins_cost: int, del_cost: int, rep_cost: int) -> int:
    """Edit distance with custom costs for insert, delete, replace."""
    m: int = len(word1)
    n: int = len(word2)
    dp: list[list[int]] = []
    r: int = 0
    while r <= m:
        row: list[int] = [0] * (n + 1)
        dp.append(row)
        r = r + 1
    i: int = 0
    while i <= m:
        dp[i][0] = i * del_cost
        i = i + 1
    j: int = 0
    while j <= n:
        dp[0][j] = j * ins_cost
        j = j + 1
    i2: int = 1
    while i2 <= m:
        j2: int = 1
        while j2 <= n:
            if word1[i2 - 1] == word2[j2 - 1]:
                dp[i2][j2] = dp[i2 - 1][j2 - 1]
            else:
                rep: int = dp[i2 - 1][j2 - 1] + rep_cost
                ins: int = dp[i2][j2 - 1] + ins_cost
                dele: int = dp[i2 - 1][j2] + del_cost
                best: int = rep
                if ins < best:
                    best = ins
                if dele < best:
                    best = dele
                dp[i2][j2] = best
            j2 = j2 + 1
        i2 = i2 + 1
    return dp[m][n]


def is_one_edit_away(s1: str, s2: str) -> bool:
    """Check if two strings are at most one edit apart."""
    dist: int = edit_distance(s1, s2)
    if dist <= 1:
        return True
    return False


def test_module() -> int:
    passed: int = 0
    if edit_distance("kitten", "sitting") == 3:
        passed = passed + 1
    if edit_distance("", "abc") == 3:
        passed = passed + 1
    if hamming_distance("karolin", "kathrin") == 3:
        passed = passed + 1
    if edit_distance_with_costs("abc", "adc", 1, 1, 2) == 2:
        passed = passed + 1
    if is_one_edit_away("cat", "cats") == True:
        passed = passed + 1
    if is_one_edit_away("cat", "dog") == False:
        passed = passed + 1
    return passed
