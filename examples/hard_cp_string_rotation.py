# Generated by: depyler corpus generator
# Source: hard_cp_string_rotation.py
#
# String rotation matching for transpiler stress testing.


def is_rotation(s1: str, s2: str) -> int:
    """Check if s2 is a rotation of s1. Returns 1=yes, 0=no."""
    n1: int = len(s1)
    n2: int = len(s2)
    if n1 != n2:
        return 0
    if n1 == 0:
        return 1
    doubled: str = s1 + s1
    m: int = n2
    n: int = len(doubled)
    i: int = 0
    while i <= n - m:
        matched: int = 1
        j: int = 0
        while j < m:
            if doubled[i + j] != s2[j]:
                matched = 0
                j = m
            j = j + 1
        if matched == 1:
            return 1
        i = i + 1
    return 0


def min_rotation_index(s: str) -> int:
    """Find starting index of lexicographically smallest rotation."""
    n: int = len(s)
    if n == 0:
        return 0
    doubled: str = s + s
    best: int = 0
    i: int = 1
    while i < n:
        is_smaller: int = 0
        j: int = 0
        while j < n:
            ci: int = ord(doubled[i + j])
            cb: int = ord(doubled[best + j])
            if ci < cb:
                is_smaller = 1
                j = n
            elif ci > cb:
                j = n
            j = j + 1
        if is_smaller == 1:
            best = i
        i = i + 1
    return best


def rotation_distance(s1: str, s2: str) -> int:
    """Minimum rotations to transform s1 to s2. -1 if impossible."""
    if len(s1) != len(s2):
        return 0 - 1
    n: int = len(s1)
    if n == 0:
        return 0
    i: int = 0
    while i < n:
        matched: int = 1
        j: int = 0
        while j < n:
            idx: int = (i + j) % n
            if s1[idx] != s2[j]:
                matched = 0
                j = n
            j = j + 1
        if matched == 1:
            if i <= n - i:
                return i
            return n - i
        i = i + 1
    return 0 - 1


def count_rotations_equal(s: str) -> int:
    """Count how many rotations of s equal s (periodicity)."""
    n: int = len(s)
    if n == 0:
        return 1
    count: int = 0
    r: int = 0
    while r < n:
        matched: int = 1
        j: int = 0
        while j < n:
            idx: int = (r + j) % n
            if s[idx] != s[j]:
                matched = 0
                j = n
            j = j + 1
        if matched == 1:
            count = count + 1
        r = r + 1
    return count


def test_module() -> int:
    passed: int = 0
    if is_rotation("abcde", "cdeab") == 1:
        passed = passed + 1
    if is_rotation("abc", "acb") == 0:
        passed = passed + 1
    if min_rotation_index("cab") == 1:
        passed = passed + 1
    if rotation_distance("abcd", "cdab") == 2:
        passed = passed + 1
    if count_rotations_equal("abab") == 2:
        passed = passed + 1
    return passed
