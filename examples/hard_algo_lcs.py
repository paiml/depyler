# Generated by: depyler corpus generator
# Source: hard_algo_lcs.py
#
# Longest common subsequence with variants.


def lcs_length(text1: str, text2: str) -> int:
    """Length of the longest common subsequence of two strings."""
    m: int = len(text1)
    n: int = len(text2)
    dp: List[List[int]] = []
    r: int = 0
    while r <= m:
        row: List[int] = [0] * (n + 1)
        dp.append(row)
        r = r + 1
    i: int = 1
    while i <= m:
        j: int = 1
        while j <= n:
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                top: int = dp[i - 1][j]
                left: int = dp[i][j - 1]
                if top > left:
                    dp[i][j] = top
                else:
                    dp[i][j] = left
            j = j + 1
        i = i + 1
    return dp[m][n]


def lcs_string(text1: str, text2: str) -> str:
    """Reconstruct the longest common subsequence string."""
    m: int = len(text1)
    n: int = len(text2)
    dp: List[List[int]] = []
    r: int = 0
    while r <= m:
        row: List[int] = [0] * (n + 1)
        dp.append(row)
        r = r + 1
    i: int = 1
    while i <= m:
        j: int = 1
        while j <= n:
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                top: int = dp[i - 1][j]
                left: int = dp[i][j - 1]
                if top > left:
                    dp[i][j] = top
                else:
                    dp[i][j] = left
            j = j + 1
        i = i + 1
    result: str = ""
    i = m
    j: int = n
    while i > 0 and j > 0:
        if text1[i - 1] == text2[j - 1]:
            result = text1[i - 1] + result
            i = i - 1
            j = j - 1
        elif dp[i - 1][j] > dp[i][j - 1]:
            i = i - 1
        else:
            j = j - 1
    return result


def lcs_of_three(s1: str, s2: str, s3: str) -> int:
    """Length of LCS of three strings."""
    l1: int = len(s1)
    l2: int = len(s2)
    l3: int = len(s3)
    dp: List[List[List[int]]] = []
    a: int = 0
    while a <= l1:
        plane: List[List[int]] = []
        b: int = 0
        while b <= l2:
            row: List[int] = [0] * (l3 + 1)
            plane.append(row)
            b = b + 1
        dp.append(plane)
        a = a + 1
    i: int = 1
    while i <= l1:
        j: int = 1
        while j <= l2:
            k: int = 1
            while k <= l3:
                if s1[i - 1] == s2[j - 1] and s2[j - 1] == s3[k - 1]:
                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1
                else:
                    v1: int = dp[i - 1][j][k]
                    v2: int = dp[i][j - 1][k]
                    v3: int = dp[i][j][k - 1]
                    best: int = v1
                    if v2 > best:
                        best = v2
                    if v3 > best:
                        best = v3
                    dp[i][j][k] = best
                k = k + 1
            j = j + 1
        i = i + 1
    return dp[l1][l2][l3]


def shortest_common_supersequence_len(s1: str, s2: str) -> int:
    """Length of shortest common supersequence using LCS."""
    lcs_len: int = lcs_length(s1, s2)
    return len(s1) + len(s2) - lcs_len


def test_module() -> int:
    """Test all LCS functions."""
    passed: int = 0

    r1: int = lcs_length("abcde", "ace")
    if r1 == 3:
        passed = passed + 1

    r2: int = lcs_length("abc", "def")
    if r2 == 0:
        passed = passed + 1

    r3: str = lcs_string("abcde", "ace")
    if r3 == "ace":
        passed = passed + 1

    r4: str = lcs_string("abc", "abc")
    if r4 == "abc":
        passed = passed + 1

    r5: int = lcs_of_three("abcd", "abdc", "abcx")
    if r5 == 3:
        passed = passed + 1

    r6: int = shortest_common_supersequence_len("abac", "cab")
    if r6 == 5:
        passed = passed + 1

    r7: int = lcs_length("", "abc")
    if r7 == 0:
        passed = passed + 1

    return passed
