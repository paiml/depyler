# Generated by: depyler corpus generator
# Source: hard_cp_graph_coloring.py
#
# Graph coloring and chromatic number for transpiler stress testing.


def is_safe_color(adj: list[list[int]], colors: list[int], node: int, color: int) -> bool:
    """Check if assigning color to node is safe."""
    i: int = 0
    while i < len(adj[node]):
        nb: int = adj[node][i]
        if colors[nb] == color:
            return False
        i = i + 1
    return True


def greedy_coloring(n: int, edges: list[list[int]]) -> int:
    """Greedy graph coloring. Returns number of colors used."""
    adj: list[list[int]] = []
    i: int = 0
    while i < n:
        adj.append([])
        i = i + 1
    e: int = 0
    while e < len(edges):
        u: int = edges[e][0]
        v: int = edges[e][1]
        adj[u].append(v)
        adj[v].append(u)
        e = e + 1
    colors: list[int] = [0 - 1] * n
    max_color: int = 0
    node: int = 0
    while node < n:
        used: list[bool] = [False] * (n + 1)
        ni: int = 0
        while ni < len(adj[node]):
            nb: int = adj[node][ni]
            c: int = colors[nb]
            if c >= 0:
                used[c] = True
            ni = ni + 1
        c2: int = 0
        while c2 <= n:
            if not used[c2]:
                colors[node] = c2
                if c2 > max_color:
                    max_color = c2
                c2 = n + 1
            c2 = c2 + 1
        node = node + 1
    return max_color + 1


def is_bipartite(n: int, edges: list[list[int]]) -> bool:
    """Check if graph is bipartite (2-colorable) using BFS."""
    adj: list[list[int]] = []
    i: int = 0
    while i < n:
        adj.append([])
        i = i + 1
    e: int = 0
    while e < len(edges):
        u: int = edges[e][0]
        v: int = edges[e][1]
        adj[u].append(v)
        adj[v].append(u)
        e = e + 1
    colors: list[int] = [0 - 1] * n
    s: int = 0
    while s < n:
        if colors[s] == 0 - 1:
            colors[s] = 0
            queue: list[int] = [s]
            qi: int = 0
            while qi < len(queue):
                curr: int = queue[qi]
                ni: int = 0
                while ni < len(adj[curr]):
                    nb: int = adj[curr][ni]
                    if colors[nb] == 0 - 1:
                        if colors[curr] == 0:
                            colors[nb] = 1
                        else:
                            colors[nb] = 0
                        queue.append(nb)
                    elif colors[nb] == colors[curr]:
                        return False
                    ni = ni + 1
                qi = qi + 1
        s = s + 1
    return True


def chromatic_number_brute(n: int, edges: list[list[int]]) -> int:
    """Find chromatic number for small graphs by trying 1,2,...,n colors."""
    if n == 0:
        return 0
    adj: list[list[int]] = []
    i: int = 0
    while i < n:
        adj.append([])
        i = i + 1
    e: int = 0
    while e < len(edges):
        u: int = edges[e][0]
        v: int = edges[e][1]
        adj[u].append(v)
        adj[v].append(u)
        e = e + 1
    if len(edges) == 0:
        return 1
    num_colors: int = 1
    while num_colors <= n:
        colors: list[int] = [0 - 1] * n
        if try_color(adj, colors, 0, n, num_colors):
            return num_colors
        num_colors = num_colors + 1
    return n


def try_color(adj: list[list[int]], colors: list[int], node: int, n: int, max_c: int) -> bool:
    """Backtracking helper for chromatic number."""
    if node == n:
        return True
    c: int = 0
    while c < max_c:
        if is_safe_color(adj, colors, node, c):
            colors[node] = c
            if try_color(adj, colors, node + 1, n, max_c):
                return True
            colors[node] = 0 - 1
        c = c + 1
    return False


def test_module() -> int:
    passed: int = 0
    edges1: list[list[int]] = [[0, 1], [1, 2], [2, 0]]
    if greedy_coloring(3, edges1) <= 3:
        passed = passed + 1
    if is_bipartite(3, edges1) == False:
        passed = passed + 1
    edges2: list[list[int]] = [[0, 1], [2, 3]]
    if is_bipartite(4, edges2) == True:
        passed = passed + 1
    if chromatic_number_brute(3, edges1) == 3:
        passed = passed + 1
    if chromatic_number_brute(4, [[0, 1], [1, 2], [2, 3], [3, 0]]) == 2:
        passed = passed + 1
    return passed
