# Generated by: depyler corpus generator
# Source: hard_adv_net_retry.py
#
# Retry logic with exponential backoff and jitter.


def exponential_backoff(attempt: int, base_delay: int, max_delay: int) -> int:
    """Compute delay for given attempt using exponential backoff."""
    delay: int = base_delay
    i: int = 0
    while i < attempt:
        delay = delay * 2
        if delay > max_delay:
            delay = max_delay
        i = i + 1
    return delay


def add_jitter(delay: int, seed: int) -> int:
    """Add deterministic jitter to delay."""
    jitter: int = (seed * 1103515245 + 12345) % 2147483648
    jitter_amount: int = jitter % (delay // 4 + 1)
    return delay + jitter_amount


def should_retry(status_code: int) -> int:
    """Determine if a status code is retryable. Returns 1 or 0."""
    if status_code == 429:
        return 1
    if status_code >= 500 and status_code < 600:
        return 1
    if status_code == 408:
        return 1
    return 0


def simulate_retries(fail_codes: list[int], max_retries: int, base_delay: int) -> tuple[int, int]:
    """Simulate retry attempts. Returns (final_code, total_delay)."""
    total_delay: int = 0
    attempt: int = 0
    n: int = len(fail_codes)
    while attempt <= max_retries and attempt < n:
        code: int = fail_codes[attempt]
        retryable: int = should_retry(code)
        if retryable == 0:
            return (code, total_delay)
        if attempt < max_retries:
            delay: int = exponential_backoff(attempt, base_delay, 30000)
            total_delay = total_delay + delay
        attempt = attempt + 1
    if n > 0 and attempt > 0:
        last_code: int = fail_codes[attempt - 1]
        return (last_code, total_delay)
    return (-1, total_delay)


def retry_budget_remaining(max_budget: int, spent: int) -> int:
    """Compute remaining retry budget."""
    remaining: int = max_budget - spent
    if remaining < 0:
        return 0
    return remaining


def count_retryable_errors(codes: list[int]) -> int:
    """Count how many error codes are retryable."""
    cnt: int = 0
    i: int = 0
    n: int = len(codes)
    while i < n:
        code: int = codes[i]
        r: int = should_retry(code)
        if r == 1:
            cnt = cnt + 1
        i = i + 1
    return cnt


def test_module() -> int:
    """Test retry logic functions."""
    passed: int = 0

    d0: int = exponential_backoff(0, 100, 10000)
    if d0 == 100:
        passed = passed + 1

    d2: int = exponential_backoff(2, 100, 10000)
    if d2 == 400:
        passed = passed + 1

    d10: int = exponential_backoff(10, 100, 1000)
    if d10 == 1000:
        passed = passed + 1

    sr: int = should_retry(500)
    if sr == 1:
        passed = passed + 1

    sr2: int = should_retry(200)
    if sr2 == 0:
        passed = passed + 1

    result: tuple[int, int] = simulate_retries([500, 500, 200], 5, 100)
    rc: int = result[0]
    if rc == 200:
        passed = passed + 1

    cnt: int = count_retryable_errors([200, 500, 429, 404, 503])
    if cnt == 3:
        passed = passed + 1

    return passed
