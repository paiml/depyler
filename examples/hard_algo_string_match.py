# Generated by: depyler corpus generator
# Source: hard_algo_string_match.py
#
# Naive string matching and Rabin-Karp hash-based matching.


def naive_string_match(text: str, pat: str) -> List[int]:
    """Find all starting indices where pat appears in text."""
    result: List[int] = []
    n: int = len(text)
    m: int = len(pat)
    if m == 0 or m > n:
        return result
    i: int = 0
    while i <= n - m:
        matched: int = 1
        j: int = 0
        while j < m:
            if text[i + j] != pat[j]:
                matched = 0
                j = m
            else:
                j = j + 1
        if matched == 1:
            result.append(i)
        i = i + 1
    return result


def rabin_karp_match(text: str, pat: str) -> List[int]:
    """Rabin-Karp string matching with rolling hash."""
    n: int = len(text)
    m: int = len(pat)
    if m == 0 or m > n:
        return []
    rk_base: int = 256
    rk_mod: int = 1000000007
    result: List[int] = []
    p_hash: int = 0
    t_hash: int = 0
    h: int = 1
    k: int = 0
    while k < m - 1:
        h = (h * rk_base) % rk_mod
        k = k + 1
    i: int = 0
    while i < m:
        p_hash = (rk_base * p_hash + ord(pat[i])) % rk_mod
        t_hash = (rk_base * t_hash + ord(text[i])) % rk_mod
        i = i + 1
    i = 0
    while i <= n - m:
        if p_hash == t_hash:
            matched: int = 1
            j: int = 0
            while j < m:
                if text[i + j] != pat[j]:
                    matched = 0
                    j = m
                else:
                    j = j + 1
            if matched == 1:
                result.append(i)
        if i < n - m:
            t_hash = (rk_base * (t_hash - ord(text[i]) * h) + ord(text[i + m])) % rk_mod
            if t_hash < 0:
                t_hash = t_hash + rk_mod
        i = i + 1
    return result


def count_occurrences(text: str, pat: str) -> int:
    """Count how many times pat appears in text."""
    matches: List[int] = naive_string_match(text, pat)
    return len(matches)


def first_occurrence(text: str, pat: str) -> int:
    """Find first occurrence of pat in text. Returns -1 if not found."""
    n: int = len(text)
    m: int = len(pat)
    if m == 0 or m > n:
        return -1
    i: int = 0
    while i <= n - m:
        matched: int = 1
        j: int = 0
        while j < m:
            if text[i + j] != pat[j]:
                matched = 0
                j = m
            else:
                j = j + 1
        if matched == 1:
            return i
        i = i + 1
    return -1


def last_occurrence(text: str, pat: str) -> int:
    """Find last occurrence of pat in text. Returns -1 if not found."""
    n: int = len(text)
    m: int = len(pat)
    if m == 0 or m > n:
        return -1
    found: int = -1
    i: int = 0
    while i <= n - m:
        matched: int = 1
        j: int = 0
        while j < m:
            if text[i + j] != pat[j]:
                matched = 0
                j = m
            else:
                j = j + 1
        if matched == 1:
            found = i
        i = i + 1
    return found


def test_module() -> int:
    """Test all string matching functions."""
    passed: int = 0

    r1: List[int] = naive_string_match("abcabcabc", "abc")
    if len(r1) == 3 and r1[0] == 0:
        passed = passed + 1

    r2: List[int] = naive_string_match("hello", "xyz")
    if r2 == []:
        passed = passed + 1

    r3: List[int] = rabin_karp_match("abcabcabc", "abc")
    if len(r3) == 3 and r3[0] == 0:
        passed = passed + 1

    r4: int = count_occurrences("aaaaaa", "aa")
    if r4 == 5:
        passed = passed + 1

    r5: int = first_occurrence("hello world", "world")
    if r5 == 6:
        passed = passed + 1

    r6: int = last_occurrence("abcabc", "abc")
    if r6 == 3:
        passed = passed + 1

    r7: int = first_occurrence("abc", "xyz")
    if r7 == -1:
        passed = passed + 1

    return passed
