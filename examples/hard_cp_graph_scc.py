# Generated by: depyler corpus generator
# Source: hard_cp_graph_scc.py
#
# Strongly connected components (Kosaraju-like) for transpiler stress testing.


def kosaraju_scc_count(n: int, edges: list[list[int]]) -> int:
    """Count strongly connected components using Kosaraju algorithm."""
    adj: list[list[int]] = []
    radj: list[list[int]] = []
    i: int = 0
    while i < n:
        adj.append([])
        radj.append([])
        i = i + 1
    e: int = 0
    while e < len(edges):
        u: int = edges[e][0]
        v: int = edges[e][1]
        adj[u].append(v)
        radj[v].append(u)
        e = e + 1
    visited: list[bool] = [False] * n
    order: list[int] = []
    stack: list[int] = []
    start: int = 0
    while start < n:
        if not visited[start]:
            stack.append(start)
            while len(stack) > 0:
                top: int = stack[len(stack) - 1]
                if not visited[top]:
                    visited[top] = True
                found_next: bool = False
                ni: int = 0
                while ni < len(adj[top]):
                    nb: int = adj[top][ni]
                    if not visited[nb]:
                        stack.append(nb)
                        found_next = True
                        ni = len(adj[top])
                    ni = ni + 1
                if not found_next:
                    stack.pop()
                    order.append(top)
        start = start + 1
    visited2: list[bool] = [False] * n
    scc_count: int = 0
    idx: int = len(order) - 1
    while idx >= 0:
        node: int = order[idx]
        if not visited2[node]:
            stack2: list[int] = [node]
            visited2[node] = True
            while len(stack2) > 0:
                curr: int = stack2.pop()
                ni2: int = 0
                while ni2 < len(radj[curr]):
                    nb2: int = radj[curr][ni2]
                    if not visited2[nb2]:
                        visited2[nb2] = True
                        stack2.append(nb2)
                    ni2 = ni2 + 1
            scc_count = scc_count + 1
        idx = idx - 1
    return scc_count


def is_strongly_connected(n: int, edges: list[list[int]]) -> bool:
    """Check if the directed graph is strongly connected."""
    if n <= 1:
        return True
    count: int = kosaraju_scc_count(n, edges)
    if count == 1:
        return True
    return False


def largest_scc_size(n: int, edges: list[list[int]]) -> int:
    """Find the size of the largest strongly connected component."""
    adj: list[list[int]] = []
    radj: list[list[int]] = []
    i: int = 0
    while i < n:
        adj.append([])
        radj.append([])
        i = i + 1
    e: int = 0
    while e < len(edges):
        u: int = edges[e][0]
        v: int = edges[e][1]
        adj[u].append(v)
        radj[v].append(u)
        e = e + 1
    visited: list[bool] = [False] * n
    order: list[int] = []
    stack: list[int] = []
    start: int = 0
    while start < n:
        if not visited[start]:
            stack.append(start)
            while len(stack) > 0:
                top: int = stack[len(stack) - 1]
                if not visited[top]:
                    visited[top] = True
                found_next: bool = False
                ni: int = 0
                while ni < len(adj[top]):
                    nb: int = adj[top][ni]
                    if not visited[nb]:
                        stack.append(nb)
                        found_next = True
                        ni = len(adj[top])
                    ni = ni + 1
                if not found_next:
                    stack.pop()
                    order.append(top)
        start = start + 1
    visited2: list[bool] = [False] * n
    max_size: int = 0
    idx: int = len(order) - 1
    while idx >= 0:
        node: int = order[idx]
        if not visited2[node]:
            stack2: list[int] = [node]
            visited2[node] = True
            sz: int = 0
            while len(stack2) > 0:
                curr: int = stack2.pop()
                sz = sz + 1
                ni2: int = 0
                while ni2 < len(radj[curr]):
                    nb2: int = radj[curr][ni2]
                    if not visited2[nb2]:
                        visited2[nb2] = True
                        stack2.append(nb2)
                    ni2 = ni2 + 1
            if sz > max_size:
                max_size = sz
        idx = idx - 1
    return max_size


def test_module() -> int:
    passed: int = 0
    edges1: list[list[int]] = [[0, 1], [1, 2], [2, 0], [2, 3], [3, 4], [4, 3]]
    if kosaraju_scc_count(5, edges1) == 2:
        passed = passed + 1
    if is_strongly_connected(5, edges1) == False:
        passed = passed + 1
    if largest_scc_size(5, edges1) == 3:
        passed = passed + 1
    edges2: list[list[int]] = [[0, 1], [1, 2], [2, 0]]
    if is_strongly_connected(3, edges2) == True:
        passed = passed + 1
    if kosaraju_scc_count(3, []) == 3:
        passed = passed + 1
    return passed
