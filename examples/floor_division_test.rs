// Generated by: depyler transpile ./examples/floor_division_test.py
// Source: ./examples/floor_division_test.py
// Command: depyler transpile ./examples/floor_division_test.py

#[doc = "Test floor division with positive operands"] #[doc = " Depyler: proven to terminate"] pub fn test_floor_division_positive()  -> Result<DynamicType, ZeroDivisionError>{
    let mut _cse_temp_0 = {
    let a = - 9;
    let b = 3;
    let q = a / b;
    let r = a % b;
    let r_negative = r<0;
    let b_negative = b<0;
    let needs_adjustment = r != 0 && r_negative != b_negative;
    if needs_adjustment {
    q - 1
}
else {
    q
}
};
    let mut result = _cse_temp_0;
    return Ok(result);
   
}
#[doc = "Test floor division with negative dividend"] #[doc = " Depyler: proven to terminate"] pub fn test_floor_division_negative()  -> Result<DynamicType, ZeroDivisionError>{
    let mut _cse_temp_0 = {
    let a = - 9;
    let b = 3;
    let q = a / b;
    let r = a % b;
    let r_negative = r<0;
    let b_negative = b<0;
    let needs_adjustment = r != 0 && r_negative != b_negative;
    if needs_adjustment {
    q - 1
}
else {
    q
}
};
    let mut result = _cse_temp_0;
    return Ok(result);
   
}
#[doc = "Test floor division with negative divisor"] #[doc = " Depyler: proven to terminate"] pub fn test_floor_division_negative_divisor()  -> Result<DynamicType, ZeroDivisionError>{
    let mut _cse_temp_0 = {
    let a = - 9;
    let b = 3;
    let q = a / b;
    let r = a % b;
    let r_negative = r<0;
    let b_negative = b<0;
    let needs_adjustment = r != 0 && r_negative != b_negative;
    if needs_adjustment {
    q - 1
}
else {
    q
}
};
    let mut result = _cse_temp_0;
    return Ok(result);
   
}
#[doc = "Test floor division with both operands negative"] #[doc = " Depyler: proven to terminate"] pub fn test_floor_division_both_negative()  -> Result<DynamicType, ZeroDivisionError>{
    let mut _cse_temp_0 = {
    let a = - 9;
    let b = 3;
    let q = a / b;
    let r = a % b;
    let r_negative = r<0;
    let b_negative = b<0;
    let needs_adjustment = r != 0 && r_negative != b_negative;
    if needs_adjustment {
    q - 1
}
else {
    q
}
};
    let mut result = _cse_temp_0;
    return Ok(result);
   
}
#[doc = "Test floor division with exact result"] #[doc = " Depyler: proven to terminate"] pub fn test_floor_division_exact()  -> Result<DynamicType, ZeroDivisionError>{
    let mut _cse_temp_0 = {
    let a = - 9;
    let b = 3;
    let q = a / b;
    let r = a % b;
    let r_negative = r<0;
    let b_negative = b<0;
    let needs_adjustment = r != 0 && r_negative != b_negative;
    if needs_adjustment {
    q - 1
}
else {
    q
}
};
    let mut result = _cse_temp_0;
    return Ok(result);
   
}
#[doc = "Test floor division with zero remainder edge case"] #[doc = " Depyler: proven to terminate"] pub fn test_floor_division_zero_remainder()  -> Result<DynamicType, ZeroDivisionError>{
    let mut _cse_temp_0 = {
    let a = - 9;
    let b = 3;
    let q = a / b;
    let r = a % b;
    let r_negative = r<0;
    let b_negative = b<0;
    let needs_adjustment = r != 0 && r_negative != b_negative;
    if needs_adjustment {
    q - 1
}
else {
    q
}
};
    let mut result = _cse_temp_0;
    return Ok(result)
}