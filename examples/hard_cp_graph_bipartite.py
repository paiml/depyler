# Generated by: depyler corpus generator
# Source: hard_cp_graph_bipartite.py
#
# Bipartite matching for transpiler stress testing.


def hungarian_match(n_left: int, n_right: int, adj: list[list[int]]) -> int:
    """Maximum bipartite matching using augmenting paths."""
    match_right: list[int] = [0 - 1] * n_right
    result: int = 0
    u: int = 0
    while u < n_left:
        visited: list[bool] = [False] * n_right
        if augment(adj, u, match_right, visited):
            result = result + 1
        u = u + 1
    return result


def augment(adj: list[list[int]], u: int, match_right: list[int], visited: list[bool]) -> bool:
    """Try to find augmenting path from left node u."""
    i: int = 0
    while i < len(adj[u]):
        v: int = adj[u][i]
        if not visited[v]:
            visited[v] = True
            mr: int = match_right[v]
            if mr == 0 - 1 or augment(adj, mr, match_right, visited):
                match_right[v] = u
                return True
        i = i + 1
    return False


def max_matching_matrix(graph: list[list[int]]) -> int:
    """Maximum matching from bipartite adjacency matrix."""
    n_left: int = len(graph)
    if n_left == 0:
        return 0
    n_right: int = len(graph[0])
    adj: list[list[int]] = []
    i: int = 0
    while i < n_left:
        neighbors: list[int] = []
        j: int = 0
        while j < n_right:
            if graph[i][j] == 1:
                neighbors.append(j)
            j = j + 1
        adj.append(neighbors)
        i = i + 1
    return hungarian_match(n_left, n_right, adj)


def is_perfect_matching(graph: list[list[int]]) -> bool:
    """Check if bipartite graph has a perfect matching."""
    n_left: int = len(graph)
    if n_left == 0:
        return True
    n_right: int = len(graph[0])
    if n_left != n_right:
        return False
    matching: int = max_matching_matrix(graph)
    if matching == n_left:
        return True
    return False


def min_vertex_cover_size(graph: list[list[int]]) -> int:
    """By Konig theorem, min vertex cover = max matching in bipartite graph."""
    return max_matching_matrix(graph)


def test_module() -> int:
    passed: int = 0
    g1: list[list[int]] = [
        [1, 1, 0],
        [0, 1, 1],
        [1, 0, 1],
    ]
    if max_matching_matrix(g1) == 3:
        passed = passed + 1
    if is_perfect_matching(g1) == True:
        passed = passed + 1
    g2: list[list[int]] = [
        [1, 0],
        [1, 0],
    ]
    if max_matching_matrix(g2) == 1:
        passed = passed + 1
    if is_perfect_matching(g2) == False:
        passed = passed + 1
    if min_vertex_cover_size(g1) == 3:
        passed = passed + 1
    return passed
