# Generated by: depyler corpus generator
# Source: hard_algo_heap_ops.py
#
# Heap operations (sift up, sift down, heapify, heap sort) using list.


def heap_sift_down(arr: List[int], size: int, idx: int) -> List[int]:
    """Max-heap sift down at index idx on a copy."""
    result: List[int] = []
    i: int = 0
    while i < len(arr):
        result.append(arr[i])
        i = i + 1
    pos: int = idx
    done: int = 0
    while done == 0:
        largest: int = pos
        left: int = 2 * pos + 1
        right: int = 2 * pos + 2
        if left < size and result[left] > result[largest]:
            largest = left
        if right < size and result[right] > result[largest]:
            largest = right
        if largest == pos:
            done = 1
        else:
            tmp: int = result[pos]
            result[pos] = result[largest]
            result[largest] = tmp
            pos = largest
    return result


def heap_sift_up(arr: List[int], idx: int) -> List[int]:
    """Max-heap sift up from index idx on a copy."""
    result: List[int] = []
    i: int = 0
    while i < len(arr):
        result.append(arr[i])
        i = i + 1
    pos: int = idx
    while pos > 0:
        parent_idx: int = (pos - 1) // 2
        if result[pos] > result[parent_idx]:
            tmp: int = result[pos]
            result[pos] = result[parent_idx]
            result[parent_idx] = tmp
            pos = parent_idx
        else:
            pos = 0 - 1
    return result


def build_max_heap(arr: List[int]) -> List[int]:
    """Build a max-heap from an array."""
    result: List[int] = []
    i: int = 0
    while i < len(arr):
        result.append(arr[i])
        i = i + 1
    n: int = len(result)
    start: int = n // 2 - 1
    while start >= 0:
        pos: int = start
        done: int = 0
        while done == 0:
            largest: int = pos
            left: int = 2 * pos + 1
            right: int = 2 * pos + 2
            if left < n and result[left] > result[largest]:
                largest = left
            if right < n and result[right] > result[largest]:
                largest = right
            if largest == pos:
                done = 1
            else:
                tmp: int = result[pos]
                result[pos] = result[largest]
                result[largest] = tmp
                pos = largest
        start = start - 1
    return result


def heap_sort(arr: List[int]) -> List[int]:
    """Heap sort using build + extract."""
    result: List[int] = build_max_heap(arr)
    n: int = len(result)
    end: int = n - 1
    while end > 0:
        tmp: int = result[0]
        result[0] = result[end]
        result[end] = tmp
        pos: int = 0
        done: int = 0
        while done == 0:
            largest: int = pos
            left: int = 2 * pos + 1
            right: int = 2 * pos + 2
            if left < end and result[left] > result[largest]:
                largest = left
            if right < end and result[right] > result[largest]:
                largest = right
            if largest == pos:
                done = 1
            else:
                tmp2: int = result[pos]
                result[pos] = result[largest]
                result[largest] = tmp2
                pos = largest
        end = end - 1
    return result


def heap_extract_max(arr: List[int]) -> int:
    """Extract max element from a max-heap (returns the max value)."""
    n: int = len(arr)
    if n == 0:
        return -1
    return arr[0]


def test_module() -> int:
    """Test all heap operation functions."""
    passed: int = 0

    r1: List[int] = build_max_heap([3, 1, 6, 5, 2, 4])
    if r1[0] == 6:
        passed = passed + 1

    r2: List[int] = heap_sort([12, 11, 13, 5, 6, 7])
    if r2 == [5, 6, 7, 11, 12, 13]:
        passed = passed + 1

    r3: List[int] = heap_sort([])
    if r3 == []:
        passed = passed + 1

    r4: List[int] = heap_sort([1])
    if r4 == [1]:
        passed = passed + 1

    r5: List[int] = heap_sift_up([5, 3, 4, 1, 2, 10], 5)
    if r5[0] == 10:
        passed = passed + 1

    r6: List[int] = heap_sift_down([1, 5, 3, 4, 2], 5, 0)
    if r6[0] == 5:
        passed = passed + 1

    r7: int = heap_extract_max([9, 7, 5, 3, 1])
    if r7 == 9:
        passed = passed + 1

    return passed
