# Generated by: depyler corpus generator
# Source: hard_cp_math_convexhull.py
#
# Convex hull (Andrew's monotone chain) for transpiler stress testing.


def cross_product(ox: int, oy: int, ax: int, ay: int, bx: int, by: int) -> int:
    """Cross product of vectors OA and OB."""
    return (ax - ox) * (by - oy) - (ay - oy) * (bx - ox)


def convex_hull_size(xs: list[int], ys: list[int]) -> int:
    """Compute convex hull size using Andrew's monotone chain."""
    n: int = len(xs)
    if n < 3:
        return n
    indices: list[int] = [0] * n
    i: int = 0
    while i < n:
        indices[i] = i
        i = i + 1
    a: int = 0
    while a < n:
        b: int = a + 1
        while b < n:
            ia: int = indices[a]
            ib: int = indices[b]
            swap: int = 0
            if xs[ib] < xs[ia]:
                swap = 1
            elif xs[ib] == xs[ia] and ys[ib] < ys[ia]:
                swap = 1
            if swap == 1:
                tmp: int = indices[a]
                indices[a] = indices[b]
                indices[b] = tmp
            b = b + 1
        a = a + 1
    lower: list[int] = []
    k: int = 0
    while k < n:
        idx: int = indices[k]
        still_removing: int = 1
        while still_removing == 1:
            if len(lower) < 2:
                still_removing = 0
            else:
                li1: int = lower[len(lower) - 1]
                li2: int = lower[len(lower) - 2]
                cp: int = cross_product(xs[li2], ys[li2], xs[li1], ys[li1], xs[idx], ys[idx])
                if cp <= 0:
                    lower.pop()
                else:
                    still_removing = 0
        lower.append(idx)
        k = k + 1
    upper: list[int] = []
    k2: int = n - 1
    while k2 >= 0:
        idx2: int = indices[k2]
        still_removing2: int = 1
        while still_removing2 == 1:
            if len(upper) < 2:
                still_removing2 = 0
            else:
                ui1: int = upper[len(upper) - 1]
                ui2: int = upper[len(upper) - 2]
                cp2: int = cross_product(xs[ui2], ys[ui2], xs[ui1], ys[ui1], xs[idx2], ys[idx2])
                if cp2 <= 0:
                    upper.pop()
                else:
                    still_removing2 = 0
        upper.append(idx2)
        k2 = k2 - 1
    total: int = len(lower) + len(upper) - 2
    return total


def polygon_area_2x(xs: list[int], ys: list[int]) -> int:
    """Twice the area of polygon using shoelace formula (absolute value)."""
    n: int = len(xs)
    if n < 3:
        return 0
    area: int = 0
    i: int = 0
    while i < n:
        j: int = (i + 1) % n
        area = area + xs[i] * ys[j] - xs[j] * ys[i]
        i = i + 1
    if area < 0:
        area = 0 - area
    return area


def test_module() -> int:
    passed: int = 0
    cp: int = cross_product(0, 0, 1, 0, 0, 1)
    if cp == 1:
        passed = passed + 1
    xs1: list[int] = [0, 1, 2, 1]
    ys1: list[int] = [0, 0, 1, 1]
    hull: int = convex_hull_size(xs1, ys1)
    if hull >= 3:
        passed = passed + 1
    area: int = polygon_area_2x([0, 4, 4, 0], [0, 0, 3, 3])
    if area == 24:
        passed = passed + 1
    xs2: list[int] = [0, 1, 0]
    ys2: list[int] = [0, 0, 1]
    if polygon_area_2x(xs2, ys2) == 1:
        passed = passed + 1
    if convex_hull_size([0, 1], [0, 1]) == 2:
        passed = passed + 1
    return passed
