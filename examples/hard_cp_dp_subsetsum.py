# Generated by: depyler corpus generator
# Source: hard_cp_dp_subsetsum.py
#
# Subset sum variants for transpiler stress testing.


def subset_sum_exists(nums: list[int], target: int) -> bool:
    """Check if any subset sums to target."""
    dp: list[bool] = [False] * (target + 1)
    dp[0] = True
    i: int = 0
    while i < len(nums):
        val: int = nums[i]
        j: int = target
        while j >= val:
            if dp[j - val]:
                dp[j] = True
            j = j - 1
        i = i + 1
    return dp[target]


def count_subset_sums(nums: list[int], target: int) -> int:
    """Count number of subsets that sum to target."""
    dp: list[int] = [0] * (target + 1)
    dp[0] = 1
    i: int = 0
    while i < len(nums):
        val: int = nums[i]
        j: int = target
        while j >= val:
            dp[j] = dp[j] + dp[j - val]
            j = j - 1
        i = i + 1
    return dp[target]


def target_sum_ways(nums: list[int], goal: int) -> int:
    """Count ways to assign +/- to each number to reach goal."""
    total: int = 0
    i: int = 0
    while i < len(nums):
        total = total + nums[i]
        i = i + 1
    if (total + goal) % 2 != 0:
        return 0
    if total < goal:
        return 0
    if goal < 0 - total:
        return 0
    target: int = (total + goal) // 2
    if target < 0:
        return 0
    dp: list[int] = [0] * (target + 1)
    dp[0] = 1
    j: int = 0
    while j < len(nums):
        val: int = nums[j]
        k: int = target
        while k >= val:
            dp[k] = dp[k] + dp[k - val]
            k = k - 1
        j = j + 1
    return dp[target]


def max_subset_sum_no_adjacent(nums: list[int]) -> int:
    """Maximum subset sum with no two adjacent elements."""
    n: int = len(nums)
    if n == 0:
        return 0
    if n == 1:
        return nums[0]
    prev2: int = 0
    prev1: int = nums[0]
    i: int = 1
    while i < n:
        val: int = nums[i]
        take: int = prev2 + val
        skip: int = prev1
        if take > skip:
            curr: int = take
        else:
            curr = skip
        prev2 = prev1
        prev1 = curr
        i = i + 1
    return prev1


def subset_sum_closest(nums: list[int], target: int) -> int:
    """Find sum of subset closest to target."""
    dp: list[bool] = [False] * (target + 1)
    dp[0] = True
    i: int = 0
    while i < len(nums):
        val: int = nums[i]
        if val <= target:
            j: int = target
            while j >= val:
                if dp[j - val]:
                    dp[j] = True
                j = j - 1
        i = i + 1
    best: int = 0
    k: int = 0
    while k <= target:
        if dp[k]:
            best = k
        k = k + 1
    return best


def test_module() -> int:
    passed: int = 0
    if subset_sum_exists([3, 34, 4, 12, 5, 2], 9) == True:
        passed = passed + 1
    if subset_sum_exists([3, 34, 4, 12, 5, 2], 30) == False:
        passed = passed + 1
    if count_subset_sums([1, 2, 3, 4, 5], 5) == 3:
        passed = passed + 1
    if target_sum_ways([1, 1, 1, 1, 1], 3) == 5:
        passed = passed + 1
    if max_subset_sum_no_adjacent([2, 7, 9, 3, 1]) == 12:
        passed = passed + 1
    if subset_sum_closest([1, 2, 3, 7], 6) == 6:
        passed = passed + 1
    return passed
