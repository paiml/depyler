# Generated by: depyler corpus generator
# Source: hard_algo_insertion_sort.py
#
# Insertion sort variants with optimizations.


def insertion_sort_basic(arr: List[int]) -> List[int]:
    """Basic insertion sort on a copy of the array."""
    result: List[int] = []
    i: int = 0
    while i < len(arr):
        result.append(arr[i])
        i = i + 1
    n: int = len(result)
    i = 1
    while i < n:
        current: int = result[i]
        j: int = i - 1
        while j >= 0 and result[j] > current:
            result[j + 1] = result[j]
            j = j - 1
        result[j + 1] = current
        i = i + 1
    return result


def insertion_sort_desc(arr: List[int]) -> List[int]:
    """Insertion sort in descending order."""
    result: List[int] = []
    i: int = 0
    while i < len(arr):
        result.append(arr[i])
        i = i + 1
    n: int = len(result)
    i = 1
    while i < n:
        current: int = result[i]
        j: int = i - 1
        while j >= 0 and result[j] < current:
            result[j + 1] = result[j]
            j = j - 1
        result[j + 1] = current
        i = i + 1
    return result


def binary_insertion_sort(arr: List[int]) -> List[int]:
    """Insertion sort using binary search to find insertion point."""
    result: List[int] = []
    i: int = 0
    while i < len(arr):
        result.append(arr[i])
        i = i + 1
    n: int = len(result)
    i = 1
    while i < n:
        current: int = result[i]
        lo: int = 0
        hi: int = i
        while lo < hi:
            mid: int = (lo + hi) // 2
            if result[mid] <= current:
                lo = mid + 1
            else:
                hi = mid
        j: int = i
        while j > lo:
            result[j] = result[j - 1]
            j = j - 1
        result[lo] = current
        i = i + 1
    return result


def insertion_sort_partial(arr: List[int], left: int, right: int) -> List[int]:
    """Sort a subrange [left, right] of the array using insertion sort."""
    result: List[int] = []
    i: int = 0
    while i < len(arr):
        result.append(arr[i])
        i = i + 1
    i = left + 1
    while i <= right:
        current: int = result[i]
        j: int = i - 1
        while j >= left and result[j] > current:
            result[j + 1] = result[j]
            j = j - 1
        result[j + 1] = current
        i = i + 1
    return result


def is_sorted_asc(arr: List[int]) -> int:
    """Check if array is sorted ascending. Returns 1 if yes, 0 if no."""
    n: int = len(arr)
    if n <= 1:
        return 1
    i: int = 0
    while i < n - 1:
        if arr[i] > arr[i + 1]:
            return 0
        i = i + 1
    return 1


def test_module() -> int:
    """Test all insertion sort functions."""
    passed: int = 0

    r1: List[int] = insertion_sort_basic([5, 3, 8, 1, 2])
    if r1 == [1, 2, 3, 5, 8]:
        passed = passed + 1

    r2: List[int] = insertion_sort_basic([])
    if r2 == []:
        passed = passed + 1

    r3: List[int] = insertion_sort_desc([1, 5, 3, 2, 4])
    if r3 == [5, 4, 3, 2, 1]:
        passed = passed + 1

    r4: List[int] = binary_insertion_sort([9, 7, 5, 3, 1])
    if r4 == [1, 3, 5, 7, 9]:
        passed = passed + 1

    r5: List[int] = insertion_sort_partial([5, 3, 8, 1, 2], 1, 3)
    if r5[1] == 1 and r5[2] == 3 and r5[3] == 8:
        passed = passed + 1

    r6: int = is_sorted_asc([1, 2, 3, 4])
    if r6 == 1:
        passed = passed + 1

    r7: int = is_sorted_asc([4, 2, 3])
    if r7 == 0:
        passed = passed + 1

    r8: List[int] = insertion_sort_basic([7, 7, 7])
    if r8 == [7, 7, 7]:
        passed = passed + 1

    return passed
