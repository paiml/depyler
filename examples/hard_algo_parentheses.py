# Generated by: depyler corpus generator
# Source: hard_algo_parentheses.py
#
# Balanced parentheses and valid combination generation.


def is_balanced(s: str) -> int:
    """Check if string of parentheses is balanced. Returns 1/0."""
    depth: int = 0
    i: int = 0
    while i < len(s):
        c: str = s[i]
        if c == "(":
            depth = depth + 1
        elif c == ")":
            depth = depth - 1
            if depth < 0:
                return 0
        i = i + 1
    if depth == 0:
        return 1
    return 0


def is_balanced_multi(s: str) -> int:
    """Check balanced parentheses for (), [], {}. Returns 1/0."""
    stack: List[str] = []
    i: int = 0
    while i < len(s):
        c: str = s[i]
        if c == "(" or c == "[" or c == "{":
            stack.append(c)
        elif c == ")":
            if len(stack) == 0:
                return 0
            top: str = stack[len(stack) - 1]
            stack.pop()
            if top != "(":
                return 0
        elif c == "]":
            if len(stack) == 0:
                return 0
            top2: str = stack[len(stack) - 1]
            stack.pop()
            if top2 != "[":
                return 0
        elif c == "}":
            if len(stack) == 0:
                return 0
            top3: str = stack[len(stack) - 1]
            stack.pop()
            if top3 != "{":
                return 0
        i = i + 1
    if len(stack) == 0:
        return 1
    return 0


def min_remove_to_balance(s: str) -> int:
    """Minimum parentheses to remove to make string balanced."""
    open_count: int = 0
    close_unmatched: int = 0
    i: int = 0
    while i < len(s):
        c: str = s[i]
        if c == "(":
            open_count = open_count + 1
        elif c == ")":
            if open_count > 0:
                open_count = open_count - 1
            else:
                close_unmatched = close_unmatched + 1
        i = i + 1
    return open_count + close_unmatched


def max_nesting_depth(s: str) -> int:
    """Find maximum nesting depth of parentheses."""
    depth: int = 0
    max_depth: int = 0
    i: int = 0
    while i < len(s):
        c: str = s[i]
        if c == "(":
            depth = depth + 1
            if depth > max_depth:
                max_depth = depth
        elif c == ")":
            depth = depth - 1
        i = i + 1
    return max_depth


def count_valid_parens(n: int) -> int:
    """Count number of valid parentheses combinations of n pairs (Catalan)."""
    if n == 0:
        return 1
    dp: List[int] = [0] * (n + 1)
    dp[0] = 1
    i: int = 1
    while i <= n:
        j: int = 0
        while j < i:
            dp[i] = dp[i] + dp[j] * dp[i - 1 - j]
            j = j + 1
        i = i + 1
    return dp[n]


def score_of_parentheses(s: str) -> int:
    """Score of parentheses: () = 1, (A) = 2*A, AB = A+B."""
    stack: List[int] = [0]
    i: int = 0
    while i < len(s):
        c: str = s[i]
        if c == "(":
            stack.append(0)
        else:
            top: int = stack[len(stack) - 1]
            stack.pop()
            if top == 0:
                val: int = 1
            else:
                val = 2 * top
            last_idx: int = len(stack) - 1
            stack[last_idx] = stack[last_idx] + val
        i = i + 1
    return stack[0]


def test_module() -> int:
    """Test all parentheses functions."""
    passed: int = 0

    r1: int = is_balanced("(()())")
    if r1 == 1:
        passed = passed + 1

    r2: int = is_balanced("(()")
    if r2 == 0:
        passed = passed + 1

    r3: int = is_balanced_multi("([{}])")
    if r3 == 1:
        passed = passed + 1

    r4: int = is_balanced_multi("([)]")
    if r4 == 0:
        passed = passed + 1

    r5: int = min_remove_to_balance("())()(")
    if r5 == 2:
        passed = passed + 1

    r6: int = max_nesting_depth("((())())")
    if r6 == 3:
        passed = passed + 1

    r7: int = count_valid_parens(3)
    if r7 == 5:
        passed = passed + 1

    r8: int = score_of_parentheses("(()(()))")
    if r8 == 6:
        passed = passed + 1

    return passed
