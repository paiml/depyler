# Generated by: depyler corpus generator
# Source: hard_state_machines.py
#
# Pathological state machine patterns for Python-to-Rust transpiler stress testing.
# Focuses on mutable state tracking, enum simulation, nested conditionals,
# and complex loop patterns that challenge transpilation.

from typing import List, Dict, Tuple


def traffic_light_fsm(events: List[int]) -> List[int]:
    """Simulate a traffic light FSM: 0=red, 1=green, 2=yellow.
    Events: 0=timer, 1=emergency, 2=reset.
    Returns list of state snapshots after each event."""
    state: int = 0
    history: List[int] = []
    for event in events:
        if event == 1:
            state = 0
        elif event == 2:
            state = 0
        elif event == 0:
            if state == 0:
                state = 1
            elif state == 1:
                state = 2
            elif state == 2:
                state = 0
            else:
                state = 0
        else:
            state = state
        history.append(state)
    return history


def balanced_parens_checker(s: str) -> int:
    """Stack-based balanced parentheses checker.
    Returns 1 if balanced, 0 if unbalanced, -1 if invalid char found.
    Handles (), [], {}."""
    stack: List[int] = []
    i: int = 0
    while i < len(s):
        ch: str = s[i]
        if ch == "(" or ch == "[" or ch == "{":
            if ch == "(":
                stack.append(1)
            elif ch == "[":
                stack.append(2)
            else:
                stack.append(3)
        elif ch == ")" or ch == "]" or ch == "}":
            if len(stack) == 0:
                return 0
            top: int = stack.pop()
            if ch == ")" and top != 1:
                return 0
            elif ch == "]" and top != 2:
                return 0
            elif ch == "}" and top != 3:
                return 0
        else:
            return -1
        i = i + 1
    if len(stack) == 0:
        return 1
    return 0


def token_scanner_classify(source: str) -> List[int]:
    """Scan a string character by character, classifying tokens.
    Returns list of token types: 0=digit_run, 1=alpha_run, 2=space, 3=other.
    Each entry corresponds to one detected token."""
    tokens: List[int] = []
    i: int = 0
    n: int = len(source)
    while i < n:
        ch: str = source[i]
        if ch >= "0" and ch <= "9":
            while i < n and source[i] >= "0" and source[i] <= "9":
                i = i + 1
            tokens.append(0)
        elif (ch >= "a" and ch <= "z") or (ch >= "A" and ch <= "Z"):
            while i < n and ((source[i] >= "a" and source[i] <= "z") or (source[i] >= "A" and source[i] <= "Z")):
                i = i + 1
            tokens.append(1)
        elif ch == " ":
            while i < n and source[i] == " ":
                i = i + 1
            tokens.append(2)
        else:
            tokens.append(3)
            i = i + 1
    return tokens


def tcp_connection_fsm(commands: List[int]) -> List[int]:
    """Simulate TCP-like connection state machine.
    States: 0=closed, 1=listen, 2=syn_sent, 3=syn_received,
            4=established, 5=fin_wait, 6=close_wait, 7=time_wait.
    Commands: 0=open_passive, 1=open_active, 2=syn_ack, 3=ack,
              4=close, 5=fin, 6=timeout.
    Returns state history."""
    state: int = 0
    history: List[int] = []
    for cmd in commands:
        if state == 0:
            if cmd == 0:
                state = 1
            elif cmd == 1:
                state = 2
        elif state == 1:
            if cmd == 2:
                state = 3
            elif cmd == 4:
                state = 0
        elif state == 2:
            if cmd == 2:
                state = 4
            elif cmd == 6:
                state = 0
        elif state == 3:
            if cmd == 3:
                state = 4
        elif state == 4:
            if cmd == 4:
                state = 5
            elif cmd == 5:
                state = 6
        elif state == 5:
            if cmd == 5:
                state = 7
            elif cmd == 3:
                state = 7
        elif state == 6:
            if cmd == 4:
                state = 0
        elif state == 7:
            if cmd == 6:
                state = 0
        history.append(state)
    return history


def dfa_binary_divisible_by_3(binary_str: str) -> bool:
    """DFA that checks if a binary number is divisible by 3.
    States represent remainder: 0, 1, 2.
    Transitions on '0' and '1' digits."""
    state: int = 0
    i: int = 0
    while i < len(binary_str):
        ch: str = binary_str[i]
        if ch == "0":
            if state == 0:
                state = 0
            elif state == 1:
                state = 2
            elif state == 2:
                state = 1
        elif ch == "1":
            if state == 0:
                state = 1
            elif state == 1:
                state = 0
            elif state == 2:
                state = 2
        i = i + 1
    return state == 0


def accumulator_with_reset(values: List[int], threshold: int) -> List[int]:
    """Accumulate values, resetting when sum exceeds threshold.
    Returns list of accumulated sums at each step (post-reset if triggered)."""
    results: List[int] = []
    acc: int = 0
    reset_count: int = 0
    for v in values:
        acc = acc + v
        if acc > threshold:
            reset_count = reset_count + 1
            acc = v
        results.append(acc)
    return results


def multi_phase_pipeline(data: List[int]) -> List[int]:
    """Three-phase pipeline: filter, transform, aggregate.
    Phase 1: keep only positive values.
    Phase 2: square each value, cap at 10000.
    Phase 3: running average (integer division)."""
    phase1: List[int] = []
    for x in data:
        if x > 0:
            phase1.append(x)
    phase2: List[int] = []
    for x in phase1:
        sq: int = x * x
        if sq > 10000:
            sq = 10000
        phase2.append(sq)
    phase3: List[int] = []
    running_sum: int = 0
    count: int = 0
    for x in phase2:
        running_sum = running_sum + x
        count = count + 1
        phase3.append(running_sum // count)
    return phase3


def vending_machine_fsm(coins: List[int], price: int) -> Tuple[int, int]:
    """Simulate a vending machine. Accepts coins (1, 5, 10, 25).
    Returns (items_dispensed, change_returned).
    Invalid coins are ignored. Dispenses when total >= price."""
    total: int = 0
    items: int = 0
    change: int = 0
    valid_coins: List[int] = [1, 5, 10, 25]
    for coin in coins:
        is_valid: bool = False
        for vc in valid_coins:
            if coin == vc:
                is_valid = True
        if is_valid:
            total = total + coin
            if total >= price:
                items = items + 1
                leftover: int = total - price
                change = change + leftover
                total = 0
    return (items, change)


def elevator_controller(floors: List[int], capacity: int) -> List[int]:
    """Simulate elevator state: track current floor and direction.
    States: 0=idle, 1=moving_up, 2=moving_down.
    Returns list of floors visited in order.
    Floors are clamped to [0, capacity-1]."""
    current: int = 0
    visited: List[int] = [0]
    for target in floors:
        if target < 0:
            target = 0
        elif target >= capacity:
            target = capacity - 1
        if target == current:
            visited.append(current)
        else:
            step: int = 1 if target > current else -1
            while current != target:
                current = current + step
                visited.append(current)
    return visited


def regex_dot_star_match(pattern: str, text: str) -> bool:
    """Simple regex matching supporting '.' (any char) and '*' (zero or more of prev).
    Uses iterative state machine approach with backtracking stack."""
    stack: List[Tuple[int, int]] = [(0, 0)]
    visited: Dict[str, bool] = {}
    while len(stack) > 0:
        top: Tuple[int, int] = stack.pop()
        pi: int = top[0]
        ti: int = top[1]
        key: str = str(pi) + "," + str(ti)
        if key in visited:
            continue
        visited[key] = True
        if pi == len(pattern):
            if ti == len(text):
                return True
            continue
        if pi + 1 < len(pattern) and pattern[pi + 1] == "*":
            stack.append((pi + 2, ti))
            if ti < len(text):
                if pattern[pi] == "." or pattern[pi] == text[ti]:
                    stack.append((pi, ti + 1))
        else:
            if ti < len(text):
                if pattern[pi] == "." or pattern[pi] == text[ti]:
                    stack.append((pi + 1, ti + 1))
    return False


def run_length_encode(data: List[int]) -> List[Tuple[int, int]]:
    """Encode consecutive runs as (value, count) pairs.
    State machine tracks current value and run length."""
    if len(data) == 0:
        return []
    result: List[Tuple[int, int]] = []
    current_val: int = data[0]
    current_count: int = 1
    i: int = 1
    while i < len(data):
        if data[i] == current_val:
            current_count = current_count + 1
        else:
            result.append((current_val, current_count))
            current_val = data[i]
            current_count = 1
        i = i + 1
    result.append((current_val, current_count))
    return result


def nfa_simulate(transitions: Dict[str, List[int]], start: int, accepts: List[int], input_str: str) -> bool:
    """Simulate an NFA given as transition table.
    Transition keys are 'state,char' -> list of next states.
    Returns True if any path reaches an accept state."""
    current_states: List[int] = [start]
    for ch in input_str:
        next_states: List[int] = []
        for s in current_states:
            key: str = str(s) + "," + ch
            if key in transitions:
                for ns in transitions[key]:
                    already: bool = False
                    for existing in next_states:
                        if existing == ns:
                            already = True
                    if not already:
                        next_states.append(ns)
        current_states = next_states
    for s in current_states:
        for a in accepts:
            if s == a:
                return True
    return False


def state_reduction_merge(states: List[int]) -> List[int]:
    """Reduce a state sequence by merging consecutive duplicates
    and collapsing alternating patterns (e.g., 1,2,1,2 -> 1,2).
    Returns the reduced sequence."""
    if len(states) == 0:
        return []
    deduped: List[int] = [states[0]]
    i: int = 1
    while i < len(states):
        if states[i] != deduped[len(deduped) - 1]:
            deduped.append(states[i])
        i = i + 1
    if len(deduped) <= 2:
        return deduped
    changed: bool = True
    current: List[int] = deduped
    while changed:
        changed = False
        result: List[int] = []
        j: int = 0
        while j < len(current):
            if len(result) >= 2 and result[len(result) - 2] == current[j] and result[len(result) - 1] == current[j]:
                j = j + 1
                changed = True
                continue
            already_seen: bool = False
            if len(result) >= 2 and result[len(result) - 2] == current[j]:
                already_seen = True
            if already_seen and j + 1 < len(current) and result[len(result) - 1] == current[j + 1]:
                j = j + 2
                changed = True
                continue
            result.append(current[j])
            j = j + 1
        current = result
    return current


def priority_event_processor(events: List[Tuple[int, int]]) -> Dict[str, int]:
    """Process events as (priority, value) tuples.
    Priority 0=critical, 1=high, 2=normal, 3=low.
    Returns counts and sums per priority level as a dict.
    Keys: 'count_0'..'count_3', 'sum_0'..'sum_3'."""
    counts: Dict[str, int] = {}
    p: int = 0
    while p < 4:
        counts["count_" + str(p)] = 0
        counts["sum_" + str(p)] = 0
        p = p + 1
    for event in events:
        pri: int = event[0]
        val: int = event[1]
        if pri < 0 or pri > 3:
            pri = 3
        count_key: str = "count_" + str(pri)
        sum_key: str = "sum_" + str(pri)
        counts[count_key] = counts[count_key] + 1
        counts[sum_key] = counts[sum_key] + val
    return counts


def game_of_life_step(grid: List[List[int]], rows: int, cols: int) -> List[List[int]]:
    """One step of Conway's Game of Life as a state machine.
    Each cell transitions based on neighbor count.
    0=dead, 1=alive. Returns new grid."""
    new_grid: List[List[int]] = []
    r: int = 0
    while r < rows:
        row: List[int] = []
        c: int = 0
        while c < cols:
            neighbors: int = 0
            dr: int = -1
            while dr <= 1:
                dc: int = -1
                while dc <= 1:
                    if dr != 0 or dc != 0:
                        nr: int = r + dr
                        nc: int = c + dc
                        if nr >= 0 and nr < rows and nc >= 0 and nc < cols:
                            neighbors = neighbors + grid[nr][nc]
                    dc = dc + 1
                dr = dr + 1
            if grid[r][c] == 1:
                if neighbors == 2 or neighbors == 3:
                    row.append(1)
                else:
                    row.append(0)
            else:
                if neighbors == 3:
                    row.append(1)
                else:
                    row.append(0)
            c = c + 1
        new_grid.append(row)
        r = r + 1
    return new_grid


def morse_decoder(encoded: str) -> str:
    """Decode a simplified morse-like encoding.
    '.' = short, '-' = long, ' ' = letter separator, '/' = word separator.
    Maps a small alphabet: a=.-, b=-..., e=., t=-, s=..., o=---."""
    morse_map: Dict[str, str] = {}
    morse_map[".-"] = "a"
    morse_map["-..."] = "b"
    morse_map["."] = "e"
    morse_map["-"] = "t"
    morse_map["..."] = "s"
    morse_map["---"] = "o"
    morse_map[".."] = "i"
    morse_map["-."] = "n"
    result: str = ""
    current: str = ""
    i: int = 0
    while i < len(encoded):
        ch: str = encoded[i]
        if ch == " " or ch == "/":
            if len(current) > 0:
                if current in morse_map:
                    result = result + morse_map[current]
                else:
                    result = result + "?"
                current = ""
            if ch == "/":
                result = result + " "
        else:
            current = current + ch
        i = i + 1
    if len(current) > 0:
        if current in morse_map:
            result = result + morse_map[current]
        else:
            result = result + "?"
    return result


def markov_chain_step(transition_counts: Dict[str, Dict[str, int]], current_state: str, steps: int) -> List[str]:
    """Simulate a deterministic Markov chain by always picking the highest-count next state.
    Ties broken by lexicographic order. Returns state path."""
    path: List[str] = [current_state]
    s: int = 0
    while s < steps:
        if current_state not in transition_counts:
            break
        neighbors: Dict[str, int] = transition_counts[current_state]
        best_state: str = ""
        best_count: int = -1
        for next_state in neighbors:
            cnt: int = neighbors[next_state]
            if cnt > best_count:
                best_count = cnt
                best_state = next_state
            elif cnt == best_count:
                if best_state == "" or next_state < best_state:
                    best_state = next_state
        if best_state == "":
            break
        current_state = best_state
        path.append(current_state)
        s = s + 1
    return path


def sliding_window_state(data: List[int], window_size: int) -> List[Tuple[int, int, int]]:
    """Sliding window that tracks (min, max, sum) state over each window position.
    Returns list of (min, max, sum) tuples for each valid window."""
    results: List[Tuple[int, int, int]] = []
    if window_size <= 0 or len(data) < window_size:
        return results
    i: int = 0
    while i <= len(data) - window_size:
        w_min: int = data[i]
        w_max: int = data[i]
        w_sum: int = 0
        j: int = 0
        while j < window_size:
            val: int = data[i + j]
            if val < w_min:
                w_min = val
            if val > w_max:
                w_max = val
            w_sum = w_sum + val
            j = j + 1
        results.append((w_min, w_max, w_sum))
        i = i + 1
    return results


def test_all() -> bool:
    """Test all state machine functions."""
    ok: bool = True

    # traffic_light_fsm
    tl: List[int] = traffic_light_fsm([0, 0, 0, 1, 0])
    if tl != [1, 2, 0, 0, 1]:
        ok = False

    # balanced_parens_checker
    if balanced_parens_checker("()[]{}") != 1:
        ok = False
    if balanced_parens_checker("([)]") != 0:
        ok = False
    if balanced_parens_checker("") != 1:
        ok = False
    if balanced_parens_checker("(") != 0:
        ok = False

    # token_scanner_classify
    tokens: List[int] = token_scanner_classify("abc 123 !!")
    if tokens != [1, 2, 0, 2, 3, 3]:
        ok = False

    # tcp_connection_fsm: open_active, syn_ack, close, fin -> 2,4,5,7
    tcp: List[int] = tcp_connection_fsm([1, 2, 4, 5])
    if tcp != [2, 4, 5, 7]:
        ok = False

    # dfa_binary_divisible_by_3
    if dfa_binary_divisible_by_3("110") != True:
        ok = False
    if dfa_binary_divisible_by_3("111") != False:
        ok = False
    if dfa_binary_divisible_by_3("0") != True:
        ok = False

    # accumulator_with_reset: 3, 7, 12>10 reset to 5, 5+2=7, 7+8=15>10 reset to 8
    acc: List[int] = accumulator_with_reset([3, 4, 5, 2, 8], 10)
    if acc != [3, 7, 5, 7, 8]:
        ok = False

    # multi_phase_pipeline: filter [2,3,4] -> square [4,9,16] -> running avg [4,6,9]
    pipe: List[int] = multi_phase_pipeline([-1, 2, 3, -5, 4])
    if pipe != [4, 6, 9]:
        ok = False

    # vending_machine_fsm: 25+25=50>=30 -> dispense (change 20), then 10+10+5=25<30
    vm: Tuple[int, int] = vending_machine_fsm([25, 25, 10, 10, 5], 30)
    if vm[0] != 1:
        ok = False
    if vm[1] != 20:
        ok = False

    # elevator_controller
    elev: List[int] = elevator_controller([3, 1], 5)
    if elev != [0, 1, 2, 3, 2, 1]:
        ok = False

    # regex_dot_star_match
    if regex_dot_star_match("a.*b", "axxb") != True:
        ok = False
    if regex_dot_star_match("a.*b", "axxc") != False:
        ok = False
    if regex_dot_star_match(".", "x") != True:
        ok = False

    # run_length_encode
    rle: List[Tuple[int, int]] = run_length_encode([1, 1, 2, 2, 2, 3])
    if len(rle) != 3:
        ok = False
    if rle[0] != (1, 2):
        ok = False
    if rle[1] != (2, 3):
        ok = False

    # nfa_simulate
    nfa_trans: Dict[str, List[int]] = {"0,a": [0, 1], "1,b": [2]}
    if nfa_simulate(nfa_trans, 0, [2], "ab") != True:
        ok = False
    if nfa_simulate(nfa_trans, 0, [2], "aa") != False:
        ok = False

    # state_reduction_merge: dedup [1,1,2,3,3,4] -> [1,2,3,4], no alternation
    red: List[int] = state_reduction_merge([1, 1, 2, 3, 3, 4])
    if red != [1, 2, 3, 4]:
        ok = False
    # alternation collapse: [1,2,1,2,3] deduped is same, collapses 1,2 alt to [1,2,3]
    red2: List[int] = state_reduction_merge([1, 2, 1, 2, 3])
    if red2 != [1, 2, 3]:
        ok = False

    # priority_event_processor
    pe: Dict[str, int] = priority_event_processor([(0, 10), (1, 20), (0, 30)])
    if pe["count_0"] != 2:
        ok = False
    if pe["sum_0"] != 40:
        ok = False

    # game_of_life_step: vertical blinker -> horizontal blinker
    grid: List[List[int]] = [[0, 1, 0], [0, 1, 0], [0, 1, 0]]
    new_grid: List[List[int]] = game_of_life_step(grid, 3, 3)
    if new_grid[1][0] != 1 or new_grid[1][1] != 1 or new_grid[1][2] != 1:
        ok = False
    if new_grid[0][0] != 0 or new_grid[0][1] != 0 or new_grid[0][2] != 0:
        ok = False

    # morse_decoder
    decoded: str = morse_decoder("... --- ...")
    if decoded != "sos":
        ok = False

    # markov_chain_step
    mc_trans: Dict[str, Dict[str, int]] = {
        "a": {"b": 5, "c": 3},
        "b": {"a": 2, "c": 7},
        "c": {"a": 1},
    }
    mc_path: List[str] = markov_chain_step(mc_trans, "a", 3)
    if mc_path != ["a", "b", "c", "a"]:
        ok = False

    # sliding_window_state
    sw: List[Tuple[int, int, int]] = sliding_window_state([1, 3, 2, 5, 4], 3)
    if len(sw) != 3:
        ok = False
    if sw[0] != (1, 3, 6):
        ok = False
    if sw[1] != (2, 5, 10):
        ok = False

    return ok
