# Generated by: depyler corpus generator
# Source: hard_cp_graph_dijkstra.py
#
# Dijkstra shortest path variants for transpiler stress testing.


def dijkstra_matrix(graph: list[list[int]], src: int) -> list[int]:
    """Dijkstra using adjacency matrix (0 = no edge). Returns dist array."""
    n: int = len(graph)
    dist: list[int] = [999999999] * n
    visited: list[int] = [0] * n
    dist[src] = 0
    count: int = 0
    while count < n:
        u: int = 0 - 1
        min_d: int = 999999999
        i: int = 0
        while i < n:
            if visited[i] == 0:
                if dist[i] < min_d:
                    min_d = dist[i]
                    u = i
            i = i + 1
        if u == 0 - 1:
            count = n
        else:
            visited[u] = 1
            v: int = 0
            while v < n:
                w: int = graph[u][v]
                if w > 0 and visited[v] == 0:
                    new_dist: int = dist[u] + w
                    if new_dist < dist[v]:
                        dist[v] = new_dist
                v = v + 1
            count = count + 1
    return dist


def dijkstra_single_target(graph: list[list[int]], src: int, target: int) -> int:
    """Shortest distance from src to target. Returns -1 if unreachable."""
    dists: list[int] = dijkstra_matrix(graph, src)
    result: int = dists[target]
    if result >= 999999999:
        return 0 - 1
    return result


def shortest_path_count(graph: list[list[int]], src: int, dst: int) -> int:
    """Count number of shortest paths from src to dst."""
    n: int = len(graph)
    dist: list[int] = [999999999] * n
    ways: list[int] = [0] * n
    visited: list[int] = [0] * n
    dist[src] = 0
    ways[src] = 1
    count: int = 0
    while count < n:
        u: int = 0 - 1
        min_d: int = 999999999
        i: int = 0
        while i < n:
            if visited[i] == 0:
                if dist[i] < min_d:
                    min_d = dist[i]
                    u = i
            i = i + 1
        if u == 0 - 1:
            count = n
        else:
            visited[u] = 1
            v: int = 0
            while v < n:
                w: int = graph[u][v]
                if w > 0 and visited[v] == 0:
                    new_dist: int = dist[u] + w
                    if new_dist < dist[v]:
                        dist[v] = new_dist
                        ways[v] = ways[u]
                    elif new_dist == dist[v]:
                        ways[v] = ways[v] + ways[u]
                v = v + 1
            count = count + 1
    return ways[dst]


def test_module() -> int:
    passed: int = 0
    g: list[list[int]] = [
        [0, 4, 0, 0, 0],
        [4, 0, 8, 0, 0],
        [0, 8, 0, 7, 0],
        [0, 0, 7, 0, 9],
        [0, 0, 0, 9, 0],
    ]
    dists: list[int] = dijkstra_matrix(g, 0)
    if dists[0] == 0:
        passed = passed + 1
    if dists[1] == 4:
        passed = passed + 1
    if dists[4] == 28:
        passed = passed + 1
    if dijkstra_single_target(g, 0, 3) == 19:
        passed = passed + 1
    g2: list[list[int]] = [
        [0, 1, 1, 0],
        [0, 0, 0, 1],
        [0, 0, 0, 1],
        [0, 0, 0, 0],
    ]
    if shortest_path_count(g2, 0, 3) == 2:
        passed = passed + 1
    return passed
