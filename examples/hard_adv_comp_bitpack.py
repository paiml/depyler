# Generated by: depyler corpus generator
# Source: hard_adv_comp_bitpack.py
#
# Bit packing: pack multiple small integers into larger words.


def bits_needed(max_val: int) -> int:
    """Compute minimum bits needed to represent values 0..max_val."""
    if max_val <= 0:
        return 1
    bits: int = 0
    v: int = max_val
    while v > 0:
        bits = bits + 1
        v = v // 2
    return bits


def pack_values(data: list[int], bit_width: int) -> list[int]:
    """Pack values into 32-bit words using bit_width bits each."""
    words: list[int] = []
    current_word: int = 0
    bits_used: int = 0
    i: int = 0
    n: int = len(data)
    while i < n:
        val: int = data[i]
        mask: int = (1 << bit_width) - 1
        masked_val: int = val & mask
        current_word = current_word | (masked_val << bits_used)
        bits_used = bits_used + bit_width
        if bits_used >= 32:
            words.append(current_word & 4294967295)
            bits_used = bits_used - 32
            current_word = masked_val >> (bit_width - bits_used)
        i = i + 1
    if bits_used > 0:
        words.append(current_word & 4294967295)
    return words


def unpack_values(words: list[int], bit_width: int, count: int) -> list[int]:
    """Unpack count values from packed words."""
    result: list[int] = []
    word_idx: int = 0
    bit_offset: int = 0
    i: int = 0
    mask: int = (1 << bit_width) - 1
    while i < count:
        if word_idx >= len(words):
            result.append(0)
            i = i + 1
            continue
        w: int = words[word_idx]
        val: int = (w >> bit_offset) & mask
        bit_offset = bit_offset + bit_width
        if bit_offset >= 32:
            bit_offset = bit_offset - 32
            word_idx = word_idx + 1
            if bit_offset > 0 and word_idx < len(words):
                w2: int = words[word_idx]
                val = val | ((w2 & ((1 << bit_offset) - 1)) << (bit_width - bit_offset))
        result.append(val)
        i = i + 1
    return result


def packed_size(count: int, bit_width: int) -> int:
    """Compute how many 32-bit words are needed."""
    total_bits: int = count * bit_width
    words_needed: int = (total_bits + 31) // 32
    return words_needed


def compression_savings(original_bits: int, packed_bits: int) -> int:
    """Compute savings as percentage."""
    if original_bits == 0:
        return 0
    return 100 - (packed_bits * 100) // original_bits


def test_module() -> int:
    """Test bit packing functions."""
    passed: int = 0

    b1: int = bits_needed(7)
    if b1 == 3:
        passed = passed + 1

    b2: int = bits_needed(255)
    if b2 == 8:
        passed = passed + 1

    packed: list[int] = pack_values([1, 2, 3, 4], 4)
    if len(packed) >= 1:
        passed = passed + 1

    ps: int = packed_size(10, 4)
    if ps == 2:
        passed = passed + 1

    cs: int = compression_savings(320, 40)
    if cs > 0:
        passed = passed + 1

    b3: int = bits_needed(0)
    if b3 == 1:
        passed = passed + 1

    return passed
