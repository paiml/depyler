# Generated by: depyler corpus generator
# Source: hard_string_algorithms.py
#
# Pathological string algorithm patterns for Python-to-Rust transpiler stress testing.
# Every function is pure, fully type-annotated, and uses no imports.


def kmp_failure_function(pattern: str) -> List[int]:
    """Compute the KMP failure function (partial match table)."""
    m: int = len(pattern)
    fail: List[int] = [0] * m
    k: int = 0
    i: int = 1
    while i < m:
        if pattern[i] == pattern[k]:
            k = k + 1
            fail[i] = k
            i = i + 1
        elif k > 0:
            k = fail[k - 1]
        else:
            fail[i] = 0
            i = i + 1
    return fail


def kmp_search(text: str, pattern: str) -> List[int]:
    """Find all occurrences of pattern in text using KMP algorithm."""
    n: int = len(text)
    m: int = len(pattern)
    if m == 0:
        return []
    fail: List[int] = kmp_failure_function(pattern)
    matches: List[int] = []
    j: int = 0
    i: int = 0
    while i < n:
        if text[i] == pattern[j]:
            i = i + 1
            j = j + 1
            if j == m:
                matches.append(i - m)
                j = fail[j - 1]
        elif j > 0:
            j = fail[j - 1]
        else:
            i = i + 1
    return matches


def rabin_karp_search(text: str, pattern: str) -> List[int]:
    """Find pattern occurrences using Rabin-Karp rolling hash."""
    n: int = len(text)
    m: int = len(pattern)
    if m == 0 or m > n:
        return []
    base: int = 256
    mod: int = 1000000007
    matches: List[int] = []
    p_hash: int = 0
    t_hash: int = 0
    h: int = 1
    k: int = 0
    while k < m - 1:
        h = (h * base) % mod
        k = k + 1
    i: int = 0
    while i < m:
        p_hash = (base * p_hash + ord(pattern[i])) % mod
        t_hash = (base * t_hash + ord(text[i])) % mod
        i = i + 1
    i = 0
    while i <= n - m:
        if p_hash == t_hash:
            match: bool = True
            j: int = 0
            while j < m:
                if text[i + j] != pattern[j]:
                    match = False
                    j = m
                else:
                    j = j + 1
            if match:
                matches.append(i)
        if i < n - m:
            t_hash = (base * (t_hash - ord(text[i]) * h) + ord(text[i + m])) % mod
            if t_hash < 0:
                t_hash = t_hash + mod
        i = i + 1
    return matches


def expand_around_center(s: str, left: int, right: int) -> str:
    """Expand around center indices to find palindrome."""
    n: int = len(s)
    while left >= 0 and right < n and s[left] == s[right]:
        left = left - 1
        right = right + 1
    return s[left + 1:right]


def longest_palindromic_substring(s: str) -> str:
    """Find the longest palindromic substring using expand-around-center."""
    if len(s) == 0:
        return ""
    best: str = s[0:1]
    i: int = 0
    while i < len(s):
        odd: str = expand_around_center(s, i, i)
        if len(odd) > len(best):
            best = odd
        even: str = expand_around_center(s, i, i + 1)
        if len(even) > len(best):
            best = even
        i = i + 1
    return best


def is_rotation(s1: str, s2: str) -> bool:
    """Check if s2 is a rotation of s1."""
    if len(s1) != len(s2):
        return False
    if len(s1) == 0:
        return True
    doubled: str = s1 + s1
    n: int = len(doubled)
    m: int = len(s2)
    i: int = 0
    while i <= n - m:
        found: bool = True
        j: int = 0
        while j < m:
            if doubled[i + j] != s2[j]:
                found = False
                j = m
            else:
                j = j + 1
        if found:
            return True
        i = i + 1
    return False


def char_frequency(s: str) -> Dict[str, int]:
    """Count character frequencies in a string."""
    freq: Dict[str, int] = {}
    i: int = 0
    while i < len(s):
        c: str = s[i]
        if c in freq:
            freq[c] = freq[c] + 1
        else:
            freq[c] = 1
        i = i + 1
    return freq


def are_anagrams(s1: str, s2: str) -> bool:
    """Check if two strings are anagrams of each other."""
    if len(s1) != len(s2):
        return False
    freq1: Dict[str, int] = char_frequency(s1)
    freq2: Dict[str, int] = char_frequency(s2)
    for key in freq1:
        if key not in freq2:
            return False
        if freq1[key] != freq2[key]:
            return False
    for key in freq2:
        if key not in freq1:
            return False
    return True


def group_anagrams(words: List[str]) -> List[List[str]]:
    """Group a list of words into anagram groups."""
    seen: Dict[str, int] = {}
    groups: List[List[str]] = []
    i: int = 0
    while i < len(words):
        w: str = words[i]
        key: str = sort_string(w)
        if key in seen:
            idx: int = seen[key]
            groups[idx].append(w)
        else:
            seen[key] = len(groups)
            groups.append([w])
        i = i + 1
    return groups


def sort_string(s: str) -> str:
    """Sort characters of a string alphabetically (selection sort)."""
    chars: List[str] = []
    i: int = 0
    while i < len(s):
        chars.append(s[i])
        i = i + 1
    n: int = len(chars)
    i = 0
    while i < n:
        min_idx: int = i
        j: int = i + 1
        while j < n:
            if chars[j] < chars[min_idx]:
                min_idx = j
            j = j + 1
        tmp: str = chars[i]
        chars[i] = chars[min_idx]
        chars[min_idx] = tmp
        i = i + 1
    result: str = ""
    i = 0
    while i < n:
        result = result + chars[i]
        i = i + 1
    return result


def run_length_encode(s: str) -> str:
    """Run-length encode a string: 'aaabbc' -> 'a3b2c1'."""
    if len(s) == 0:
        return ""
    result: str = ""
    count: int = 1
    i: int = 1
    while i < len(s):
        if s[i] == s[i - 1]:
            count = count + 1
        else:
            result = result + s[i - 1] + int_to_str(count)
            count = 1
        i = i + 1
    result = result + s[len(s) - 1] + int_to_str(count)
    return result


def int_to_str(n: int) -> str:
    """Convert a non-negative integer to its string representation."""
    if n == 0:
        return "0"
    result: str = ""
    val: int = n
    while val > 0:
        digit: int = val % 10
        if digit == 0:
            result = "0" + result
        elif digit == 1:
            result = "1" + result
        elif digit == 2:
            result = "2" + result
        elif digit == 3:
            result = "3" + result
        elif digit == 4:
            result = "4" + result
        elif digit == 5:
            result = "5" + result
        elif digit == 6:
            result = "6" + result
        elif digit == 7:
            result = "7" + result
        elif digit == 8:
            result = "8" + result
        else:
            result = "9" + result
        val = val // 10
    return result


def run_length_decode(encoded: str) -> str:
    """Decode a run-length encoded string: 'a3b2c1' -> 'aaabbc'."""
    result: str = ""
    i: int = 0
    n: int = len(encoded)
    while i < n:
        ch: str = encoded[i]
        i = i + 1
        num_str: str = ""
        while i < n and encoded[i] >= "0" and encoded[i] <= "9":
            num_str = num_str + encoded[i]
            i = i + 1
        count: int = str_to_int(num_str)
        j: int = 0
        while j < count:
            result = result + ch
            j = j + 1
    return result


def str_to_int(s: str) -> int:
    """Convert a numeric string to an integer."""
    result: int = 0
    i: int = 0
    while i < len(s):
        c: str = s[i]
        d: int = 0
        if c == "1":
            d = 1
        elif c == "2":
            d = 2
        elif c == "3":
            d = 3
        elif c == "4":
            d = 4
        elif c == "5":
            d = 5
        elif c == "6":
            d = 6
        elif c == "7":
            d = 7
        elif c == "8":
            d = 8
        elif c == "9":
            d = 9
        result = result * 10 + d
        i = i + 1
    return result


def levenshtein_distance(s1: str, s2: str) -> int:
    """Compute the Levenshtein (edit) distance between two strings."""
    m: int = len(s1)
    n: int = len(s2)
    prev: List[int] = []
    j: int = 0
    while j <= n:
        prev.append(j)
        j = j + 1
    i: int = 1
    while i <= m:
        curr: List[int] = [i]
        j = 1
        while j <= n:
            if s1[i - 1] == s2[j - 1]:
                curr.append(prev[j - 1])
            else:
                replace_cost: int = prev[j - 1] + 1
                insert_cost: int = curr[j - 1] + 1
                delete_cost: int = prev[j] + 1
                min_cost: int = replace_cost
                if insert_cost < min_cost:
                    min_cost = insert_cost
                if delete_cost < min_cost:
                    min_cost = delete_cost
                curr.append(min_cost)
            j = j + 1
        prev = curr
        i = i + 1
    return prev[n]


def z_function(s: str) -> List[int]:
    """Compute the Z-array for the given string."""
    n: int = len(s)
    if n == 0:
        return []
    z: List[int] = [0] * n
    z[0] = n
    l: int = 0
    r: int = 0
    i: int = 1
    while i < n:
        if i < r:
            z[i] = r - i
            if z[i - l] < z[i]:
                z[i] = z[i - l]
        while i + z[i] < n and s[z[i]] == s[i + z[i]]:
            z[i] = z[i] + 1
        if i + z[i] > r:
            l = i
            r = i + z[i]
        i = i + 1
    return z


def z_search(text: str, pattern: str) -> List[int]:
    """Find all occurrences of pattern in text using Z-algorithm."""
    if len(pattern) == 0:
        return []
    combined: str = pattern + "$" + text
    z: List[int] = z_function(combined)
    m: int = len(pattern)
    matches: List[int] = []
    i: int = m + 1
    while i < len(combined):
        if z[i] == m:
            matches.append(i - m - 1)
        i = i + 1
    return matches


def build_suffix_array(s: str) -> List[int]:
    """Build a suffix array using naive O(n^2 log n) construction."""
    n: int = len(s)
    suffixes: List[int] = []
    i: int = 0
    while i < n:
        suffixes.append(i)
        i = i + 1
    # Selection sort by suffix comparison
    i = 0
    while i < n:
        min_idx: int = i
        j: int = i + 1
        while j < n:
            if compare_suffixes(s, suffixes[j], suffixes[min_idx]) < 0:
                min_idx = j
            j = j + 1
        tmp: int = suffixes[i]
        suffixes[i] = suffixes[min_idx]
        suffixes[min_idx] = tmp
        i = i + 1
    return suffixes


def compare_suffixes(s: str, i: int, j: int) -> int:
    """Compare two suffixes of s starting at positions i and j."""
    n: int = len(s)
    while i < n and j < n:
        if s[i] < s[j]:
            return -1
        elif s[i] > s[j]:
            return 1
        i = i + 1
        j = j + 1
    if i == n and j == n:
        return 0
    elif i == n:
        return -1
    else:
        return 1


def manacher_odd(s: str) -> List[int]:
    """Compute odd-length palindrome radii using Manacher's algorithm."""
    n: int = len(s)
    if n == 0:
        return []
    p: List[int] = [0] * n
    center: int = 0
    right: int = 0
    i: int = 0
    while i < n:
        mirror: int = 2 * center - i
        if i < right and mirror >= 0:
            p[i] = right - i
            if p[mirror] < p[i]:
                p[i] = p[mirror]
        while i - p[i] - 1 >= 0 and i + p[i] + 1 < n and s[i - p[i] - 1] == s[i + p[i] + 1]:
            p[i] = p[i] + 1
        if i + p[i] > right:
            center = i
            right = i + p[i]
        i = i + 1
    return p


def longest_palindrome_manacher(s: str) -> str:
    """Find the longest palindromic substring using Manacher's algorithm."""
    if len(s) == 0:
        return ""
    # Transform: "abc" -> "^#a#b#c#$"
    t: str = "^"
    i: int = 0
    while i < len(s):
        t = t + "#" + s[i]
        i = i + 1
    t = t + "#$"
    n: int = len(t)
    p: List[int] = [0] * n
    center: int = 0
    right: int = 0
    i = 1
    while i < n - 1:
        mirror: int = 2 * center - i
        if i < right:
            p[i] = right - i
            if mirror >= 0 and p[mirror] < p[i]:
                p[i] = p[mirror]
        while t[i + p[i] + 1] == t[i - p[i] - 1]:
            p[i] = p[i] + 1
        if i + p[i] > right:
            center = i
            right = i + p[i]
        i = i + 1
    max_len: int = 0
    best_center: int = 0
    i = 1
    while i < n - 1:
        if p[i] > max_len:
            max_len = p[i]
            best_center = i
        i = i + 1
    start: int = (best_center - max_len) // 2
    return s[start:start + max_len]


def compress_string(s: str) -> str:
    """Compress a string using run-length encoding; return original if no savings."""
    if len(s) == 0:
        return ""
    compressed: str = ""
    count: int = 1
    i: int = 1
    while i < len(s):
        if s[i] == s[i - 1]:
            count = count + 1
        else:
            compressed = compressed + s[i - 1]
            if count > 1:
                compressed = compressed + int_to_str(count)
            count = 1
        i = i + 1
    compressed = compressed + s[len(s) - 1]
    if count > 1:
        compressed = compressed + int_to_str(count)
    if len(compressed) < len(s):
        return compressed
    return s


def wildcard_match(text: str, pattern: str) -> bool:
    """Match text against pattern with '?' (any char) and '*' (any sequence)."""
    m: int = len(text)
    n: int = len(pattern)
    # DP table: prev and curr rows
    prev: List[bool] = []
    j: int = 0
    while j <= n:
        prev.append(False)
        j = j + 1
    prev[0] = True
    j = 1
    while j <= n:
        if pattern[j - 1] == "*":
            prev[j] = prev[j - 1]
        j = j + 1
    i: int = 1
    while i <= m:
        curr: List[bool] = []
        j = 0
        while j <= n:
            curr.append(False)
            j = j + 1
        j = 1
        while j <= n:
            if pattern[j - 1] == "*":
                curr[j] = curr[j - 1] or prev[j]
            elif pattern[j - 1] == "?" or pattern[j - 1] == text[i - 1]:
                curr[j] = prev[j - 1]
            j = j + 1
        prev = curr
        i = i + 1
    return prev[n]


def simple_regex_match(text: str, pattern: str) -> bool:
    """Match text against a simple regex with '.' (any char) and '*' (zero or more of prev)."""
    m: int = len(text)
    n: int = len(pattern)
    prev: List[bool] = []
    j: int = 0
    while j <= n:
        prev.append(False)
        j = j + 1
    prev[0] = True
    j = 2
    while j <= n:
        if pattern[j - 1] == "*":
            prev[j] = prev[j - 2]
        j = j + 1
    i: int = 1
    while i <= m:
        curr: List[bool] = []
        j = 0
        while j <= n:
            curr.append(False)
            j = j + 1
        j = 1
        while j <= n:
            if pattern[j - 1] == "*":
                curr[j] = curr[j - 2]
                if pattern[j - 2] == "." or pattern[j - 2] == text[i - 1]:
                    curr[j] = curr[j] or prev[j]
            elif pattern[j - 1] == "." or pattern[j - 1] == text[i - 1]:
                curr[j] = prev[j - 1]
            j = j + 1
        prev = curr
        i = i + 1
    return prev[n]


def longest_common_prefix(strings: List[str]) -> str:
    """Find the longest common prefix of a list of strings."""
    if len(strings) == 0:
        return ""
    prefix: str = strings[0]
    i: int = 1
    while i < len(strings):
        new_prefix: str = ""
        j: int = 0
        s: str = strings[i]
        while j < len(prefix) and j < len(s):
            if prefix[j] == s[j]:
                new_prefix = new_prefix + prefix[j]
            else:
                j = len(prefix)
            j = j + 1
        prefix = new_prefix
        if len(prefix) == 0:
            return ""
        i = i + 1
    return prefix


def caesar_cipher_encode(text: str, shift: int) -> str:
    """Encode text using Caesar cipher with given shift."""
    result: str = ""
    i: int = 0
    while i < len(text):
        c: str = text[i]
        code: int = ord(c)
        if code >= 65 and code <= 90:
            code = (code - 65 + shift) % 26 + 65
            result = result + chr(code)
        elif code >= 97 and code <= 122:
            code = (code - 97 + shift) % 26 + 97
            result = result + chr(code)
        else:
            result = result + c
        i = i + 1
    return result


def caesar_cipher_decode(text: str, shift: int) -> str:
    """Decode text using Caesar cipher with given shift."""
    return caesar_cipher_encode(text, 26 - (shift % 26))


def hamming_distance(s1: str, s2: str) -> int:
    """Compute the Hamming distance between two equal-length strings."""
    if len(s1) != len(s2):
        return -1
    dist: int = 0
    i: int = 0
    while i < len(s1):
        if s1[i] != s2[i]:
            dist = dist + 1
        i = i + 1
    return dist


def longest_common_substring(s1: str, s2: str) -> str:
    """Find the longest common substring of two strings."""
    m: int = len(s1)
    n: int = len(s2)
    best_len: int = 0
    best_end: int = 0
    prev: List[int] = []
    j: int = 0
    while j <= n:
        prev.append(0)
        j = j + 1
    i: int = 1
    while i <= m:
        curr: List[int] = [0]
        j = 1
        while j <= n:
            if s1[i - 1] == s2[j - 1]:
                val: int = prev[j - 1] + 1
                curr.append(val)
                if val > best_len:
                    best_len = val
                    best_end = i
            else:
                curr.append(0)
            j = j + 1
        prev = curr
        i = i + 1
    return s1[best_end - best_len:best_end]


def is_subsequence(s: str, t: str) -> bool:
    """Check if s is a subsequence of t."""
    si: int = 0
    ti: int = 0
    while si < len(s) and ti < len(t):
        if s[si] == t[ti]:
            si = si + 1
        ti = ti + 1
    return si == len(s)


def count_distinct_substrings(s: str) -> int:
    """Count the number of distinct substrings using a brute-force set approach."""
    n: int = len(s)
    seen: Dict[str, int] = {}
    i: int = 0
    while i < n:
        j: int = i + 1
        while j <= n:
            sub: str = s[i:j]
            if sub not in seen:
                seen[sub] = 1
            j = j + 1
        i = i + 1
    count: int = 0
    for key in seen:
        count = count + 1
    return count


def repeated_string_match(a: str, b: str) -> int:
    """Find minimum repeats of a such that b is a substring of the repeated a. Return -1 if impossible."""
    if len(a) == 0:
        return -1
    repeated: str = ""
    count: int = 0
    while len(repeated) < len(b) + 2 * len(a):
        repeated = repeated + a
        count = count + 1
        if len(repeated) >= len(b):
            # Check if b is a substring
            found: bool = False
            k: int = 0
            while k <= len(repeated) - len(b):
                match: bool = True
                j: int = 0
                while j < len(b):
                    if repeated[k + j] != b[j]:
                        match = False
                        j = len(b)
                    else:
                        j = j + 1
                if match:
                    found = True
                    k = len(repeated)
                else:
                    k = k + 1
            if found:
                return count
    return -1


def interleave_strings(s1: str, s2: str) -> str:
    """Interleave two strings character by character."""
    result: str = ""
    i: int = 0
    j: int = 0
    while i < len(s1) and j < len(s2):
        result = result + s1[i] + s2[j]
        i = i + 1
        j = j + 1
    while i < len(s1):
        result = result + s1[i]
        i = i + 1
    while j < len(s2):
        result = result + s2[j]
        j = j + 1
    return result


def longest_repeating_substring(s: str) -> str:
    """Find the longest substring that appears at least twice."""
    n: int = len(s)
    best: str = ""
    length: int = 1
    while length < n:
        i: int = 0
        while i <= n - length:
            sub: str = s[i:i + length]
            j: int = i + 1
            while j <= n - length:
                if s[j:j + length] == sub:
                    if length > len(best):
                        best = sub
                    j = n
                else:
                    j = j + 1
            i = i + 1
        length = length + 1
    return best


def string_multiply_hash(s: str) -> int:
    """Compute a polynomial rolling hash of a string."""
    h: int = 0
    base: int = 31
    mod: int = 1000000007
    i: int = 0
    while i < len(s):
        h = (h * base + ord(s[i])) % mod
        i = i + 1
    return h


def test_all() -> bool:
    """Test all string algorithm functions."""
    # KMP
    fail: List[int] = kmp_failure_function("abcabd")
    ok: bool = fail[0] == 0 and fail[3] == 1 and fail[4] == 2
    matches: List[int] = kmp_search("abcabcabd", "abcabd")
    ok = ok and len(matches) == 1 and matches[0] == 3

    # Rabin-Karp
    rk: List[int] = rabin_karp_search("ababababab", "abab")
    ok = ok and len(rk) >= 1 and rk[0] == 0

    # Longest palindromic substring
    pal: str = longest_palindromic_substring("babad")
    ok = ok and (pal == "bab" or pal == "aba")

    # Rotation detection
    ok = ok and is_rotation("abcde", "cdeab")
    ok = ok and not is_rotation("abcde", "abced")

    # Anagram detection
    ok = ok and are_anagrams("listen", "silent")
    ok = ok and not are_anagrams("hello", "world")

    # Anagram grouping
    groups: List[List[str]] = group_anagrams(["eat", "tea", "tan", "ate", "nat", "bat"])
    ok = ok and len(groups) == 3

    # Run-length encode/decode
    encoded: str = run_length_encode("aaabbc")
    ok = ok and encoded == "a3b2c1"
    decoded: str = run_length_decode(encoded)
    ok = ok and decoded == "aaabbc"

    # Levenshtein distance
    dist: int = levenshtein_distance("kitten", "sitting")
    ok = ok and dist == 3

    # Z-algorithm search
    z_matches: List[int] = z_search("ababababab", "abab")
    ok = ok and len(z_matches) >= 1 and z_matches[0] == 0

    # Suffix array
    sa: List[int] = build_suffix_array("banana")
    ok = ok and sa[0] == 5  # "a" is lexicographically first

    # Manacher
    man_pal: str = longest_palindrome_manacher("cbbd")
    ok = ok and man_pal == "bb"

    # String compression
    comp: str = compress_string("aabcccccaaa")
    ok = ok and len(comp) < len("aabcccccaaa")

    # Wildcard matching
    ok = ok and wildcard_match("adceb", "*a*b")
    ok = ok and not wildcard_match("acdcb", "a*c?b")

    # Simple regex
    ok = ok and simple_regex_match("aab", "c*a*b")
    ok = ok and not simple_regex_match("mississippi", "mis*is*p*.")

    # Longest common prefix
    lcp: str = longest_common_prefix(["flower", "flow", "flight"])
    ok = ok and lcp == "fl"

    # Caesar cipher
    encrypted: str = caesar_cipher_encode("hello", 3)
    ok = ok and encrypted == "khoor"
    decrypted: str = caesar_cipher_decode(encrypted, 3)
    ok = ok and decrypted == "hello"

    # Hamming distance
    hd: int = hamming_distance("karolin", "kathrin")
    ok = ok and hd == 3

    # Longest common substring
    lcs: str = longest_common_substring("abcdef", "zbcdf")
    ok = ok and lcs == "bcd"

    # Subsequence check
    ok = ok and is_subsequence("ace", "abcde")
    ok = ok and not is_subsequence("aec", "abcde")

    # Distinct substrings
    dc: int = count_distinct_substrings("abc")
    ok = ok and dc == 6  # a, b, c, ab, bc, abc

    # Repeated string match
    rsm: int = repeated_string_match("abcd", "cdabcdab")
    ok = ok and rsm == 3

    # Interleave strings
    inter: str = interleave_strings("abc", "xyz")
    ok = ok and inter == "axbycz"

    # Longest repeating substring
    lrs: str = longest_repeating_substring("banana")
    ok = ok and lrs == "ana"

    # String hash
    h1: int = string_multiply_hash("hello")
    h2: int = string_multiply_hash("hello")
    ok = ok and h1 == h2 and h1 > 0

    return ok
