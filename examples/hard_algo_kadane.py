# Generated by: depyler corpus generator
# Source: hard_algo_kadane.py
#
# Maximum subarray (Kadane's algorithm) and variants.


def max_subarray_sum(nums: List[int]) -> int:
    """Maximum contiguous subarray sum (Kadane's algorithm)."""
    n: int = len(nums)
    if n == 0:
        return 0
    best: int = nums[0]
    current: int = nums[0]
    i: int = 1
    while i < n:
        val: int = nums[i]
        if current + val > val:
            current = current + val
        else:
            current = val
        if current > best:
            best = current
        i = i + 1
    return best


def max_subarray_indices(nums: List[int]) -> List[int]:
    """Return [start, end, sum] of max subarray."""
    n: int = len(nums)
    if n == 0:
        return [0, 0, 0]
    best_sum: int = nums[0]
    best_start: int = 0
    best_end: int = 0
    current: int = nums[0]
    cur_start: int = 0
    i: int = 1
    while i < n:
        val: int = nums[i]
        if current + val > val:
            current = current + val
        else:
            current = val
            cur_start = i
        if current > best_sum:
            best_sum = current
            best_start = cur_start
            best_end = i
        i = i + 1
    return [best_start, best_end, best_sum]


def max_circular_subarray(nums: List[int]) -> int:
    """Maximum subarray sum in a circular array."""
    n: int = len(nums)
    if n == 0:
        return 0
    total: int = 0
    max_sum: int = nums[0]
    cur_max: int = nums[0]
    min_sum: int = nums[0]
    cur_min: int = nums[0]
    total = nums[0]
    i: int = 1
    while i < n:
        val: int = nums[i]
        total = total + val
        if cur_max + val > val:
            cur_max = cur_max + val
        else:
            cur_max = val
        if cur_max > max_sum:
            max_sum = cur_max
        if cur_min + val < val:
            cur_min = cur_min + val
        else:
            cur_min = val
        if cur_min < min_sum:
            min_sum = cur_min
        i = i + 1
    if max_sum < 0:
        return max_sum
    wrap: int = total - min_sum
    if wrap > max_sum:
        return wrap
    return max_sum


def max_subarray_product(nums: List[int]) -> int:
    """Maximum product subarray."""
    n: int = len(nums)
    if n == 0:
        return 0
    best: int = nums[0]
    cur_max: int = nums[0]
    cur_min: int = nums[0]
    i: int = 1
    while i < n:
        val: int = nums[i]
        if val < 0:
            tmp: int = cur_max
            cur_max = cur_min
            cur_min = tmp
        prod_max: int = cur_max * val
        if prod_max > val:
            cur_max = prod_max
        else:
            cur_max = val
        prod_min: int = cur_min * val
        if prod_min < val:
            cur_min = prod_min
        else:
            cur_min = val
        if cur_max > best:
            best = cur_max
        i = i + 1
    return best


def min_subarray_sum(nums: List[int]) -> int:
    """Minimum contiguous subarray sum."""
    n: int = len(nums)
    if n == 0:
        return 0
    best: int = nums[0]
    current: int = nums[0]
    i: int = 1
    while i < n:
        val: int = nums[i]
        if current + val < val:
            current = current + val
        else:
            current = val
        if current < best:
            best = current
        i = i + 1
    return best


def test_module() -> int:
    """Test all Kadane and subarray functions."""
    passed: int = 0

    r1: int = max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4])
    if r1 == 6:
        passed = passed + 1

    r2: int = max_subarray_sum([-1, -2, -3])
    if r2 == -1:
        passed = passed + 1

    r3: List[int] = max_subarray_indices([-2, 1, -3, 4, -1, 2, 1, -5, 4])
    r3_sum: int = r3[2]
    if r3_sum == 6:
        passed = passed + 1

    r4: int = max_circular_subarray([5, -3, 5])
    if r4 == 10:
        passed = passed + 1

    r5: int = max_circular_subarray([-3, -2, -1])
    if r5 == -1:
        passed = passed + 1

    r6: int = max_subarray_product([2, 3, -2, 4])
    if r6 == 6:
        passed = passed + 1

    r7: int = min_subarray_sum([3, -4, 2, -3, -1, 7, -5])
    if r7 == -6:
        passed = passed + 1

    return passed
