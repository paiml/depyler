# Generated by: depyler corpus generator
# Source: hard_cp_graph_euler.py
#
# Euler path and circuit detection for transpiler stress testing.


def has_euler_circuit(n: int, edges: list[list[int]]) -> int:
    """Check if undirected graph has Euler circuit. Returns 1=yes, 0=no."""
    degree: list[int] = [0] * n
    adj: list[list[int]] = []
    i: int = 0
    while i < n:
        adj.append([])
        i = i + 1
    e: int = 0
    while e < len(edges):
        u: int = edges[e][0]
        v: int = edges[e][1]
        degree[u] = degree[u] + 1
        degree[v] = degree[v] + 1
        adj[u].append(v)
        adj[v].append(u)
        e = e + 1
    k: int = 0
    while k < n:
        if degree[k] % 2 != 0:
            return 0
        k = k + 1
    if len(edges) == 0:
        return 1
    visited: list[int] = [0] * n
    start: int = 0
    si: int = 0
    while si < n:
        if degree[si] > 0:
            start = si
            si = n
        si = si + 1
    stack: list[int] = [start]
    visited[start] = 1
    while len(stack) > 0:
        curr: int = stack.pop()
        ni: int = 0
        while ni < len(adj[curr]):
            nb: int = adj[curr][ni]
            if visited[nb] == 0:
                visited[nb] = 1
                stack.append(nb)
            ni = ni + 1
    vi: int = 0
    while vi < n:
        if degree[vi] > 0 and visited[vi] == 0:
            return 0
        vi = vi + 1
    return 1


def has_euler_path(n: int, edges: list[list[int]]) -> int:
    """Check if undirected graph has Euler path. Returns 1=yes, 0=no."""
    degree: list[int] = [0] * n
    e: int = 0
    while e < len(edges):
        u: int = edges[e][0]
        v: int = edges[e][1]
        degree[u] = degree[u] + 1
        degree[v] = degree[v] + 1
        e = e + 1
    odd_count: int = 0
    k: int = 0
    while k < n:
        if degree[k] % 2 != 0:
            odd_count = odd_count + 1
        k = k + 1
    if odd_count == 0 or odd_count == 2:
        return 1
    return 0


def count_connected_components(n: int, edges: list[list[int]]) -> int:
    """Count connected components in undirected graph."""
    adj: list[list[int]] = []
    i: int = 0
    while i < n:
        adj.append([])
        i = i + 1
    e: int = 0
    while e < len(edges):
        u: int = edges[e][0]
        v: int = edges[e][1]
        adj[u].append(v)
        adj[v].append(u)
        e = e + 1
    visited: list[int] = [0] * n
    comp: int = 0
    s: int = 0
    while s < n:
        if visited[s] == 0:
            stack: list[int] = [s]
            visited[s] = 1
            while len(stack) > 0:
                curr: int = stack.pop()
                ni: int = 0
                while ni < len(adj[curr]):
                    nb: int = adj[curr][ni]
                    if visited[nb] == 0:
                        visited[nb] = 1
                        stack.append(nb)
                    ni = ni + 1
            comp = comp + 1
        s = s + 1
    return comp


def vertex_degree_list(n: int, edges: list[list[int]]) -> list[int]:
    """Return degree of each vertex."""
    degree: list[int] = [0] * n
    e: int = 0
    while e < len(edges):
        u: int = edges[e][0]
        v: int = edges[e][1]
        degree[u] = degree[u] + 1
        degree[v] = degree[v] + 1
        e = e + 1
    return degree


def test_module() -> int:
    passed: int = 0
    edges1: list[list[int]] = [[0, 1], [1, 2], [2, 0]]
    if has_euler_circuit(3, edges1) == 1:
        passed = passed + 1
    edges2: list[list[int]] = [[0, 1], [1, 2]]
    if has_euler_circuit(3, edges2) == 0:
        passed = passed + 1
    if has_euler_path(3, edges2) == 1:
        passed = passed + 1
    if count_connected_components(4, [[0, 1], [2, 3]]) == 2:
        passed = passed + 1
    degs: list[int] = vertex_degree_list(3, edges1)
    if degs[0] == 2 and degs[1] == 2:
        passed = passed + 1
    return passed
