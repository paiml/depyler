# Generated by: depyler corpus generator
# Source: hard_cp_dp_knapsack.py
#
# Knapsack problem variants for transpiler stress testing.


def knapsack_01(weights: list[int], values: list[int], capacity: int) -> int:
    """Classic 0/1 knapsack: max value within capacity."""
    n: int = len(weights)
    dp: list[int] = [0] * (capacity + 1)
    i: int = 0
    while i < n:
        w: int = weights[i]
        v: int = values[i]
        j: int = capacity
        while j >= w:
            cand: int = dp[j - w] + v
            if cand > dp[j]:
                dp[j] = cand
            j = j - 1
        i = i + 1
    return dp[capacity]


def knapsack_unbounded(weights: list[int], values: list[int], capacity: int) -> int:
    """Unbounded knapsack: items can be reused."""
    dp: list[int] = [0] * (capacity + 1)
    j: int = 1
    while j <= capacity:
        i: int = 0
        while i < len(weights):
            w: int = weights[i]
            v: int = values[i]
            if w <= j:
                cand: int = dp[j - w] + v
                if cand > dp[j]:
                    dp[j] = cand
            i = i + 1
        j = j + 1
    return dp[capacity]


def knapsack_bounded(weights: list[int], values: list[int], counts: list[int], capacity: int) -> int:
    """Bounded knapsack: each item has a limited count."""
    dp: list[int] = [0] * (capacity + 1)
    i: int = 0
    while i < len(weights):
        w: int = weights[i]
        v: int = values[i]
        cnt: int = counts[i]
        k: int = 0
        while k < cnt:
            j: int = capacity
            while j >= w:
                cand: int = dp[j - w] + v
                if cand > dp[j]:
                    dp[j] = cand
                j = j - 1
            k = k + 1
        i = i + 1
    return dp[capacity]


def fractional_knapsack_approx(weights: list[int], values: list[int], capacity: int) -> int:
    """Greedy fractional knapsack returning integer floor of max value."""
    n: int = len(weights)
    ratios: list[int] = [0] * n
    indices: list[int] = [0] * n
    i: int = 0
    while i < n:
        ratios[i] = (values[i] * 1000) // weights[i]
        indices[i] = i
        i = i + 1
    a: int = 0
    while a < n:
        b: int = a + 1
        while b < n:
            if ratios[b] > ratios[a]:
                tmp_r: int = ratios[a]
                ratios[a] = ratios[b]
                ratios[b] = tmp_r
                tmp_i: int = indices[a]
                indices[a] = indices[b]
                indices[b] = tmp_i
            b = b + 1
        a = a + 1
    result: int = 0
    rem: int = capacity
    k: int = 0
    while k < n:
        idx: int = indices[k]
        w: int = weights[idx]
        v: int = values[idx]
        if w <= rem:
            result = result + v
            rem = rem - w
        else:
            result = result + (v * rem) // w
            rem = 0
        k = k + 1
    return result


def test_module() -> int:
    passed: int = 0
    if knapsack_01([1, 3, 4, 5], [1, 4, 5, 7], 7) == 9:
        passed = passed + 1
    if knapsack_unbounded([2, 3, 4], [3, 4, 5], 7) == 10:
        passed = passed + 1
    if knapsack_bounded([2, 3], [3, 4], [2, 1], 7) == 10:
        passed = passed + 1
    if fractional_knapsack_approx([10, 20, 30], [60, 100, 120], 50) == 240:
        passed = passed + 1
    if knapsack_01([], [], 10) == 0:
        passed = passed + 1
    if knapsack_01([5], [10], 3) == 0:
        passed = passed + 1
    return passed
