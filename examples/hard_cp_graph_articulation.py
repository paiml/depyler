# Generated by: depyler corpus generator
# Source: hard_cp_graph_articulation.py
#
# Articulation points (cut vertices) for transpiler stress testing.


def find_articulation_points(n: int, edges: list[list[int]]) -> list[int]:
    """Find articulation points in undirected graph using iterative DFS."""
    adj: list[list[int]] = []
    i: int = 0
    while i < n:
        adj.append([])
        i = i + 1
    e: int = 0
    while e < len(edges):
        u: int = edges[e][0]
        v: int = edges[e][1]
        adj[u].append(v)
        adj[v].append(u)
        e = e + 1
    disc: list[int] = [0 - 1] * n
    low: list[int] = [0 - 1] * n
    parent: list[int] = [0 - 1] * n
    is_ap: list[int] = [0] * n
    timer: int = 0
    stack: list[int] = []
    child_idx: list[int] = [0] * n
    start: int = 0
    while start < n:
        if disc[start] == 0 - 1:
            stack.append(start)
            disc[start] = timer
            low[start] = timer
            timer = timer + 1
            child_idx[start] = 0
            while len(stack) > 0:
                u2: int = stack[len(stack) - 1]
                if child_idx[u2] < len(adj[u2]):
                    v2: int = adj[u2][child_idx[u2]]
                    child_idx[u2] = child_idx[u2] + 1
                    if disc[v2] == 0 - 1:
                        parent[v2] = u2
                        disc[v2] = timer
                        low[v2] = timer
                        timer = timer + 1
                        child_idx[v2] = 0
                        stack.append(v2)
                    elif v2 != parent[u2]:
                        if disc[v2] < low[u2]:
                            low[u2] = disc[v2]
                else:
                    stack.pop()
                    if len(stack) > 0:
                        p: int = stack[len(stack) - 1]
                        if low[u2] < low[p]:
                            low[p] = low[u2]
                        if parent[p] == 0 - 1:
                            child_count: int = 0
                            ci: int = 0
                            while ci < len(adj[p]):
                                nb: int = adj[p][ci]
                                if parent[nb] == p:
                                    child_count = child_count + 1
                                ci = ci + 1
                            if child_count > 1:
                                is_ap[p] = 1
                        else:
                            if low[u2] >= disc[p]:
                                is_ap[p] = 1
        start = start + 1
    result: list[int] = []
    k: int = 0
    while k < n:
        if is_ap[k] == 1:
            result.append(k)
        k = k + 1
    return result


def count_articulation_points(n: int, edges: list[list[int]]) -> int:
    """Count the number of articulation points."""
    pts: list[int] = find_articulation_points(n, edges)
    return len(pts)


def is_biconnected(n: int, edges: list[list[int]]) -> int:
    """Check if graph is biconnected (no articulation points, connected). 1=yes, 0=no."""
    if n <= 2:
        return 1
    pts: list[int] = find_articulation_points(n, edges)
    if len(pts) > 0:
        return 0
    visited: list[int] = [0] * n
    adj: list[list[int]] = []
    i: int = 0
    while i < n:
        adj.append([])
        i = i + 1
    e: int = 0
    while e < len(edges):
        u: int = edges[e][0]
        v: int = edges[e][1]
        adj[u].append(v)
        adj[v].append(u)
        e = e + 1
    stack: list[int] = [0]
    visited[0] = 1
    while len(stack) > 0:
        curr: int = stack.pop()
        ni: int = 0
        while ni < len(adj[curr]):
            nb: int = adj[curr][ni]
            if visited[nb] == 0:
                visited[nb] = 1
                stack.append(nb)
            ni = ni + 1
    k: int = 0
    while k < n:
        if visited[k] == 0:
            return 0
        k = k + 1
    return 1


def test_module() -> int:
    passed: int = 0
    edges1: list[list[int]] = [[0, 1], [1, 2], [2, 0], [1, 3], [3, 4]]
    ap1: list[int] = find_articulation_points(5, edges1)
    if len(ap1) == 2:
        passed = passed + 1
    if count_articulation_points(5, edges1) == 2:
        passed = passed + 1
    edges2: list[list[int]] = [[0, 1], [1, 2], [2, 0]]
    if count_articulation_points(3, edges2) == 0:
        passed = passed + 1
    if is_biconnected(3, edges2) == 1:
        passed = passed + 1
    if is_biconnected(5, edges1) == 0:
        passed = passed + 1
    return passed
