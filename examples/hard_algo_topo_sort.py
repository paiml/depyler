# Generated by: depyler corpus generator
# Source: hard_algo_topo_sort.py
#
# Topological sort using adjacency list representation.


def topo_sort_kahn(num_nodes: int, edges: List[List[int]]) -> List[int]:
    """Kahn's algorithm for topological sort. edges[i] = [from, to]."""
    in_deg: List[int] = [0] * num_nodes
    adj: List[List[int]] = []
    i: int = 0
    while i < num_nodes:
        adj.append([])
        i = i + 1
    e: int = 0
    while e < len(edges):
        edge: List[int] = edges[e]
        src: int = edge[0]
        dst: int = edge[1]
        adj[src].append(dst)
        in_deg[dst] = in_deg[dst] + 1
        e = e + 1
    queue: List[int] = []
    q: int = 0
    while q < num_nodes:
        if in_deg[q] == 0:
            queue.append(q)
        q = q + 1
    result: List[int] = []
    while len(queue) > 0:
        node: int = queue[0]
        new_q: List[int] = []
        qi: int = 1
        while qi < len(queue):
            new_q.append(queue[qi])
            qi = qi + 1
        queue = new_q
        result.append(node)
        ni: int = 0
        neighbors: List[int] = adj[node]
        while ni < len(neighbors):
            nb: int = neighbors[ni]
            in_deg[nb] = in_deg[nb] - 1
            if in_deg[nb] == 0:
                queue.append(nb)
            ni = ni + 1
    if len(result) != num_nodes:
        return []
    return result


def has_cycle(num_nodes: int, edges: List[List[int]]) -> int:
    """Check if directed graph has a cycle. Returns 1 if cycle, 0 otherwise."""
    order: List[int] = topo_sort_kahn(num_nodes, edges)
    if len(order) == 0 and num_nodes > 0:
        return 1
    return 0


def count_sources(num_nodes: int, edges: List[List[int]]) -> int:
    """Count nodes with no incoming edges."""
    in_deg: List[int] = [0] * num_nodes
    e: int = 0
    while e < len(edges):
        edge: List[int] = edges[e]
        dst: int = edge[1]
        in_deg[dst] = in_deg[dst] + 1
        e = e + 1
    count: int = 0
    i: int = 0
    while i < num_nodes:
        if in_deg[i] == 0:
            count = count + 1
        i = i + 1
    return count


def count_sinks(num_nodes: int, edges: List[List[int]]) -> int:
    """Count nodes with no outgoing edges."""
    out_deg: List[int] = [0] * num_nodes
    e: int = 0
    while e < len(edges):
        edge: List[int] = edges[e]
        src: int = edge[0]
        out_deg[src] = out_deg[src] + 1
        e = e + 1
    count: int = 0
    i: int = 0
    while i < num_nodes:
        if out_deg[i] == 0:
            count = count + 1
        i = i + 1
    return count


def test_module() -> int:
    """Test all topological sort functions."""
    passed: int = 0

    edges1: List[List[int]] = [[5, 2], [5, 0], [4, 0], [4, 1], [2, 3], [3, 1]]
    r1: List[int] = topo_sort_kahn(6, edges1)
    if len(r1) == 6:
        passed = passed + 1

    edges2: List[List[int]] = [[0, 1], [1, 2], [2, 0]]
    r2: List[int] = topo_sort_kahn(3, edges2)
    if r2 == []:
        passed = passed + 1

    r3: List[int] = topo_sort_kahn(1, [])
    if r3 == [0]:
        passed = passed + 1

    r4: int = has_cycle(3, [[0, 1], [1, 2], [2, 0]])
    if r4 == 1:
        passed = passed + 1

    r5: int = has_cycle(3, [[0, 1], [1, 2]])
    if r5 == 0:
        passed = passed + 1

    r6: int = count_sources(4, [[0, 1], [0, 2], [2, 3]])
    if r6 == 1:
        passed = passed + 1

    r7: int = count_sinks(4, [[0, 1], [0, 2], [2, 3]])
    if r7 == 2:
        passed = passed + 1

    return passed
