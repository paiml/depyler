# Generated by: depyler corpus generator
# Source: hard_adv_opt_genetic.py
#
# Genetic algorithm operations: selection, crossover, mutation, fitness.


def fitness(chromosome: list[int], target: list[int]) -> int:
    """Fitness = number of matching positions between chromosome and target."""
    score: int = 0
    i: int = 0
    n: int = len(chromosome)
    m: int = len(target)
    limit: int = n
    if m < limit:
        limit = m
    while i < limit:
        cv: int = chromosome[i]
        tv: int = target[i]
        if cv == tv:
            score = score + 1
        i = i + 1
    return score


def crossover_onepoint(parent_a: list[int], parent_b: list[int], split: int) -> list[int]:
    """One-point crossover at given split index."""
    child: list[int] = []
    i: int = 0
    n: int = len(parent_a)
    while i < n:
        if i < split:
            val: int = parent_a[i]
        else:
            val = parent_b[i]
        child.append(val)
        i = i + 1
    return child


def mutate(chromosome: list[int], position: int, new_val: int) -> list[int]:
    """Mutate a single position in the chromosome."""
    result: list[int] = []
    i: int = 0
    n: int = len(chromosome)
    while i < n:
        if i == position:
            result.append(new_val)
        else:
            cv: int = chromosome[i]
            result.append(cv)
        i = i + 1
    return result


def tournament_select(pop: list[int], fitnesses: list[int], idx_a: int, idx_b: int) -> int:
    """Select better individual from two candidates. Returns index."""
    fa: int = fitnesses[idx_a]
    fb: int = fitnesses[idx_b]
    if fa >= fb:
        return idx_a
    return idx_b


def evaluate_population(pop_flat: list[int], chrom_size: int, target: list[int]) -> list[int]:
    """Evaluate fitness for a flat population array. Returns fitness list."""
    result: list[int] = []
    num_chroms: int = len(pop_flat) // chrom_size
    i: int = 0
    while i < num_chroms:
        chrom: list[int] = []
        j: int = 0
        while j < chrom_size:
            idx: int = i * chrom_size + j
            val: int = pop_flat[idx]
            chrom.append(val)
            j = j + 1
        f: int = fitness(chrom, target)
        result.append(f)
        i = i + 1
    return result


def best_in_population(fitnesses: list[int]) -> int:
    """Find index of best fitness."""
    best_idx: int = 0
    best_fit: int = fitnesses[0]
    i: int = 1
    n: int = len(fitnesses)
    while i < n:
        fi: int = fitnesses[i]
        if fi > best_fit:
            best_fit = fi
            best_idx = i
        i = i + 1
    return best_idx


def test_module() -> int:
    """Test genetic algorithm operations."""
    passed: int = 0

    f1: int = fitness([1, 2, 3, 4], [1, 2, 3, 4])
    if f1 == 4:
        passed = passed + 1

    f2: int = fitness([1, 0, 3, 0], [1, 2, 3, 4])
    if f2 == 2:
        passed = passed + 1

    child: list[int] = crossover_onepoint([1, 1, 1, 1], [2, 2, 2, 2], 2)
    c0: int = child[0]
    c2: int = child[2]
    if c0 == 1 and c2 == 2:
        passed = passed + 1

    mutated: list[int] = mutate([1, 2, 3], 1, 99)
    mv: int = mutated[1]
    if mv == 99:
        passed = passed + 1

    winner: int = tournament_select([0, 0, 0], [10, 20, 5], 0, 1)
    if winner == 1:
        passed = passed + 1

    fits: list[int] = evaluate_population([1, 2, 3, 4, 5, 6], 3, [1, 2, 3])
    if len(fits) == 2:
        passed = passed + 1

    best: int = best_in_population([5, 10, 3, 8])
    if best == 1:
        passed = passed + 1

    return passed
