# Generated by: depyler corpus generator
# Source: hard_cp_dp_lcs.py
#
# Longest Common Subsequence variants for transpiler stress testing.


def lcs_length(text1: str, text2: str) -> int:
    """Length of longest common subsequence of two strings."""
    m: int = len(text1)
    n: int = len(text2)
    dp: list[list[int]] = []
    r: int = 0
    while r <= m:
        row: list[int] = [0] * (n + 1)
        dp.append(row)
        r = r + 1
    i: int = 1
    while i <= m:
        j: int = 1
        while j <= n:
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                top: int = dp[i - 1][j]
                left: int = dp[i][j - 1]
                if top > left:
                    dp[i][j] = top
                else:
                    dp[i][j] = left
            j = j + 1
        i = i + 1
    return dp[m][n]


def lcs_of_three(a: str, b: str, c: str) -> int:
    """LCS length of three strings using 3D DP."""
    la: int = len(a)
    lb: int = len(b)
    lc: int = len(c)
    dp: list[list[list[int]]] = []
    i: int = 0
    while i <= la:
        plane: list[list[int]] = []
        j: int = 0
        while j <= lb:
            row: list[int] = [0] * (lc + 1)
            plane.append(row)
            j = j + 1
        dp.append(plane)
        i = i + 1
    i2: int = 1
    while i2 <= la:
        j2: int = 1
        while j2 <= lb:
            k2: int = 1
            while k2 <= lc:
                if a[i2 - 1] == b[j2 - 1] and b[j2 - 1] == c[k2 - 1]:
                    dp[i2][j2][k2] = dp[i2 - 1][j2 - 1][k2 - 1] + 1
                else:
                    v1: int = dp[i2 - 1][j2][k2]
                    v2: int = dp[i2][j2 - 1][k2]
                    v3: int = dp[i2][j2][k2 - 1]
                    best: int = v1
                    if v2 > best:
                        best = v2
                    if v3 > best:
                        best = v3
                    dp[i2][j2][k2] = best
                k2 = k2 + 1
            j2 = j2 + 1
        i2 = i2 + 1
    return dp[la][lb][lc]


def lcs_space_optimized(text1: str, text2: str) -> int:
    """LCS with O(n) space using two rows."""
    m: int = len(text1)
    n: int = len(text2)
    prev: list[int] = [0] * (n + 1)
    curr: list[int] = [0] * (n + 1)
    i: int = 1
    while i <= m:
        j: int = 1
        while j <= n:
            if text1[i - 1] == text2[j - 1]:
                curr[j] = prev[j - 1] + 1
            else:
                top: int = prev[j]
                left: int = curr[j - 1]
                if top > left:
                    curr[j] = top
                else:
                    curr[j] = left
            j = j + 1
        k: int = 0
        while k <= n:
            prev[k] = curr[k]
            curr[k] = 0
            k = k + 1
        i = i + 1
    return prev[n]


def shortest_common_supersequence_len(text1: str, text2: str) -> int:
    """Length of shortest common supersequence using LCS."""
    lcs_val: int = lcs_length(text1, text2)
    return len(text1) + len(text2) - lcs_val


def test_module() -> int:
    passed: int = 0
    if lcs_length("abcde", "ace") == 3:
        passed = passed + 1
    if lcs_length("abc", "def") == 0:
        passed = passed + 1
    if lcs_of_three("abcd", "abdc", "abcd") == 3:
        passed = passed + 1
    if lcs_space_optimized("abcde", "ace") == 3:
        passed = passed + 1
    if shortest_common_supersequence_len("abac", "cab") == 5:
        passed = passed + 1
    if lcs_length("", "abc") == 0:
        passed = passed + 1
    return passed
