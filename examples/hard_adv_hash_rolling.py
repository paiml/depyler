# Generated by: depyler corpus generator
# Source: hard_adv_hash_rolling.py
#
# Rolling hash (Rabin-Karp style) for substring matching.


def rolling_hash_init(data: list[int], window: int) -> int:
    """Compute initial rolling hash for first window elements."""
    h: int = 0
    i: int = 0
    while i < window and i < len(data):
        val: int = data[i]
        h = (h * 31 + val) % 1000000007
        i = i + 1
    return h


def power_mod(mult: int, exp: int, mod_val: int) -> int:
    """Compute mult^exp % mod_val using repeated squaring."""
    result: int = 1
    cur: int = mult % mod_val
    e: int = exp
    while e > 0:
        if e % 2 == 1:
            result = (result * cur) % mod_val
        cur = (cur * cur) % mod_val
        e = e // 2
    return result


def rolling_hash_update(old_hash: int, old_val: int, new_val: int, window: int) -> int:
    """Update rolling hash by removing old_val and adding new_val."""
    mod_val: int = 1000000007
    pw: int = power_mod(31, window - 1, mod_val)
    h: int = old_hash
    h = (h + mod_val - (old_val * pw) % mod_val) % mod_val
    h = (h * 31 + new_val) % mod_val
    return h


def find_substring(text: list[int], needle: list[int]) -> int:
    """Find first occurrence of needle in text using rolling hash. Returns index or -1."""
    tlen: int = len(text)
    nlen: int = len(needle)
    if nlen > tlen:
        return -1
    if nlen == 0:
        return 0
    target: int = rolling_hash_init(needle, nlen)
    current: int = rolling_hash_init(text, nlen)
    if current == target:
        match: int = 1
        j: int = 0
        while j < nlen:
            tv: int = text[j]
            nv: int = needle[j]
            if tv != nv:
                match = 0
            j = j + 1
        if match == 1:
            return 0
    i: int = 1
    while i <= tlen - nlen:
        old_v: int = text[i - 1]
        new_v: int = text[i + nlen - 1]
        current = rolling_hash_update(current, old_v, new_v, nlen)
        if current == target:
            ok: int = 1
            k: int = 0
            while k < nlen:
                tv2: int = text[i + k]
                nv2: int = needle[k]
                if tv2 != nv2:
                    ok = 0
                k = k + 1
            if ok == 1:
                return i
        i = i + 1
    return -1


def count_occurrences(text: list[int], needle: list[int]) -> int:
    """Count all non-overlapping occurrences of needle in text."""
    cnt: int = 0
    pos: int = 0
    tlen: int = len(text)
    nlen: int = len(needle)
    while pos <= tlen - nlen:
        remaining: list[int] = []
        j: int = pos
        while j < tlen:
            v: int = text[j]
            remaining.append(v)
            j = j + 1
        found: int = find_substring(remaining, needle)
        if found == -1:
            return cnt
        cnt = cnt + 1
        pos = pos + found + nlen
    return cnt


def test_module() -> int:
    """Test rolling hash functions."""
    passed: int = 0

    h1: int = rolling_hash_init([1, 2, 3, 4], 3)
    h2: int = rolling_hash_init([1, 2, 3, 4], 3)
    if h1 == h2:
        passed = passed + 1

    pw: int = power_mod(2, 10, 1000000007)
    if pw == 1024:
        passed = passed + 1

    pw2: int = power_mod(31, 0, 1000000007)
    if pw2 == 1:
        passed = passed + 1

    idx: int = find_substring([1, 2, 3, 4, 5], [3, 4])
    if idx == 2:
        passed = passed + 1

    idx2: int = find_substring([1, 2, 3, 4, 5], [9, 9])
    if idx2 == -1:
        passed = passed + 1

    c: int = count_occurrences([1, 2, 1, 2, 1, 2], [1, 2])
    if c == 3:
        passed = passed + 1

    return passed
