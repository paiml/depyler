# Generated by: depyler corpus generator
# Source: hard_dynamic_programming.py
#
# Pathological dynamic programming patterns for Python-to-Rust transpilation stress testing.
# Covers: 1D DP, 2D DP, knapsack, interval DP, bitmask DP, space optimization,
# backtracking reconstruction, and multi-dimensional accumulation.


def fibonacci_bottom_up(n: int) -> int:
    """Classic bottom-up Fibonacci with 1D DP table."""
    if n <= 1:
        return n
    dp: List[int] = [0] * (n + 1)
    dp[0] = 0
    dp[1] = 1
    i: int = 2
    while i <= n:
        dp[i] = dp[i - 1] + dp[i - 2]
        i = i + 1
    return dp[n]


def climb_stairs_ways(n: int) -> int:
    """Count ways to climb n stairs taking 1, 2, or 3 steps at a time."""
    if n <= 0:
        return 0
    if n == 1:
        return 1
    if n == 2:
        return 2
    dp: List[int] = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1
    dp[2] = 2
    i: int = 3
    while i <= n:
        dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3]
        i = i + 1
    return dp[n]


def coin_change_min(coins: List[int], amount: int) -> int:
    """Minimum coins needed to make amount. Returns -1 if impossible."""
    if amount == 0:
        return 0
    big: int = amount + 1
    dp: List[int] = [big] * (amount + 1)
    dp[0] = 0
    i: int = 1
    while i <= amount:
        j: int = 0
        while j < len(coins):
            c: int = coins[j]
            if c <= i:
                prev: int = dp[i - c]
                candidate: int = prev + 1
                if candidate < dp[i]:
                    dp[i] = candidate
            j = j + 1
        i = i + 1
    result: int = dp[amount]
    if result > amount:
        return -1
    return result


def coin_change_count(coins: List[int], amount: int) -> int:
    """Count number of distinct ways to make amount with given coins."""
    dp: List[int] = [0] * (amount + 1)
    dp[0] = 1
    j: int = 0
    while j < len(coins):
        c: int = coins[j]
        i: int = c
        while i <= amount:
            dp[i] = dp[i] + dp[i - c]
            i = i + 1
        j = j + 1
    return dp[amount]


def longest_increasing_subsequence(nums: List[int]) -> int:
    """Length of the longest strictly increasing subsequence using O(n^2) DP."""
    n: int = len(nums)
    if n == 0:
        return 0
    dp: List[int] = [1] * n
    i: int = 1
    while i < n:
        j: int = 0
        while j < i:
            if nums[j] < nums[i]:
                candidate: int = dp[j] + 1
                if candidate > dp[i]:
                    dp[i] = candidate
            j = j + 1
        i = i + 1
    best: int = 0
    k: int = 0
    while k < n:
        if dp[k] > best:
            best = dp[k]
        k = k + 1
    return best


def max_subarray_sum(nums: List[int]) -> int:
    """Maximum contiguous subarray sum (Kadane's algorithm as DP)."""
    n: int = len(nums)
    if n == 0:
        return 0
    best: int = nums[0]
    current: int = nums[0]
    i: int = 1
    while i < n:
        if current + nums[i] > nums[i]:
            current = current + nums[i]
        else:
            current = nums[i]
        if current > best:
            best = current
        i = i + 1
    return best


def house_robber(houses: List[int]) -> int:
    """Max money from non-adjacent houses. Classic 1D DP with state transition."""
    n: int = len(houses)
    if n == 0:
        return 0
    if n == 1:
        return houses[0]
    prev2: int = 0
    prev1: int = houses[0]
    i: int = 1
    while i < n:
        take: int = prev2 + houses[i]
        skip: int = prev1
        if take > skip:
            current: int = take
        else:
            current = skip
        prev2 = prev1
        prev1 = current
        i = i + 1
    return prev1


def unique_grid_paths(m: int, n: int) -> int:
    """Count unique paths in m x n grid moving only right or down. 2D DP."""
    dp: List[List[int]] = []
    r: int = 0
    while r < m:
        row: List[int] = [0] * n
        dp.append(row)
        r = r + 1
    i: int = 0
    while i < m:
        dp[i][0] = 1
        i = i + 1
    j: int = 0
    while j < n:
        dp[0][j] = 1
        j = j + 1
    i2: int = 1
    while i2 < m:
        j2: int = 1
        while j2 < n:
            dp[i2][j2] = dp[i2 - 1][j2] + dp[i2][j2 - 1]
            j2 = j2 + 1
        i2 = i2 + 1
    return dp[m - 1][n - 1]


def min_path_sum(grid: List[List[int]]) -> int:
    """Minimum cost path from top-left to bottom-right in a grid."""
    m: int = len(grid)
    if m == 0:
        return 0
    n: int = len(grid[0])
    if n == 0:
        return 0
    dp: List[List[int]] = []
    r: int = 0
    while r < m:
        row: List[int] = [0] * n
        dp.append(row)
        r = r + 1
    dp[0][0] = grid[0][0]
    i: int = 1
    while i < m:
        dp[i][0] = dp[i - 1][0] + grid[i][0]
        i = i + 1
    j: int = 1
    while j < n:
        dp[0][j] = dp[0][j - 1] + grid[0][j]
        j = j + 1
    i2: int = 1
    while i2 < m:
        j2: int = 1
        while j2 < n:
            top: int = dp[i2 - 1][j2]
            left: int = dp[i2][j2 - 1]
            if top < left:
                dp[i2][j2] = top + grid[i2][j2]
            else:
                dp[i2][j2] = left + grid[i2][j2]
            j2 = j2 + 1
        i2 = i2 + 1
    return dp[m - 1][n - 1]


def edit_distance(word1: str, word2: str) -> int:
    """Levenshtein edit distance between two strings. Classic 2D DP."""
    m: int = len(word1)
    n: int = len(word2)
    dp: List[List[int]] = []
    r: int = 0
    while r <= m:
        row: List[int] = [0] * (n + 1)
        dp.append(row)
        r = r + 1
    i: int = 0
    while i <= m:
        dp[i][0] = i
        i = i + 1
    j: int = 0
    while j <= n:
        dp[0][j] = j
        j = j + 1
    i2: int = 1
    while i2 <= m:
        j2: int = 1
        while j2 <= n:
            if word1[i2 - 1] == word2[j2 - 1]:
                dp[i2][j2] = dp[i2 - 1][j2 - 1]
            else:
                replace_cost: int = dp[i2 - 1][j2 - 1] + 1
                insert_cost: int = dp[i2][j2 - 1] + 1
                delete_cost: int = dp[i2 - 1][j2] + 1
                best: int = replace_cost
                if insert_cost < best:
                    best = insert_cost
                if delete_cost < best:
                    best = delete_cost
                dp[i2][j2] = best
            j2 = j2 + 1
        i2 = i2 + 1
    return dp[m][n]


def longest_common_subsequence(text1: str, text2: str) -> int:
    """Length of the longest common subsequence of two strings."""
    m: int = len(text1)
    n: int = len(text2)
    dp: List[List[int]] = []
    r: int = 0
    while r <= m:
        row: List[int] = [0] * (n + 1)
        dp.append(row)
        r = r + 1
    i: int = 1
    while i <= m:
        j: int = 1
        while j <= n:
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                top: int = dp[i - 1][j]
                left: int = dp[i][j - 1]
                if top > left:
                    dp[i][j] = top
                else:
                    dp[i][j] = left
            j = j + 1
        i = i + 1
    return dp[m][n]


def knapsack_01(weights: List[int], values: List[int], capacity: int) -> int:
    """0/1 knapsack: max value without exceeding capacity."""
    n: int = len(weights)
    dp: List[List[int]] = []
    r: int = 0
    while r <= n:
        row: List[int] = [0] * (capacity + 1)
        dp.append(row)
        r = r + 1
    i: int = 1
    while i <= n:
        w: int = weights[i - 1]
        v: int = values[i - 1]
        j: int = 0
        while j <= capacity:
            dp[i][j] = dp[i - 1][j]
            if w <= j:
                candidate: int = dp[i - 1][j - w] + v
                if candidate > dp[i][j]:
                    dp[i][j] = candidate
            j = j + 1
        i = i + 1
    return dp[n][capacity]


def knapsack_01_space_optimized(weights: List[int], values: List[int], capacity: int) -> int:
    """0/1 knapsack with O(capacity) space using rolling 1D array."""
    n: int = len(weights)
    dp: List[int] = [0] * (capacity + 1)
    i: int = 0
    while i < n:
        w: int = weights[i]
        v: int = values[i]
        j: int = capacity
        while j >= w:
            candidate: int = dp[j - w] + v
            if candidate > dp[j]:
                dp[j] = candidate
            j = j - 1
        i = i + 1
    return dp[capacity]


def unbounded_knapsack(weights: List[int], values: List[int], capacity: int) -> int:
    """Unbounded knapsack: items can be used multiple times."""
    dp: List[int] = [0] * (capacity + 1)
    j: int = 1
    while j <= capacity:
        i: int = 0
        while i < len(weights):
            w: int = weights[i]
            v: int = values[i]
            if w <= j:
                candidate: int = dp[j - w] + v
                if candidate > dp[j]:
                    dp[j] = candidate
            i = i + 1
        j = j + 1
    return dp[capacity]


def matrix_chain_order(dims: List[int]) -> int:
    """Minimum scalar multiplications for matrix chain. Interval DP."""
    n: int = len(dims) - 1
    if n <= 1:
        return 0
    dp: List[List[int]] = []
    r: int = 0
    while r < n:
        row: List[int] = [0] * n
        dp.append(row)
        r = r + 1
    chain_len: int = 2
    while chain_len <= n:
        i: int = 0
        while i <= n - chain_len:
            j: int = i + chain_len - 1
            dp[i][j] = 999999999
            k: int = i
            while k < j:
                cost: int = dp[i][k] + dp[k + 1][j] + dims[i] * dims[k + 1] * dims[j + 1]
                if cost < dp[i][j]:
                    dp[i][j] = cost
                k = k + 1
            i = i + 1
        chain_len = chain_len + 1
    return dp[0][n - 1]


def palindrome_partitioning_min(s: str) -> int:
    """Minimum cuts to partition string into palindromes. Interval + 1D DP."""
    n: int = len(s)
    if n <= 1:
        return 0
    is_pal: List[List[bool]] = []
    r: int = 0
    while r < n:
        row: List[bool] = [False] * n
        is_pal.append(row)
        is_pal[r][r] = True
        r = r + 1
    length: int = 2
    while length <= n:
        start: int = 0
        while start <= n - length:
            end: int = start + length - 1
            if s[start] == s[end]:
                is_pal[start][end] = length == 2 or is_pal[start + 1][end - 1]
            start = start + 1
        length = length + 1
    cuts: List[int] = [0] * n
    i: int = 0
    while i < n:
        if is_pal[0][i]:
            cuts[i] = 0
        else:
            cuts[i] = i
            j: int = 1
            while j <= i:
                if is_pal[j][i]:
                    candidate: int = cuts[j - 1] + 1
                    if candidate < cuts[i]:
                        cuts[i] = candidate
                j = j + 1
        i = i + 1
    return cuts[n - 1]


def tsp_bitmask(dist: List[List[int]], n: int) -> int:
    """Traveling salesman via bitmask DP. Exact solution for small n."""
    full_mask: int = (1 << n) - 1
    big: int = 999999999
    num_states: int = 1 << n
    dp: List[List[int]] = []
    mask: int = 0
    while mask < num_states:
        row: List[int] = [big] * n
        dp.append(row)
        mask = mask + 1
    dp[1][0] = 0
    mask2: int = 1
    while mask2 <= full_mask:
        city: int = 0
        while city < n:
            if dp[mask2][city] < big:
                next_city: int = 0
                while next_city < n:
                    bit: int = 1 << next_city
                    if (mask2 & bit) == 0:
                        new_mask: int = mask2 | bit
                        candidate: int = dp[mask2][city] + dist[city][next_city]
                        if candidate < dp[new_mask][next_city]:
                            dp[new_mask][next_city] = candidate
                    next_city = next_city + 1
            city = city + 1
        mask2 = mask2 + 1
    result: int = big
    city2: int = 1
    while city2 < n:
        candidate2: int = dp[full_mask][city2] + dist[city2][0]
        if candidate2 < result:
            result = candidate2
        city2 = city2 + 1
    return result


def subset_sum_exists(nums: List[int], target: int) -> bool:
    """Check if any subset sums to target. Boolean 2D DP with space optimization."""
    n: int = len(nums)
    dp: List[bool] = [False] * (target + 1)
    dp[0] = True
    i: int = 0
    while i < n:
        j: int = target
        while j >= nums[i]:
            if dp[j - nums[i]]:
                dp[j] = True
            j = j - 1
        i = i + 1
    return dp[target]


def longest_palindromic_subsequence(s: str) -> int:
    """Length of longest palindromic subsequence. 2D interval DP on string."""
    n: int = len(s)
    if n == 0:
        return 0
    dp: List[List[int]] = []
    r: int = 0
    while r < n:
        row: List[int] = [0] * n
        dp.append(row)
        r = r + 1
    i: int = 0
    while i < n:
        dp[i][i] = 1
        i = i + 1
    length: int = 2
    while length <= n:
        start: int = 0
        while start <= n - length:
            end: int = start + length - 1
            if s[start] == s[end]:
                if length == 2:
                    dp[start][end] = 2
                else:
                    dp[start][end] = dp[start + 1][end - 1] + 2
            else:
                left: int = dp[start + 1][end]
                right: int = dp[start][end - 1]
                if left > right:
                    dp[start][end] = left
                else:
                    dp[start][end] = right
            start = start + 1
        length = length + 1
    return dp[0][n - 1]


def decode_ways(s: str) -> int:
    """Count ways to decode a digit string where 1-26 map to A-Z. 1D DP with lookahead."""
    n: int = len(s)
    if n == 0:
        return 0
    dp: List[int] = [0] * (n + 1)
    dp[0] = 1
    if s[0] == "0":
        dp[1] = 0
    else:
        dp[1] = 1
    i: int = 2
    while i <= n:
        one_digit: int = int(s[i - 1])
        two_digit: int = int(s[i - 2]) * 10 + int(s[i - 1])
        if one_digit >= 1:
            dp[i] = dp[i] + dp[i - 1]
        if two_digit >= 10:
            if two_digit <= 26:
                dp[i] = dp[i] + dp[i - 2]
        i = i + 1
    return dp[n]


def max_profit_stock_cooldown(prices: List[int]) -> int:
    """Best stock profit with cooldown. Multi-state 1D DP."""
    n: int = len(prices)
    if n <= 1:
        return 0
    hold: List[int] = [0] * n
    sold: List[int] = [0] * n
    rest: List[int] = [0] * n
    hold[0] = 0 - prices[0]
    sold[0] = 0
    rest[0] = 0
    i: int = 1
    while i < n:
        prev_hold: int = hold[i - 1]
        prev_rest: int = rest[i - 1]
        buy_today: int = prev_rest - prices[i]
        if prev_hold > buy_today:
            hold[i] = prev_hold
        else:
            hold[i] = buy_today
        sold[i] = hold[i - 1] + prices[i]
        prev_sold: int = sold[i - 1]
        if prev_rest > prev_sold:
            rest[i] = prev_rest
        else:
            rest[i] = prev_sold
        i = i + 1
    last_sold: int = sold[n - 1]
    last_rest: int = rest[n - 1]
    if last_sold > last_rest:
        return last_sold
    return last_rest


def word_break_count(s: str, words: List[str]) -> int:
    """Count ways to segment string s using dictionary words. 1D DP with inner scan."""
    n: int = len(s)
    dp: List[int] = [0] * (n + 1)
    dp[0] = 1
    i: int = 1
    while i <= n:
        wi: int = 0
        while wi < len(words):
            w: str = words[wi]
            wlen: int = len(w)
            if wlen <= i:
                start: int = i - wlen
                match: bool = True
                k: int = 0
                while k < wlen:
                    if s[start + k] != w[k]:
                        match = False
                    k = k + 1
                if match:
                    dp[i] = dp[i] + dp[start]
            wi = wi + 1
        i = i + 1
    return dp[n]


def max_sum_non_adjacent_2d(grid: List[List[int]]) -> int:
    """Max sum from grid picking at most one per row, no two from adjacent columns."""
    m: int = len(grid)
    if m == 0:
        return 0
    n: int = len(grid[0])
    if n == 0:
        return 0
    prev: List[int] = [0] * (n + 2)
    j: int = 0
    while j < n:
        prev[j] = grid[0][j]
        j = j + 1
    row: int = 1
    while row < m:
        curr: List[int] = [0] * (n + 2)
        col: int = 0
        while col < n:
            best_prev: int = 0
            k: int = 0
            while k < n:
                diff: int = k - col
                if diff < 0:
                    diff = 0 - diff
                if diff > 1:
                    if prev[k] > best_prev:
                        best_prev = prev[k]
                k = k + 1
            curr[col] = best_prev + grid[row][col]
            col = col + 1
        prev = curr
        row = row + 1
    result: int = 0
    idx: int = 0
    while idx < n:
        if prev[idx] > result:
            result = prev[idx]
        idx = idx + 1
    return result


def lis_with_reconstruction(nums: List[int]) -> List[int]:
    """Longest increasing subsequence with path reconstruction."""
    n: int = len(nums)
    if n == 0:
        return []
    dp: List[int] = [1] * n
    parent: List[int] = [-1] * n
    i: int = 1
    while i < n:
        j: int = 0
        while j < i:
            if nums[j] < nums[i]:
                candidate: int = dp[j] + 1
                if candidate > dp[i]:
                    dp[i] = candidate
                    parent[i] = j
            j = j + 1
        i = i + 1
    best_len: int = 0
    best_idx: int = 0
    k: int = 0
    while k < n:
        if dp[k] > best_len:
            best_len = dp[k]
            best_idx = k
        k = k + 1
    result: List[int] = []
    pos: int = best_idx
    while pos != -1:
        result.append(nums[pos])
        pos = parent[pos]
    left: int = 0
    right: int = len(result) - 1
    while left < right:
        tmp: int = result[left]
        result[left] = result[right]
        result[right] = tmp
        left = left + 1
        right = right - 1
    return result


def egg_drop(eggs: int, floors: int) -> int:
    """Minimum trials to find critical floor with given eggs and floors."""
    dp: List[List[int]] = []
    r: int = 0
    while r <= eggs:
        row: List[int] = [0] * (floors + 1)
        dp.append(row)
        r = r + 1
    f: int = 1
    while f <= floors:
        dp[1][f] = f
        f = f + 1
    e: int = 2
    while e <= eggs:
        fl: int = 1
        while fl <= floors:
            dp[e][fl] = fl
            k: int = 1
            while k <= fl:
                breaks: int = dp[e - 1][k - 1]
                survives: int = dp[e][fl - k]
                if breaks > survives:
                    worst: int = breaks
                else:
                    worst = survives
                trial: int = worst + 1
                if trial < dp[e][fl]:
                    dp[e][fl] = trial
                k = k + 1
            fl = fl + 1
        e = e + 1
    return dp[eggs][floors]


def count_partitions(n: int) -> int:
    """Count the number of integer partitions of n. Accumulation DP."""
    dp: List[int] = [0] * (n + 1)
    dp[0] = 1
    k: int = 1
    while k <= n:
        j: int = k
        while j <= n:
            dp[j] = dp[j] + dp[j - k]
            j = j + 1
        k = k + 1
    return dp[n]


def test_all() -> bool:
    """Test every function in this module for correctness."""
    ok: bool = True

    if fibonacci_bottom_up(0) != 0:
        ok = False
    if fibonacci_bottom_up(1) != 1:
        ok = False
    if fibonacci_bottom_up(10) != 55:
        ok = False

    if climb_stairs_ways(0) != 0:
        ok = False
    if climb_stairs_ways(1) != 1:
        ok = False
    if climb_stairs_ways(4) != 7:
        ok = False

    if coin_change_min([1, 5, 10], 11) != 2:
        ok = False
    if coin_change_min([2], 3) != -1:
        ok = False
    if coin_change_min([1], 0) != 0:
        ok = False

    if coin_change_count([1, 2, 5], 5) != 4:
        ok = False

    if longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) != 4:
        ok = False
    if longest_increasing_subsequence([]) != 0:
        ok = False

    if max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) != 6:
        ok = False

    if house_robber([1, 2, 3, 1]) != 4:
        ok = False
    if house_robber([2, 7, 9, 3, 1]) != 12:
        ok = False

    if unique_grid_paths(3, 7) != 28:
        ok = False
    if unique_grid_paths(1, 1) != 1:
        ok = False

    if min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) != 7:
        ok = False

    if edit_distance("kitten", "sitting") != 3:
        ok = False
    if edit_distance("", "abc") != 3:
        ok = False

    if longest_common_subsequence("abcde", "ace") != 3:
        ok = False
    if longest_common_subsequence("abc", "def") != 0:
        ok = False

    if knapsack_01([1, 3, 4, 5], [1, 4, 5, 7], 7) != 9:
        ok = False
    if knapsack_01_space_optimized([1, 3, 4, 5], [1, 4, 5, 7], 7) != 9:
        ok = False

    if unbounded_knapsack([2, 3, 4], [3, 4, 5], 7) != 10:
        ok = False

    if matrix_chain_order([10, 30, 5, 60]) != 4500:
        ok = False

    if palindrome_partitioning_min("aab") != 1:
        ok = False
    if palindrome_partitioning_min("a") != 0:
        ok = False

    dist4: List[List[int]] = [
        [0, 10, 15, 20],
        [10, 0, 35, 25],
        [15, 35, 0, 30],
        [20, 25, 30, 0],
    ]
    if tsp_bitmask(dist4, 4) != 80:
        ok = False

    if subset_sum_exists([3, 34, 4, 12, 5, 2], 9) != True:
        ok = False
    if subset_sum_exists([3, 34, 4, 12, 5, 2], 30) != False:
        ok = False

    if longest_palindromic_subsequence("bbbab") != 4:
        ok = False
    if longest_palindromic_subsequence("cbbd") != 2:
        ok = False

    if decode_ways("226") != 3:
        ok = False
    if decode_ways("06") != 0:
        ok = False

    if max_profit_stock_cooldown([1, 2, 3, 0, 2]) != 3:
        ok = False

    if word_break_count("aab", ["a", "aa", "b"]) != 2:
        ok = False

    grid2d: List[List[int]] = [[5, 1, 3], [2, 8, 1], [4, 1, 7]]
    val: int = max_sum_non_adjacent_2d(grid2d)
    if val < 12:
        ok = False

    lis_result: List[int] = lis_with_reconstruction([10, 9, 2, 5, 3, 7, 101, 18])
    if len(lis_result) != 4:
        ok = False

    if egg_drop(2, 10) != 4:
        ok = False
    if egg_drop(1, 5) != 5:
        ok = False

    if count_partitions(5) != 7:
        ok = False
    if count_partitions(0) != 1:
        ok = False

    return ok
