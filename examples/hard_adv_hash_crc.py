# Generated by: depyler corpus generator
# Source: hard_adv_hash_crc.py
#
# CRC-like checksum computation using table-driven approach.


def crc_table_entry(idx: int) -> int:
    """Compute one entry of a CRC-like lookup table."""
    crc: int = idx
    bit: int = 0
    while bit < 8:
        if crc % 2 == 1:
            crc = (crc // 2) ^ 3988292384
        else:
            crc = crc // 2
        bit = bit + 1
    return crc % 65536


def build_crc_table(size: int) -> list[int]:
    """Build a CRC lookup table of given size."""
    tbl: list[int] = []
    i: int = 0
    while i < size:
        entry: int = crc_table_entry(i)
        tbl.append(entry)
        i = i + 1
    return tbl


def crc_checksum(data: list[int]) -> int:
    """Compute CRC-like checksum over a list of byte values."""
    crc: int = 65535
    tbl: list[int] = build_crc_table(256)
    i: int = 0
    n: int = len(data)
    while i < n:
        val: int = data[i]
        idx: int = (crc ^ val) % 256
        tbl_val: int = tbl[idx]
        crc = (crc // 256) ^ tbl_val
        i = i + 1
    return crc % 65536


def crc_combine(crc_a: int, crc_b: int) -> int:
    """Combine two CRC values."""
    return (crc_a ^ crc_b) % 65536


def crc_update_byte(crc: int, byte_val: int) -> int:
    """Update CRC with a single byte."""
    entry: int = crc_table_entry((crc ^ byte_val) % 256)
    return ((crc // 256) ^ entry) % 65536


def test_module() -> int:
    """Test CRC functions."""
    passed: int = 0

    e0: int = crc_table_entry(0)
    if e0 == 0:
        passed = passed + 1

    e1: int = crc_table_entry(1)
    if e1 > 0:
        passed = passed + 1

    tbl: list[int] = build_crc_table(16)
    if len(tbl) == 16:
        passed = passed + 1

    c1: int = crc_checksum([1, 2, 3])
    c2: int = crc_checksum([1, 2, 3])
    if c1 == c2:
        passed = passed + 1

    c3: int = crc_checksum([4, 5, 6])
    if c3 != c1:
        passed = passed + 1

    cb: int = crc_combine(100, 200)
    if cb == (100 ^ 200):
        passed = passed + 1

    u1: int = crc_update_byte(0, 42)
    if u1 >= 0:
        passed = passed + 1

    return passed
