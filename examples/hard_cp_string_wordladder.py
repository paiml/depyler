# Generated by: depyler corpus generator
# Source: hard_cp_string_wordladder.py
#
# Word ladder (BFS on string transformations) for transpiler stress testing.


def differ_by_one(a: str, b: str) -> int:
    """Check if two equal-length strings differ by exactly one char. 1=yes, 0=no."""
    if len(a) != len(b):
        return 0
    diffs: int = 0
    i: int = 0
    while i < len(a):
        if a[i] != b[i]:
            diffs = diffs + 1
        i = i + 1
    if diffs == 1:
        return 1
    return 0


def word_ladder_length(begin_word: str, end_word: str, word_list: list[str]) -> int:
    """BFS word ladder. Returns min transformations + 1, or 0 if impossible."""
    n: int = len(word_list)
    if n == 0:
        return 0
    end_idx: int = 0 - 1
    i: int = 0
    while i < n:
        if word_list[i] == end_word:
            end_idx = i
        i = i + 1
    if end_idx == 0 - 1:
        return 0
    visited: list[int] = [0] * n
    queue: list[int] = []
    depth: list[int] = [0] * n
    bi: int = 0
    while bi < n:
        if differ_by_one(begin_word, word_list[bi]) == 1:
            queue.append(bi)
            visited[bi] = 1
            depth[bi] = 2
        bi = bi + 1
    qi: int = 0
    while qi < len(queue):
        curr: int = queue[qi]
        if curr == end_idx:
            return depth[curr]
        ni: int = 0
        while ni < n:
            if visited[ni] == 0 and differ_by_one(word_list[curr], word_list[ni]) == 1:
                visited[ni] = 1
                depth[ni] = depth[curr] + 1
                queue.append(ni)
            ni = ni + 1
        qi = qi + 1
    return 0


def min_edit_path_length(start: str, end: str, dictionary: list[str]) -> int:
    """Find shortest path from start to end through dictionary words."""
    if start == end:
        return 1
    return word_ladder_length(start, end, dictionary)


def count_reachable_words(begin_word: str, word_list: list[str]) -> int:
    """Count how many words are reachable from begin_word via single-char transforms."""
    n: int = len(word_list)
    if n == 0:
        return 0
    visited: list[int] = [0] * n
    queue: list[int] = []
    bi: int = 0
    while bi < n:
        if differ_by_one(begin_word, word_list[bi]) == 1:
            queue.append(bi)
            visited[bi] = 1
        bi = bi + 1
    qi: int = 0
    while qi < len(queue):
        curr: int = queue[qi]
        ni: int = 0
        while ni < n:
            if visited[ni] == 0 and differ_by_one(word_list[curr], word_list[ni]) == 1:
                visited[ni] = 1
                queue.append(ni)
            ni = ni + 1
        qi = qi + 1
    reachable: int = 0
    ri: int = 0
    while ri < n:
        reachable = reachable + visited[ri]
        ri = ri + 1
    return reachable


def test_module() -> int:
    passed: int = 0
    if differ_by_one("hit", "hot") == 1:
        passed = passed + 1
    if differ_by_one("hit", "abc") == 0:
        passed = passed + 1
    wl: list[str] = ["hot", "dot", "dog", "lot", "log", "cog"]
    result: int = word_ladder_length("hit", "cog", wl)
    if result == 5:
        passed = passed + 1
    wl2: list[str] = ["hot", "dot", "dog", "lot", "log"]
    if word_ladder_length("hit", "cog", wl2) == 0:
        passed = passed + 1
    if count_reachable_words("hit", wl) == 6:
        passed = passed + 1
    return passed
