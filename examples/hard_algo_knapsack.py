# Generated by: depyler corpus generator
# Source: hard_algo_knapsack.py
#
# 0/1 knapsack dynamic programming with variants.


def knapsack_01(weights: List[int], values: List[int], capacity: int) -> int:
    """Classic 0/1 knapsack: max value without exceeding capacity."""
    n: int = len(weights)
    dp: List[List[int]] = []
    r: int = 0
    while r <= n:
        row: List[int] = [0] * (capacity + 1)
        dp.append(row)
        r = r + 1
    i: int = 1
    while i <= n:
        w: int = weights[i - 1]
        v: int = values[i - 1]
        j: int = 0
        while j <= capacity:
            dp[i][j] = dp[i - 1][j]
            if w <= j:
                candidate: int = dp[i - 1][j - w] + v
                if candidate > dp[i][j]:
                    dp[i][j] = candidate
            j = j + 1
        i = i + 1
    return dp[n][capacity]


def knapsack_01_optimized(weights: List[int], values: List[int], capacity: int) -> int:
    """Space-optimized 0/1 knapsack using 1D array."""
    n: int = len(weights)
    dp: List[int] = [0] * (capacity + 1)
    i: int = 0
    while i < n:
        w: int = weights[i]
        v: int = values[i]
        j: int = capacity
        while j >= w:
            candidate: int = dp[j - w] + v
            if candidate > dp[j]:
                dp[j] = candidate
            j = j - 1
        i = i + 1
    return dp[capacity]


def knapsack_items(weights: List[int], values: List[int], capacity: int) -> List[int]:
    """Return indices of items selected in 0/1 knapsack."""
    n: int = len(weights)
    dp: List[List[int]] = []
    r: int = 0
    while r <= n:
        row: List[int] = [0] * (capacity + 1)
        dp.append(row)
        r = r + 1
    i: int = 1
    while i <= n:
        w: int = weights[i - 1]
        v: int = values[i - 1]
        j: int = 0
        while j <= capacity:
            dp[i][j] = dp[i - 1][j]
            if w <= j:
                candidate: int = dp[i - 1][j - w] + v
                if candidate > dp[i][j]:
                    dp[i][j] = candidate
            j = j + 1
        i = i + 1
    items: List[int] = []
    cap: int = capacity
    i = n
    while i > 0:
        if dp[i][cap] != dp[i - 1][cap]:
            items.append(i - 1)
            cap = cap - weights[i - 1]
        i = i - 1
    left: int = 0
    right: int = len(items) - 1
    while left < right:
        tmp: int = items[left]
        items[left] = items[right]
        items[right] = tmp
        left = left + 1
        right = right - 1
    return items


def unbounded_knapsack(weights: List[int], values: List[int], capacity: int) -> int:
    """Unbounded knapsack: items can be reused."""
    dp: List[int] = [0] * (capacity + 1)
    j: int = 1
    while j <= capacity:
        i: int = 0
        while i < len(weights):
            w: int = weights[i]
            v: int = values[i]
            if w <= j:
                candidate: int = dp[j - w] + v
                if candidate > dp[j]:
                    dp[j] = candidate
            i = i + 1
        j = j + 1
    return dp[capacity]


def test_module() -> int:
    """Test all knapsack functions."""
    passed: int = 0

    r1: int = knapsack_01([1, 3, 4, 5], [1, 4, 5, 7], 7)
    if r1 == 9:
        passed = passed + 1

    r2: int = knapsack_01_optimized([1, 3, 4, 5], [1, 4, 5, 7], 7)
    if r2 == 9:
        passed = passed + 1

    items: List[int] = knapsack_items([1, 3, 4, 5], [1, 4, 5, 7], 7)
    total_val: int = 0
    total_wt: int = 0
    wts: List[int] = [1, 3, 4, 5]
    vals: List[int] = [1, 4, 5, 7]
    k: int = 0
    while k < len(items):
        idx: int = items[k]
        total_val = total_val + vals[idx]
        total_wt = total_wt + wts[idx]
        k = k + 1
    if total_val == 9 and total_wt <= 7:
        passed = passed + 1

    r3: int = unbounded_knapsack([2, 3, 4], [3, 4, 5], 7)
    if r3 == 10:
        passed = passed + 1

    r4: int = knapsack_01([], [], 10)
    if r4 == 0:
        passed = passed + 1

    r5: int = knapsack_01([10], [100], 5)
    if r5 == 0:
        passed = passed + 1

    return passed
