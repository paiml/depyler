# Generated by: depyler corpus generator
# Source: hard_cp_ds_lru.py
#
# LRU cache operations (list-based simulation) for transpiler stress testing.


def lru_get(cache_keys: list[int], cache_vals: list[int], capacity: int, search_key: int) -> int:
    """Get value from LRU cache. Returns -1 if not found. Moves to front."""
    i: int = 0
    while i < len(cache_keys):
        if cache_keys[i] == search_key:
            val: int = cache_vals[i]
            k: int = i
            while k > 0:
                cache_keys[k] = cache_keys[k - 1]
                cache_vals[k] = cache_vals[k - 1]
                k = k - 1
            cache_keys[0] = search_key
            cache_vals[0] = val
            return val
        i = i + 1
    return 0 - 1


def lru_put(cache_keys: list[int], cache_vals: list[int], capacity: int, new_key: int, new_val: int) -> int:
    """Put key-value into LRU cache. Returns evicted key or -1."""
    i: int = 0
    while i < len(cache_keys):
        if cache_keys[i] == new_key:
            k: int = i
            while k > 0:
                cache_keys[k] = cache_keys[k - 1]
                cache_vals[k] = cache_vals[k - 1]
                k = k - 1
            cache_keys[0] = new_key
            cache_vals[0] = new_val
            return 0 - 1
        i = i + 1
    evicted: int = 0 - 1
    if len(cache_keys) >= capacity:
        evicted = cache_keys[len(cache_keys) - 1]
        cache_keys.pop()
        cache_vals.pop()
    j: int = len(cache_keys)
    while j > 0:
        j = j - 1
    new_keys: list[int] = [new_key]
    new_vals: list[int] = [new_val]
    m: int = 0
    while m < len(cache_keys):
        new_keys.append(cache_keys[m])
        new_vals.append(cache_vals[m])
        m = m + 1
    while len(cache_keys) > 0:
        cache_keys.pop()
        cache_vals.pop()
    n: int = 0
    while n < len(new_keys):
        cache_keys.append(new_keys[n])
        cache_vals.append(new_vals[n])
        n = n + 1
    return evicted


def lru_size(cache_keys: list[int]) -> int:
    """Return current size of LRU cache."""
    return len(cache_keys)


def test_module() -> int:
    passed: int = 0
    keys: list[int] = []
    vals: list[int] = []
    cap: int = 3
    lru_put(keys, vals, cap, 1, 10)
    lru_put(keys, vals, cap, 2, 20)
    lru_put(keys, vals, cap, 3, 30)
    if lru_get(keys, vals, cap, 2) == 20:
        passed = passed + 1
    if lru_size(keys) == 3:
        passed = passed + 1
    evicted: int = lru_put(keys, vals, cap, 4, 40)
    if evicted == 1:
        passed = passed + 1
    if lru_get(keys, vals, cap, 1) == 0 - 1:
        passed = passed + 1
    if lru_get(keys, vals, cap, 4) == 40:
        passed = passed + 1
    return passed
