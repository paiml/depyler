# Generated by: depyler corpus generator
# Source: hard_algo_binary_search.py
#
# Binary search variants: lower bound, upper bound, rotated array search.


def binary_search_basic(arr: List[int], target: int) -> int:
    """Standard binary search returning index or -1."""
    lo: int = 0
    hi: int = len(arr) - 1
    while lo <= hi:
        mid: int = (lo + hi) // 2
        val: int = arr[mid]
        if val == target:
            return mid
        elif val < target:
            lo = mid + 1
        else:
            hi = mid - 1
    return -1


def binary_search_lower(arr: List[int], target: int) -> int:
    """Find leftmost position where target could be inserted."""
    lo: int = 0
    hi: int = len(arr)
    while lo < hi:
        mid: int = (lo + hi) // 2
        val: int = arr[mid]
        if val < target:
            lo = mid + 1
        else:
            hi = mid
    return lo


def binary_search_upper(arr: List[int], target: int) -> int:
    """Find first position strictly greater than target."""
    lo: int = 0
    hi: int = len(arr)
    while lo < hi:
        mid: int = (lo + hi) // 2
        val: int = arr[mid]
        if val <= target:
            lo = mid + 1
        else:
            hi = mid
    return lo


def search_rotated_array(arr: List[int], target: int) -> int:
    """Search in a rotated sorted array."""
    lo: int = 0
    hi: int = len(arr) - 1
    while lo <= hi:
        mid: int = (lo + hi) // 2
        mid_val: int = arr[mid]
        if mid_val == target:
            return mid
        lo_val: int = arr[lo]
        hi_val: int = arr[hi]
        if lo_val <= mid_val:
            if lo_val <= target and target < mid_val:
                hi = mid - 1
            else:
                lo = mid + 1
        else:
            if mid_val < target and target <= hi_val:
                lo = mid + 1
            else:
                hi = mid - 1
    return -1


def find_rotation_point(arr: List[int]) -> int:
    """Find the index of the minimum element in a rotated sorted array."""
    n: int = len(arr)
    if n == 0:
        return -1
    lo: int = 0
    hi: int = n - 1
    while lo < hi:
        mid: int = (lo + hi) // 2
        mid_val: int = arr[mid]
        hi_val: int = arr[hi]
        if mid_val > hi_val:
            lo = mid + 1
        else:
            hi = mid
    return lo


def count_in_sorted(arr: List[int], target: int) -> int:
    """Count occurrences of target in sorted array using binary search."""
    left: int = binary_search_lower(arr, target)
    right: int = binary_search_upper(arr, target)
    return right - left


def test_module() -> int:
    """Test all binary search functions."""
    passed: int = 0

    r1: int = binary_search_basic([1, 3, 5, 7, 9], 5)
    if r1 == 2:
        passed = passed + 1

    r2: int = binary_search_basic([1, 3, 5, 7, 9], 6)
    if r2 == -1:
        passed = passed + 1

    r3: int = binary_search_lower([1, 2, 4, 4, 4, 7], 4)
    if r3 == 2:
        passed = passed + 1

    r4: int = binary_search_upper([1, 2, 4, 4, 4, 7], 4)
    if r4 == 5:
        passed = passed + 1

    r5: int = search_rotated_array([4, 5, 6, 7, 0, 1, 2], 0)
    if r5 == 4:
        passed = passed + 1

    r6: int = search_rotated_array([4, 5, 6, 7, 0, 1, 2], 3)
    if r6 == -1:
        passed = passed + 1

    r7: int = find_rotation_point([4, 5, 6, 7, 0, 1, 2])
    if r7 == 4:
        passed = passed + 1

    r8: int = count_in_sorted([1, 2, 2, 2, 3, 4], 2)
    if r8 == 3:
        passed = passed + 1

    return passed
