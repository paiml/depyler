# Generated by: depyler corpus generator
# Source: hard_adv_opt_hill.py
#
# Hill climbing variants with restarts and steepest ascent.


def objective_1d(x_val: int) -> int:
    """Objective function: -(x-5)^2 + 100 (peak at x=5)."""
    diff: int = x_val - 5
    return 100 - diff * diff


def neighbors_1d(x_val: int, step: int) -> list[int]:
    """Generate 1D neighbors: x-step and x+step."""
    result: list[int] = []
    result.append(x_val - step)
    result.append(x_val + step)
    return result


def hill_climb_1d(start: int, step: int, max_iter: int) -> int:
    """Basic hill climbing in 1D."""
    current: int = start
    current_val: int = objective_1d(current)
    i: int = 0
    while i < max_iter:
        nbrs: list[int] = neighbors_1d(current, step)
        best_nbr: int = current
        best_val: int = current_val
        j: int = 0
        while j < 2:
            nbr: int = nbrs[j]
            nval: int = objective_1d(nbr)
            if nval > best_val:
                best_nbr = nbr
                best_val = nval
            j = j + 1
        if best_nbr == current:
            return current
        current = best_nbr
        current_val = best_val
        i = i + 1
    return current


def hill_climb_restarts(starts: list[int], step: int, max_iter: int) -> int:
    """Hill climbing with multiple random restarts."""
    best_x: int = starts[0]
    best_val: int = objective_1d(best_x)
    i: int = 0
    n: int = len(starts)
    while i < n:
        s: int = starts[i]
        result: int = hill_climb_1d(s, step, max_iter)
        rval: int = objective_1d(result)
        if rval > best_val:
            best_val = rval
            best_x = result
        i = i + 1
    return best_x


def steepest_ascent_2d(x_start: int, y_start: int, max_iter: int) -> tuple[int, int]:
    """Steepest ascent hill climbing on f(x,y) = -(x-3)^2 - (y-4)^2."""
    x_cur: int = x_start
    y_cur: int = y_start
    i: int = 0
    while i < max_iter:
        cur_val: int = 0 - (x_cur - 3) * (x_cur - 3) - (y_cur - 4) * (y_cur - 4)
        best_x: int = x_cur
        best_y: int = y_cur
        best_val: int = cur_val
        dx: int = -1
        while dx <= 1:
            dy: int = -1
            while dy <= 1:
                if dx != 0 or dy != 0:
                    nx: int = x_cur + dx
                    ny: int = y_cur + dy
                    nval: int = 0 - (nx - 3) * (nx - 3) - (ny - 4) * (ny - 4)
                    if nval > best_val:
                        best_x = nx
                        best_y = ny
                        best_val = nval
                dy = dy + 1
            dx = dx + 1
        if best_x == x_cur and best_y == y_cur:
            return (x_cur, y_cur)
        x_cur = best_x
        y_cur = best_y
        i = i + 1
    return (x_cur, y_cur)


def test_module() -> int:
    """Test hill climbing functions."""
    passed: int = 0

    obj_at_5: int = objective_1d(5)
    if obj_at_5 == 100:
        passed = passed + 1

    obj_at_0: int = objective_1d(0)
    if obj_at_0 == 75:
        passed = passed + 1

    nbrs: list[int] = neighbors_1d(5, 1)
    if len(nbrs) == 2:
        passed = passed + 1

    result: int = hill_climb_1d(0, 1, 50)
    if result == 5:
        passed = passed + 1

    best: int = hill_climb_restarts([0, 10, -5, 20], 1, 50)
    if best == 5:
        passed = passed + 1

    xy: tuple[int, int] = steepest_ascent_2d(0, 0, 50)
    rx: int = xy[0]
    ry: int = xy[1]
    if rx == 3 and ry == 4:
        passed = passed + 1

    return passed
