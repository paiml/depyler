# Generated by: depyler corpus generator
# Source: hard_cp_dp_rodcut.py
#
# Rod cutting and related DP for transpiler stress testing.


def rod_cutting_max(prices: list[int], rod_len: int) -> int:
    """Maximum revenue from cutting a rod of given length."""
    dp: list[int] = [0] * (rod_len + 1)
    i: int = 1
    while i <= rod_len:
        j: int = 0
        while j < len(prices):
            piece_len: int = j + 1
            if piece_len <= i:
                cand: int = dp[i - piece_len] + prices[j]
                if cand > dp[i]:
                    dp[i] = cand
            j = j + 1
        i = i + 1
    return dp[rod_len]


def rod_cutting_min_cost(costs: list[int], rod_len: int) -> int:
    """Minimum cost to cut rod into unit pieces. costs[i] = cost of piece i+1."""
    big: int = 999999999
    dp: list[int] = [big] * (rod_len + 1)
    dp[0] = 0
    dp[1] = 0
    i: int = 2
    while i <= rod_len:
        k: int = 1
        while k < i:
            cand: int = dp[k] + dp[i - k] + i
            if cand < dp[i]:
                dp[i] = cand
            k = k + 1
        i = i + 1
    return dp[rod_len]


def rod_cutting_count_ways(prices: list[int], rod_len: int) -> int:
    """Count ways to cut rod such that total price equals maximum."""
    max_val: int = rod_cutting_max(prices, rod_len)
    n: int = len(prices)
    dp: list[list[int]] = []
    r: int = 0
    while r <= rod_len:
        row: list[int] = [0] * (max_val + 1)
        dp.append(row)
        r = r + 1
    dp[0][0] = 1
    i: int = 0
    while i < n:
        piece_len: int = i + 1
        piece_val: int = prices[i]
        j: int = piece_len
        while j <= rod_len:
            v: int = piece_val
            while v <= max_val:
                dp[j][v] = dp[j][v] + dp[j - piece_len][v - piece_val]
                v = v + 1
            j = j + 1
        i = i + 1
    return dp[rod_len][max_val]


def palindrome_min_cuts(s: str) -> int:
    """Minimum cuts to partition string into palindromes."""
    n: int = len(s)
    if n <= 1:
        return 0
    is_pal: list[list[bool]] = []
    r: int = 0
    while r < n:
        row: list[bool] = [False] * n
        is_pal.append(row)
        is_pal[r][r] = True
        r = r + 1
    length: int = 2
    while length <= n:
        start: int = 0
        while start <= n - length:
            end: int = start + length - 1
            if s[start] == s[end]:
                if length == 2:
                    is_pal[start][end] = True
                else:
                    is_pal[start][end] = is_pal[start + 1][end - 1]
            start = start + 1
        length = length + 1
    cuts: list[int] = [0] * n
    i: int = 0
    while i < n:
        if is_pal[0][i]:
            cuts[i] = 0
        else:
            cuts[i] = i
            j: int = 1
            while j <= i:
                if is_pal[j][i]:
                    cand: int = cuts[j - 1] + 1
                    if cand < cuts[i]:
                        cuts[i] = cand
                j = j + 1
        i = i + 1
    return cuts[n - 1]


def test_module() -> int:
    passed: int = 0
    if rod_cutting_max([1, 5, 8, 9, 10, 17, 17, 20], 8) == 22:
        passed = passed + 1
    if rod_cutting_max([3, 5, 8, 9, 10, 17, 17, 20], 4) == 12:
        passed = passed + 1
    if rod_cutting_min_cost([], 4) == 4:
        passed = passed + 1
    if palindrome_min_cuts("aab") == 1:
        passed = passed + 1
    if palindrome_min_cuts("a") == 0:
        passed = passed + 1
    if rod_cutting_max([], 0) == 0:
        passed = passed + 1
    return passed
