# Generated by: depyler corpus generator
# Source: hard_algo_bit_manipulation.py
#
# Bit manipulation tricks: count bits, power of 2, XOR puzzles, etc.


def count_set_bits(num: int) -> int:
    """Count number of 1-bits in binary representation (popcount)."""
    count: int = 0
    val: int = num
    while val > 0:
        count = count + (val & 1)
        val = val >> 1
    return count


def is_power_of_two(num: int) -> int:
    """Check if number is a power of 2. Returns 1 if yes, 0 if no."""
    if num <= 0:
        return 0
    if (num & (num - 1)) == 0:
        return 1
    return 0


def highest_set_bit(num: int) -> int:
    """Find position of highest set bit (0-indexed). Returns -1 for 0."""
    if num == 0:
        return -1
    pos: int = 0
    val: int = num
    while val > 1:
        val = val >> 1
        pos = pos + 1
    return pos


def lowest_set_bit(num: int) -> int:
    """Find position of lowest set bit (0-indexed). Returns -1 for 0."""
    if num == 0:
        return -1
    pos: int = 0
    val: int = num
    while (val & 1) == 0:
        val = val >> 1
        pos = pos + 1
    return pos


def single_number(arr: List[int]) -> int:
    """Find the single number where every other appears twice (XOR trick)."""
    result: int = 0
    i: int = 0
    while i < len(arr):
        result = result ^ arr[i]
        i = i + 1
    return result


def reverse_bits(num: int, width: int) -> int:
    """Reverse the bits of a number within given bit width."""
    result: int = 0
    val: int = num
    i: int = 0
    while i < width:
        result = (result << 1) | (val & 1)
        val = val >> 1
        i = i + 1
    return result


def hamming_weight(a: int, b: int) -> int:
    """Count number of positions where bits differ (Hamming distance)."""
    xor_val: int = a ^ b
    return count_set_bits(xor_val)


def next_power_of_two(num: int) -> int:
    """Find the next power of 2 >= num."""
    if num <= 1:
        return 1
    val: int = num - 1
    val = val | (val >> 1)
    val = val | (val >> 2)
    val = val | (val >> 4)
    val = val | (val >> 8)
    val = val | (val >> 16)
    return val + 1


def count_bits_range(n: int) -> List[int]:
    """Count bits for each number 0 to n."""
    result: List[int] = []
    i: int = 0
    while i <= n:
        result.append(count_set_bits(i))
        i = i + 1
    return result


def test_module() -> int:
    """Test all bit manipulation functions."""
    passed: int = 0

    r1: int = count_set_bits(11)
    if r1 == 3:
        passed = passed + 1

    r2: int = is_power_of_two(16)
    if r2 == 1:
        passed = passed + 1

    r3: int = is_power_of_two(15)
    if r3 == 0:
        passed = passed + 1

    r4: int = highest_set_bit(10)
    if r4 == 3:
        passed = passed + 1

    r5: int = lowest_set_bit(12)
    if r5 == 2:
        passed = passed + 1

    r6: int = single_number([4, 1, 2, 1, 2])
    if r6 == 4:
        passed = passed + 1

    r7: int = reverse_bits(5, 4)
    if r7 == 10:
        passed = passed + 1

    r8: int = hamming_weight(1, 4)
    if r8 == 2:
        passed = passed + 1

    r9: int = next_power_of_two(5)
    if r9 == 8:
        passed = passed + 1

    r10: List[int] = count_bits_range(4)
    if r10 == [0, 1, 1, 2, 1]:
        passed = passed + 1

    return passed
