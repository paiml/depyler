# Generated by: depyler corpus generator
# Source: hard_algo_dijkstra.py
#
# Simplified Dijkstra shortest path using adjacency list.


def dijkstra_shortest(num_nodes: int, edges: List[List[int]], source: int) -> List[int]:
    """Dijkstra shortest path. edges[i] = [from, to, weight]. Returns dist array."""
    big: int = 999999999
    dist: List[int] = []
    visited: List[int] = []
    i: int = 0
    while i < num_nodes:
        dist.append(big)
        visited.append(0)
        i = i + 1
    dist[source] = 0
    adj_from: List[List[int]] = []
    adj_to: List[List[int]] = []
    adj_wt: List[List[int]] = []
    i = 0
    while i < num_nodes:
        adj_from.append([])
        adj_to.append([])
        adj_wt.append([])
        i = i + 1
    e: int = 0
    while e < len(edges):
        edge: List[int] = edges[e]
        src: int = edge[0]
        dst: int = edge[1]
        wt: int = edge[2]
        adj_to[src].append(dst)
        adj_wt[src].append(wt)
        e = e + 1
    step: int = 0
    while step < num_nodes:
        u: int = -1
        u_dist: int = big
        j: int = 0
        while j < num_nodes:
            if visited[j] == 0 and dist[j] < u_dist:
                u = j
                u_dist = dist[j]
            j = j + 1
        if u == -1:
            step = num_nodes
        else:
            visited[u] = 1
            neighbors: List[int] = adj_to[u]
            weights: List[int] = adj_wt[u]
            ni: int = 0
            while ni < len(neighbors):
                nb: int = neighbors[ni]
                w: int = weights[ni]
                candidate: int = dist[u] + w
                if candidate < dist[nb]:
                    dist[nb] = candidate
                ni = ni + 1
            step = step + 1
    return dist


def shortest_path_between(num_nodes: int, edges: List[List[int]], source: int, target: int) -> int:
    """Return shortest distance between source and target. -1 if unreachable."""
    dist: List[int] = dijkstra_shortest(num_nodes, edges, source)
    result: int = dist[target]
    if result >= 999999999:
        return -1
    return result


def all_reachable(num_nodes: int, edges: List[List[int]], source: int) -> int:
    """Count number of nodes reachable from source."""
    dist: List[int] = dijkstra_shortest(num_nodes, edges, source)
    count: int = 0
    i: int = 0
    while i < num_nodes:
        if dist[i] < 999999999:
            count = count + 1
        i = i + 1
    return count


def test_module() -> int:
    """Test all Dijkstra functions."""
    passed: int = 0

    edges: List[List[int]] = [
        [0, 1, 4],
        [0, 2, 1],
        [2, 1, 2],
        [1, 3, 1],
        [2, 3, 5]
    ]
    dist: List[int] = dijkstra_shortest(4, edges, 0)
    if dist[0] == 0:
        passed = passed + 1
    if dist[1] == 3:
        passed = passed + 1
    if dist[2] == 1:
        passed = passed + 1
    if dist[3] == 4:
        passed = passed + 1

    r1: int = shortest_path_between(4, edges, 0, 3)
    if r1 == 4:
        passed = passed + 1

    r2: int = all_reachable(4, edges, 0)
    if r2 == 4:
        passed = passed + 1

    r3: int = shortest_path_between(4, edges, 3, 0)
    if r3 == -1:
        passed = passed + 1

    return passed
