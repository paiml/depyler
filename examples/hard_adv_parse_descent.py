# Generated by: depyler corpus generator
# Source: hard_adv_parse_descent.py
#
# Recursive descent parser for balanced parentheses and nested structures.
# Encoded: 40='(', 41=')', 91='[', 93=']', 123='{', 125='}'


def is_open(ch: int) -> int:
    """Check if character is an opening bracket."""
    if ch == 40 or ch == 91 or ch == 123:
        return 1
    return 0


def is_close(ch: int) -> int:
    """Check if character is a closing bracket."""
    if ch == 41 or ch == 93 or ch == 125:
        return 1
    return 0


def matching_close(open_ch: int) -> int:
    """Return the matching close bracket for an open bracket."""
    if open_ch == 40:
        return 41
    if open_ch == 91:
        return 93
    if open_ch == 123:
        return 125
    return -1


def validate_balanced(chars: list[int]) -> int:
    """Validate that brackets are balanced. Returns 1 if valid, 0 if not."""
    stack: list[int] = []
    i: int = 0
    n: int = len(chars)
    while i < n:
        ch: int = chars[i]
        op: int = is_open(ch)
        cl: int = is_close(ch)
        if op == 1:
            stack.append(ch)
        elif cl == 1:
            if len(stack) == 0:
                return 0
            top: int = stack[len(stack) - 1]
            expected: int = matching_close(top)
            if ch != expected:
                return 0
            stack.pop()
        i = i + 1
    if len(stack) == 0:
        return 1
    return 0


def max_nesting_depth(chars: list[int]) -> int:
    """Find maximum nesting depth of brackets."""
    depth: int = 0
    max_d: int = 0
    i: int = 0
    n: int = len(chars)
    while i < n:
        ch: int = chars[i]
        op: int = is_open(ch)
        cl: int = is_close(ch)
        if op == 1:
            depth = depth + 1
            if depth > max_d:
                max_d = depth
        elif cl == 1:
            depth = depth - 1
        i = i + 1
    return max_d


def count_pairs(chars: list[int]) -> int:
    """Count the number of bracket pairs."""
    cnt: int = 0
    i: int = 0
    n: int = len(chars)
    while i < n:
        ch: int = chars[i]
        op: int = is_open(ch)
        if op == 1:
            cnt = cnt + 1
        i = i + 1
    return cnt


def test_module() -> int:
    """Test recursive descent parser."""
    passed: int = 0

    v1: int = validate_balanced([40, 41])
    if v1 == 1:
        passed = passed + 1

    v2: int = validate_balanced([40, 91, 93, 41])
    if v2 == 1:
        passed = passed + 1

    v3: int = validate_balanced([40, 91, 41, 93])
    if v3 == 0:
        passed = passed + 1

    d1: int = max_nesting_depth([40, 40, 41, 41])
    if d1 == 2:
        passed = passed + 1

    d2: int = max_nesting_depth([40, 41, 40, 41])
    if d2 == 1:
        passed = passed + 1

    cp: int = count_pairs([40, 91, 123, 125, 93, 41])
    if cp == 3:
        passed = passed + 1

    return passed
