# Generated by: depyler corpus generator
# Source: hard_adv_opt_anneal.py
#
# Simulated annealing for combinatorial optimization.


def energy_function(state: list[int]) -> int:
    """Compute energy: sum of absolute differences between consecutive elements."""
    total: int = 0
    i: int = 0
    n: int = len(state) - 1
    while i < n:
        a: int = state[i]
        b: int = state[i + 1]
        diff: int = a - b
        if diff < 0:
            diff = 0 - diff
        total = total + diff
        i = i + 1
    return total


def pseudo_random(seed: int) -> int:
    """Linear congruential generator for deterministic pseudo-randomness."""
    return (seed * 1103515245 + 12345) % 2147483648


def neighbor_swap(state: list[int], idx_a: int, idx_b: int) -> list[int]:
    """Swap two elements in state to generate a neighbor."""
    result: list[int] = []
    i: int = 0
    n: int = len(state)
    while i < n:
        val: int = state[i]
        if i == idx_a:
            val = state[idx_b]
        elif i == idx_b:
            val = state[idx_a]
        result.append(val)
        i = i + 1
    return result


def simulated_annealing(state: list[int], max_iter: int, initial_temp: int) -> list[int]:
    """Run simulated annealing to minimize energy."""
    current: list[int] = []
    i: int = 0
    n: int = len(state)
    while i < n:
        v: int = state[i]
        current.append(v)
        i = i + 1
    best_energy: int = energy_function(current)
    rng: int = 42
    iteration: int = 0
    while iteration < max_iter:
        rng = pseudo_random(rng)
        idx_a: int = (rng % n)
        rng = pseudo_random(rng)
        idx_b: int = (rng % n)
        if idx_a != idx_b:
            candidate: list[int] = neighbor_swap(current, idx_a, idx_b)
            new_energy: int = energy_function(candidate)
            if new_energy <= best_energy:
                current = candidate
                best_energy = new_energy
            else:
                temp: int = initial_temp - (initial_temp * iteration) // max_iter
                if temp > 0:
                    delta: int = new_energy - best_energy
                    threshold: int = temp * 100 // initial_temp
                    rng = pseudo_random(rng)
                    roll: int = rng % 100
                    if roll < threshold and delta < temp:
                        current = candidate
                        best_energy = new_energy
        iteration = iteration + 1
    return current


def is_sorted(arr: list[int]) -> int:
    """Check if array is sorted. Returns 1 if sorted, 0 otherwise."""
    i: int = 0
    n: int = len(arr) - 1
    while i < n:
        a: int = arr[i]
        b: int = arr[i + 1]
        if a > b:
            return 0
        i = i + 1
    return 1


def test_module() -> int:
    """Test simulated annealing functions."""
    passed: int = 0

    e1: int = energy_function([1, 2, 3, 4])
    if e1 == 3:
        passed = passed + 1

    e2: int = energy_function([4, 1, 3, 2])
    if e2 > 3:
        passed = passed + 1

    r1: int = pseudo_random(42)
    r2: int = pseudo_random(42)
    if r1 == r2:
        passed = passed + 1

    swapped: list[int] = neighbor_swap([10, 20, 30], 0, 2)
    sv0: int = swapped[0]
    sv2: int = swapped[2]
    if sv0 == 30 and sv2 == 10:
        passed = passed + 1

    initial: list[int] = [5, 3, 1, 4, 2]
    result: list[int] = simulated_annealing(initial, 200, 100)
    e_init: int = energy_function(initial)
    e_final: int = energy_function(result)
    if e_final <= e_init:
        passed = passed + 1

    s1: int = is_sorted([1, 2, 3])
    if s1 == 1:
        passed = passed + 1

    return passed
