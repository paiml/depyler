# Generated by: depyler corpus generator
# Source: hard_cp_string_subsearch.py
#
# Substring search variants for transpiler stress testing.


def naive_search(text: str, pat: str) -> int:
    """Naive O(nm) substring search. Returns first position or -1."""
    n: int = len(text)
    m: int = len(pat)
    if m == 0 or m > n:
        return 0 - 1
    i: int = 0
    while i <= n - m:
        matched: int = 1
        j: int = 0
        while j < m:
            if text[i + j] != pat[j]:
                matched = 0
                j = m
            j = j + 1
        if matched == 1:
            return i
        i = i + 1
    return 0 - 1


def search_all_positions(text: str, pat: str) -> list[int]:
    """Find all positions of pattern in text."""
    result: list[int] = []
    n: int = len(text)
    m: int = len(pat)
    if m == 0 or m > n:
        return result
    i: int = 0
    while i <= n - m:
        matched: int = 1
        j: int = 0
        while j < m:
            if text[i + j] != pat[j]:
                matched = 0
                j = m
            j = j + 1
        if matched == 1:
            result.append(i)
        i = i + 1
    return result


def longest_repeated_substring_len(s: str) -> int:
    """Find length of longest repeated substring using brute force."""
    n: int = len(s)
    best: int = 0
    sub_len: int = 1
    while sub_len < n:
        i: int = 0
        while i <= n - sub_len:
            j: int = i + 1
            while j <= n - sub_len:
                matched: int = 1
                k: int = 0
                while k < sub_len:
                    if s[i + k] != s[j + k]:
                        matched = 0
                        k = sub_len
                    k = k + 1
                if matched == 1:
                    if sub_len > best:
                        best = sub_len
                    j = n
                j = j + 1
            i = i + 1
        sub_len = sub_len + 1
    return best


def count_spaces(s: str) -> int:
    """Count space-separated words in string."""
    if len(s) == 0:
        return 0
    count: int = 1
    i: int = 0
    while i < len(s):
        if s[i] == " ":
            count = count + 1
        i = i + 1
    return count


def reverse_string(s: str) -> str:
    """Reverse a string."""
    result: str = ""
    i: int = len(s) - 1
    while i >= 0:
        result = result + s[i]
        i = i - 1
    return result


def test_module() -> int:
    passed: int = 0
    if naive_search("hello world", "world") == 6:
        passed = passed + 1
    if naive_search("abc", "xyz") == 0 - 1:
        passed = passed + 1
    positions: list[int] = search_all_positions("abcabc", "abc")
    if len(positions) == 2:
        passed = passed + 1
    if longest_repeated_substring_len("banana") == 3:
        passed = passed + 1
    if count_spaces("a b c d") == 4:
        passed = passed + 1
    if reverse_string("hello") == "olleh":
        passed = passed + 1
    return passed
