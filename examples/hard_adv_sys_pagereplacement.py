# Generated by: depyler corpus generator
# Source: hard_adv_sys_pagereplacement.py
#
# Page replacement algorithms: FIFO, LRU (clock-based approximation), optimal.


def fifo_page_faults(pages: list[int], frame_count: int) -> int:
    """Count page faults using FIFO replacement."""
    frames: list[int] = []
    faults: int = 0
    next_replace: int = 0
    i: int = 0
    n: int = len(pages)
    while i < n:
        pg: int = pages[i]
        found: int = 0
        j: int = 0
        while j < len(frames):
            fv: int = frames[j]
            if fv == pg:
                found = 1
            j = j + 1
        if found == 0:
            faults = faults + 1
            if len(frames) < frame_count:
                frames.append(pg)
            else:
                frames[next_replace] = pg
                next_replace = (next_replace + 1) % frame_count
        i = i + 1
    return faults


def lru_page_faults(pages: list[int], frame_count: int) -> int:
    """Count page faults using LRU replacement (uses access times)."""
    frames: list[int] = []
    access_time: list[int] = []
    faults: int = 0
    i: int = 0
    n: int = len(pages)
    while i < n:
        pg: int = pages[i]
        found: int = -1
        j: int = 0
        while j < len(frames):
            fv: int = frames[j]
            if fv == pg:
                found = j
            j = j + 1
        if found >= 0:
            access_time[found] = i
        else:
            faults = faults + 1
            if len(frames) < frame_count:
                frames.append(pg)
                access_time.append(i)
            else:
                lru_idx: int = 0
                lru_time: int = access_time[0]
                k: int = 1
                while k < len(frames):
                    at: int = access_time[k]
                    if at < lru_time:
                        lru_time = at
                        lru_idx = k
                    k = k + 1
                frames[lru_idx] = pg
                access_time[lru_idx] = i
        i = i + 1
    return faults


def optimal_page_faults(pages: list[int], frame_count: int) -> int:
    """Count page faults using optimal (Belady's) replacement."""
    frames: list[int] = []
    faults: int = 0
    i: int = 0
    n: int = len(pages)
    while i < n:
        pg: int = pages[i]
        found: int = 0
        j: int = 0
        while j < len(frames):
            fv: int = frames[j]
            if fv == pg:
                found = 1
            j = j + 1
        if found == 0:
            faults = faults + 1
            if len(frames) < frame_count:
                frames.append(pg)
            else:
                farthest: int = -1
                evict_idx: int = 0
                k: int = 0
                while k < len(frames):
                    frame_pg: int = frames[k]
                    next_use: int = n + 1
                    m: int = i + 1
                    while m < n:
                        pv: int = pages[m]
                        if pv == frame_pg:
                            next_use = m
                            m = n
                        m = m + 1
                    if next_use > farthest:
                        farthest = next_use
                        evict_idx = k
                    k = k + 1
                frames[evict_idx] = pg
        i = i + 1
    return faults


def test_module() -> int:
    """Test page replacement algorithms."""
    passed: int = 0

    seq: list[int] = [1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5]

    f_fifo: int = fifo_page_faults(seq, 3)
    if f_fifo > 0:
        passed = passed + 1

    f_lru: int = lru_page_faults(seq, 3)
    if f_lru > 0:
        passed = passed + 1

    f_opt: int = optimal_page_faults(seq, 3)
    if f_opt > 0:
        passed = passed + 1

    if f_opt <= f_fifo:
        passed = passed + 1

    f_all: int = fifo_page_faults([1, 2, 3], 3)
    if f_all == 3:
        passed = passed + 1

    f_hit: int = fifo_page_faults([1, 1, 1], 1)
    if f_hit == 1:
        passed = passed + 1

    return passed
