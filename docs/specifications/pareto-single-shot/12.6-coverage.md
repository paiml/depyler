# 12.6 Code Coverage Protocol (DEPYLER-COVERAGE-001)

[← Back to TOC](../pareto-complete-single-shot.md)

---

## Objective

Achieve and maintain **95% solidified coverage** on depyler-core:
- Line coverage via **property-based tests** (not just unit tests)
- Validated via **mutation testing** (tests must kill mutants)
- Execution time under 3 minutes for fast feedback

**Solidified = Property Tested + Mutation Validated**

---

## Acceptance Criteria

| ID | Criterion | Threshold | Validation |
|----|-----------|-----------|------------|
| **COV-1** | Line coverage | ≥95% | `cargo llvm-cov` |
| **COV-2** | Function coverage | ≥95% | `cargo llvm-cov` |
| **COV-3** | Mutation score | ≥80% | `cargo mutants` |
| **COV-4** | Property test coverage | ≥90% of covered lines | proptest/quickcheck |
| **COV-5** | Fast coverage time | <3 min | `make coverage` |
| **COV-6** | Full mutation time | <30 min | `make mutants` |
| **COV-7** | Coverage regression | 0% tolerance | CI gate |

---

## Solidified Coverage Principle

**Line coverage alone is insufficient.** A line can be "covered" by a test that doesn't assert anything meaningful.

```
WEAK (line coverage only):
  fn add(a: i32, b: i32) -> i32 { a + b }
  #[test] fn test_add() { add(1, 2); }  // Covers line, proves nothing

SOLIDIFIED (property + mutation):
  #[test] fn prop_add_commutative(a: i32, b: i32) {
      prop_assert_eq!(add(a, b), add(b, a));  // Property: commutativity
  }
  // Mutation: if `a + b` mutates to `a - b`, test MUST fail
```

**Mutation testing validates test quality**: If a mutant survives, the test suite is weak.

---

## Property Testing Strategy

Every public function MUST have property tests that verify **invariants**, not just examples:

| Property Type | Example | Use When |
|---------------|---------|----------|
| **Roundtrip** | `parse(generate(x)) == x` | Serialization, codegen |
| **Idempotent** | `f(f(x)) == f(x)` | Normalization, formatting |
| **Commutative** | `f(a, b) == f(b, a)` | Binary operations |
| **Associative** | `f(f(a, b), c) == f(a, f(b, c))` | Folding operations |
| **Identity** | `f(x, identity) == x` | Default values |
| **Inverse** | `f(g(x)) == x` | Encode/decode pairs |

```rust
// Example: Property test for type inference
proptest! {
    #[test]
    fn prop_type_inference_deterministic(python_code in valid_python()) {
        let result1 = infer_types(&python_code);
        let result2 = infer_types(&python_code);
        prop_assert_eq!(result1, result2, "Type inference must be deterministic");
    }

    #[test]
    fn prop_transpile_roundtrip(python_code in annotated_python()) {
        let rust = transpile(&python_code)?;
        prop_assert!(rust_compiles(&rust), "Generated Rust must compile");
    }
}
```

---

## Mutation Testing Validation

After achieving line coverage, validate with `cargo mutants`:

```bash
# Quick mutation check (changed files only)
cargo mutants --in-diff HEAD~1 -j4

# Full mutation testing (CI/nightly)
cargo mutants -p depyler-core --timeout 60 -j4
```

**Target: 80% mutation score** (80% of mutants killed by tests)

Surviving mutants indicate:
1. Missing assertions in tests
2. Untested edge cases
3. Dead code that should be removed

---

## Fast Coverage Architecture

Two-phase approach optimized for speed:

```
Phase 1: Instrumented Test Execution (Parallel)
┌─────────────────────────────────────────────────────────┐
│  cargo llvm-cov --no-report -p depyler-core --lib      │
│  PROPTEST_CASES=50 QUICKCHECK_TESTS=50                 │
│  Time: ~40 seconds                                     │
└─────────────────────────────────────────────────────────┘
                         ↓
Phase 2: Report Generation (No Retest)
┌─────────────────────────────────────────────────────────┐
│  cargo llvm-cov report --html --lcov                   │
│  Time: ~10 seconds                                     │
└─────────────────────────────────────────────────────────┘
```

---

## Property Test Configuration

| Mode | PROPTEST_CASES | Use Case |
|------|----------------|----------|
| **Coverage** | 50 | `make coverage` |
| **CI** | 100 | PR validation |
| **Full** | 256 | `make test` |
| **Exhaustive** | 1000 | Pre-release |

---

## Makefile Targets

```makefile
coverage:       # Fast (<1 min) - depyler-core only
coverage-full:  # Full (<10 min) - workspace with nextest
coverage-ci:    # CI mode - LCOV output
coverage-check: # Threshold gate (95%)
```

---

## Dependencies

| Tool | Install |
|------|---------|
| cargo-llvm-cov | `cargo install cargo-llvm-cov` |
| cargo-nextest | `cargo install cargo-nextest` |

---

## CI Enforcement

```yaml
- name: Coverage Gate
  run: |
    make coverage-ci
    COVERAGE=$(cargo llvm-cov report --summary-only | grep TOTAL | awk '{print $4}')
    [ "${COVERAGE%\%}" -ge 95 ] || exit 1
```
