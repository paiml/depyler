# 1.0 Single-Shot Compile Specification: The Unified Standard

**Version**: 1.99.0 (DEPYLER-1322: Popperian Epistemic Health Metrics)
**Date**: 2026-01-25
**Status**: **ACTIVE IMPLEMENTATION**
**Authors**: Depyler Team
**Based On**:
- `pareto-complete-single-shot.md` (Strategy)
- `root-cause-single-shot-compile.md` (Architecture Status)
- `nasa-single-shot-compile.md` (Safety Standards)
- `single-shot-compile-spec.md` (User Experience)

---

## 1. Executive Summary

### Vision
Enable Python developers to compile **ANY** Python script to a highly optimized, type-safe Rust binary with a single command. The system must operate without manual intervention, achieving "NASA-grade" reliability through rigorous type inference and semantic verification.

```bash
# The Promise
depyler compile my_script.py --release
# Result: ./my_script (native binary, 10-50x faster)
```

### Current Status (Jan 2026)
The project has surged to **39.3%** compilation success, validating the resolution of the **Dict Key Paradox**. The Unification Treaty delivered a +10.3pp improvement, bringing us within 0.7pp of the 40% barrier.
*   **Compile Rate**: **39.3%** (70/178 files).
*   **DEPYLER-1320**: COMPLETE â€” **Dict Unification**. Resolved the type system civil war. **Result: +10.3pp improvement.**
*   **Current Blockers**:
    *   **E0308 Remnants** (67 errors): Likely nested dict access and cross-function propagation.
    *   **E0599 Gaps** (49 errors): Missing methods on generated types.
    *   **E0282 Inference** (37 errors): Missing explicit type annotations.

---

## 2. Milestones & Evolution Loop

### Phase 6d: THE FINAL PUSH (ACTIVE)
**Objective**: Cross the 40% threshold and aim for 50% by targeting the specific patterns in the remaining 67 E0308 errors.

| Task | Status | Target | Result |
|------|--------|--------|--------|
| **Pattern Autopsy** | ðŸ“‹ Planned | Oracle Analysis | Identify E0308 root causes |
| **Nested Dicts** | ðŸ“‹ Planned | Intermediate vars | Fix type propagation |
| **Method Stubs** | ðŸ“‹ Planned | E0599 gaps | Generate missing impls |


---

## 2. Milestones & Evolution Loop

### Phase 5: Graph-Guided Convergence (ACTIVE)
**Objective**: Achieve >40% compile rate by auto-fixing "Patient Zero" nodes using Oracle v2.0.

| Task | Status | Target | Result |
|------|--------|--------|--------|
| **Convergence Strike** | ðŸ”„ **In Progress** | Fix 20+ Zeros | Executing `converge --auto-fix` |
| **ROI Verification** | ðŸ“‹ Planned | >80% fix acceptance | Tracking via `oracle_roi_metrics.json` |
| **Success Rate Delta** | ðŸ“‹ Planned | +12% improvement | Measuring delta vs 28.0% |

---

### Phase 5b: OPERATION PROSTHESIS (COMPLETE)
**Objective**: Build the "Hands" of the Oracle to apply fixes automatically.

| Task | Status | Target | Result |
|------|--------|--------|--------|
| **DEPYLER-1305** | âœ… **Complete** | FixApplicator | Infrastructure built (fix_applicator.rs) |
| **DEPYLER-1306** | âœ… **Complete** | Loop Wiring | `auto_fix` flag connected, tests pass |
| **Fix Rate** | ðŸ”´ **0%** | >0 fixes | Patterns too specific (e.g., `py_sub` vs `keys`) |

**Empirical Note (The Hand but No Fingers):**
The actuator infrastructure is operational, but the current `GeneratedRustFixer` patterns are brittle text matches that fail against the complexity of transpiler-generated errors (e.g., missing trait methods like `py_sub` on `Vec<f64>`). The Oracle correctly identifies the problem but the actuator lacks the "dexterity" to apply the fix.

### Phase 5c: OPERATION FINGERS (ACTIVE)
**Objective**: Equip the actuator with domain-specific patching capabilities.

| Task | Status | Target |
|------|--------|--------|
| **DEPYLER-1307** | ðŸ“‹ Planned | **TranspilerPatcher**: Apply fixes to `depyler-core` rules, not generated code. |
| **DEPYLER-1308** | ðŸ“‹ Planned | **NumPy Mapping**: Map Python operators to native Rust operators for E0599/E0308. |
| **DEPYLER-1309** | ðŸ“‹ Planned | **Similarity Retrieval**: Use `entrenar` for fuzzy pattern matching. |

**Exit Criteria:**
- [ ] At least 1 fix successfully applied in convergence loop
- [ ] Compile rate improvement >0%

---

*   **DEPYLER-1221**: COMPLETE â€” **Dict String Access Guard**. Implemented a type-aware guard in `stmt_gen.rs` to prevent redundant unwrapping of raw string keys. The transpiler now distinguishes between `serde_json::Value` proxies (which require extraction) and native Rust strings (which do not). **Result: E0599/E0308 errors in dictionary lookup chains eliminated.**
*   **DEPYLER-1220**: COMPLETE â€” **Cross-Function Return Type Inference**. Validated that return types are correctly propagated across unannotated function chains and recursive calls through Hindley-Milner unification. **Result: Chained unannotated logic now correctly infers Rust types.**
*   **DEPYLER-1219**: COMPLETE â€” **Recursive Deep Generic Inference**. Implemented recursive subtype extraction for deep generics (e.g., `Dict[str, Dict[int, List[str]]]`). Nested empty literals now inherit the precise subtype of their parent container. **Result: Complex nested data structures no longer fallback to DepylerValue proxies.**
*   **DEPYLER-1218**: COMPLETE â€” **Optional Dict Unwrapping**. Fixed E0308 errors where empty dictionary assignments (e.g., `memo = {}`) failed to infer types when the variable was typed as `Optional[Dict[K, V]]`. The unwrapper now correctly extracts the inner `HashMap<K, V>` signature. **Result: Recursive algorithms with memoization now compile correctly.**
*   **DEPYLER-1217**: COMPLETE â€” **Mutability Inference for Index Assignment (E0596 Fix)**. Fixed "cannot borrow as mutable" errors by detecting mutation patterns: (1) Index assignment `arr[i] = value` marks `arr` as mutable. (2) Tuple swap patterns `arr[i], arr[j] = arr[j], arr[i]` mark `arr` as mutable. (3) Transitive mutation: when a function calls another that expects `&mut` param, the caller's variable is marked mutable. **Pattern fixed**: `def partition(arr, low, high): arr[i], arr[j] = ...` now generates `arr: &mut Vec<i32>` instead of `arr: &Vec<i32>`. **Result: quicksort.py and similar algorithms now compile correctly.**
*   **DEPYLER-1216**: COMPLETE â€” **Semantic Entry Point (E0601 Fix)**. Captured top-level script logic and wrapped it in the generated `main()` function. This transforms the previous "Stale Stub" into a functional entry point that actually executes the Python script's logic. **Result: Standalone script compilation achieved.**
*   **DEPYLER-1215**: COMPLETE â€” **Dict Literal Value Wrapping at Call Sites**. When a dict literal is passed directly to a function expecting `Dict[str, Any]` or bare `dict`, the values are now properly wrapped in `DepylerValue`. Added `as_str()`, `as_i64()`, `as_f64()`, `as_bool()` methods to `DepylerValue` for type-safe value extraction. **Pattern fixed**: `from_dict({"name": "test"})` now generates `map.insert("name".to_string(), DepylerValue::Str("test".to_string()))` instead of `map.insert("name".to_string(), "test".to_string())`. **Result: Dict argument passing now type-correct.**
*   **DEPYLER-1170**: COMPLETE â€” **Proxy Semantic Completion**. Finalized the integration of `py_index` with `DepylerValue`. Implemented raw string key support, Python-style method mapping (startswith/endswith), and robust default value wrapping for `.get()`. **Result: E0308 errors reduced from 352 to 224 (36% reduction).**
*   **DEPYLER-1169**: COMPLETE â€” **Final 59 Root Cause Analysis**. Identified the remaining anomalies in dictionary access. Implemented `get_str()` optimization for `DepylerValue` maps to bridge the gap between proxy objects and concrete Rust string APIs. **Result: test_json_parsing.py and test_heterogeneous_dict.py now compile.**
*   **DEPYLER-1167**: COMPLETE â€” **Implicit Result Normalization**. Refined try/except closure transformations to automatically wrap return statements in `Ok()` when the closure signature returns a `Result`. **Result: "Expected Result, found non-Result" error class eliminated.**
*   **DEPYLER-1166**: COMPLETE â€” **Implicit String Promotion Strike**. Resolved E0308 mismatches where list literals in NASA mode dictionaries were not being wrapped in `DepylerValue`. Implemented recursive element wrapping for `Int`, `Float`, `Str`, `Bool`, `None`, and nested collections. **Result: 35 E0308 errors eliminated, Compile Rate improved to 40.0%.**
*   **DEPYLER-1165**: COMPLETE â€” **Truth Metric Gold Master**. Established a cleaned convergence baseline by filtering `pytest` artifacts. Recalculated total E0308 baseline at 300 errors (post-1166 fix). **Result: Instrument calibration complete; every remaining error is functional application logic.**
*   **DEPYLER-1162**: COMPLETE â€” **Global Synapse (Phase 1)**. Validated single-module type propagation. The `GlobalTypeGraph` correctly captures return signatures for internal functions. **Result: Multi-pass foundation verified.**
*   **DEPYLER-1163**: COMPLETE â€” **Kill List Execution (Set Typing)**. Executed a targeted strike on E0308 errors in collection literals. Refined `infer_collection_element_type()` to correctly distinguish between `HashSet<i32>` and `HashSet<DepylerValue>` based on literal content. **Pattern fixed**: `s = {1, 2, 3}` now generates concrete Rust sets, eliminating proxy overhead and type mismatches in standard library calls. **Result: Initial Kill List targets neutralized.**
*   **DEPYLER-1161**: COMPLETE â€” **Global Type Propagation Experiment**. Validated the "Global Synapse" hypothesis. Designed and tested a multi-pass architecture where function return types are collected in Pass 1 and propagated to call-sites across module boundaries in Pass 2. **Result: 11 tests passed, proving that cross-module inference can eliminate E0308 mismatches in call chains.**
*   **DEPYLER-1158**: COMPLETE â€” **Noise Filtering Strategy (Pytest)**. Refined the convergence baseline by explicitly excluding files containing `pytest` imports or fixture patterns. Flagged fixtures like `tmp_path`, `monkeypatch`, `capsys`, etc. **Result: Cleaned noise from metrics, allowing focus on functional application code.**
*   **DEPYLER-1159**: COMPLETE â€” **Reference/Ownership Strike**. Utilized `borrow_if_needed_typed()` infrastructure to resolve E0308 patterns. Identified and fixed mismatches in `&[u8]` vs `Vec<u8>` and `&str` vs `String`. Enforced move semantics for `Copy` types (i32, f64). **Result: 10 tests passed covering core reference/ownership scenarios.**
*   **DEPYLER-1160**: COMPLETE â€” **Trait Bound Offensive**. Audited and implemented missing standard trait implementations for `DepylerValue` and generic types. Added `PartialEq`, `Eq`, `Hash`, `Display`, `Clone`, `Debug`, `Index`, and arithmetic ops. **Result: 14 tests passed, established robust foundation for standard library integration.**
*   **DEPYLER-1156**: COMPLETE â€” **Noise Floor Deep Scan**. Executed a comprehensive convergence run using the decision-tracing infrastructure. Identified the "Kill List" of remaining errors: E0308 (124 counts - ref vs owned), E0425 (98 counts - pytest fixtures), E0277 (50 counts - trait bounds). **Result: Prioritized target list for 80% convergence achieved.**
*   **DEPYLER-1157**: COMPLETE â€” **Semantic Parity Audit**. Verified that `DepylerValue` trait implementations (`PyTruthy`, `PyAdd`, `PyIndex`) match Python semantics. Confirmed correct behavior for empty collection truthiness, mixed-type arithmetic (int+float), and negative indexing. **Result: 17 unit tests passed, establishing a verified semantic baseline.**
*   **DEPYLER-1151**: COMPLETE â€” **Result Normalization**. Documented and verified 6 Result/Option mixing patterns in the transpiler. Standardized the generation path for functions with multiple return types (Result vs Option) to ensure consistent `.unwrap_or_default()` or `Ok(Some())` patterns. **Result: 8 tests passed, eliminating ambiguity in mixed return paths.**
*   **DEPYLER-1155**: COMPLETE â€” **NASA Mode Math Constants**. Implemented "Universal Laws" for mathematical constants in NASA Mode. Mapped Python's `math.pi`, `math.e`, `math.tau`, `math.inf`, `math.nan` to their high-precision, `std`-only Rust equivalents (`std::f64::consts::PI`, `f64::INFINITY`, etc.). Eliminated ad-hoc "3.15" test patches. **Result: 7 regression tests passed, verifying precision and safety without external dependencies.**
*   **DEPYLER-1154**: COMPLETE â€” **Over-Borrowing Infrastructure**. Addressed the "Over-Borrowing Hypothesis" by implementing type-aware borrowing logic. Added `Type::is_copy()` to the HIR type system and `borrow_if_needed_typed()` to the generator. This infrastructure prevents defensive `&` insertion for `Copy` types (i32, bool, f64), laying the groundwork for a cleaner ownership model. **Result: 15 unit tests passed covering Copy/non-Copy scenarios.**
*   **DEPYLER-0426**: COMPLETE â€” **CSV Module Dispatch**. Resolved the Dispatch Routing Failure for `csv.DictWriter`. Implemented `with_nasa_mode(bool)` configuration to properly test CSV output (which requires external crates not available in strict NASA mode). Updated tests to verify correct struct initialization for module-level factories. **Result: CSV kwarg handling verified.**
*   **DEPYLER-1153**: COMPLETE â€” **Nested Dict Type Propagation**. Resolved a critical falsification where explicit type annotations for nested generics (e.g., `dict[str, dict[str, int]]`) were ignored. Added `is_concrete_type()` to recursively validate generic structures. Updated `target_has_concrete_value_type` to trigger propagation. Modified value conversion to pass target type context deep into nested literals. **Pattern fixed**: `return {"outer": {"inner": nums[0]}}` now generates correctly nested concrete `HashMap` types instead of `DepylerValue` proxies. **Result: DEPYLER-0270 failures eliminated.**
*   **DEPYLER-1150**: COMPLETE â€” **Slice-to-Vec Return Coercion**. Fixed E0308 errors when returning varargs (`*args`) parameters in functions with `Vec<T>` return types. Python's `*args` parameters transpile to Rust `&[T]` slices for efficiency, but returning `args` in a function declared to return `List[T]` (â†’ `Vec<T>`) caused type mismatch. Added `slice_params` tracking to `CodeGenContext` and automatic `.to_vec()` coercion in `codegen_return_stmt`. **Pattern fixed**: `def func(*args) -> List[T]: return args` â†’ `fn func(args: &[T]) -> Vec<T> { args.to_vec() }`. **Result: 2 E0308 errors eliminated.**
*   **DEPYLER-1149**: COMPLETE â€” **Set Literal Type Inference**. Fixed 42 E0308 `HashSet<DepylerValue>` errors by adding element type inference for set literals. Previously, all set literals were unconditionally typed as `HashSet<DepylerValue>` regardless of element types. Added `infer_collection_element_type()` helper in `stmt_gen.rs` that examines set literal elements: all integers â†’ `HashSet<i32>`, all floats â†’ `HashSet<f64>`, all strings â†’ `HashSet<String>`, mixed/unknown â†’ `HashSet<DepylerValue>`. **Pattern fixed**: `s = {1, 2, 3}` now generates `let s: HashSet<i32>` instead of `HashSet<DepylerValue>`. **Result: 41 E0308 errors eliminated (97.6% reduction), 7 files unblocked.**
*   **DEPYLER-1148**: COMPLETE â€” **CITL Flight Recorder**. Activated dormant Decision Tracing infrastructure in the main CLI. Added `init_decision_tracing()` hook to `main.rs`. When built with `--features decision-tracing`, the transpiler now captures all inference logic (TypeMapping, BorrowStrategy, etc.) to a memory-mapped binary log (`/tmp/depyler_decisions.msgpack`). **Result: The "Black Box" of inference is now observable for causal chain analysis.**
*   **DEPYLER-1147**: COMPLETE â€” **Optional Parameter Return Unwrap**. Fixed E0308 errors where functions returning `T` were incorrectly returning `&Option<T>` from optional parameters. Added automatic dereferencing and unwrapping (`(*maybe_val).unwrap()`) for return statements. **Result: 12 examples unblocked.**
*   **DEPYLER-1146**: COMPLETE â€” **Dict Subscript Option Unwrap**. Fixed E0308 errors where `dict[key]` access on `DepylerValue` maps returned `Option<DepylerValue>` instead of the value itself. Added `.unwrap_or_default()` to subscript expressions. **Result: 18 examples unblocked.**
*   **DEPYLER-1145**: COMPLETE â€” **Context-Aware Index Type Inference**. Fixed "expected DepylerValue, found i32" by tracking concrete element types in module constants. `list_example[0]` now correctly infers the element type (e.g., `i32`) instead of defaulting to proxy.
*   **DEPYLER-1144**: COMPLETE â€” **Contextual List Literals**. Integer literals in lists are now coerced to float (`vec![0.0]`) when passed to `Vec<f64>` parameters (e.g., `Polynomial([0])`).
*   **DEPYLER-1143**: COMPLETE â€” **Argparse Heterogeneity**. Enhanced `dict_has_mixed_types` to check argparse trackers, ensuring proper `DepylerValue` wrapping for heterogeneous CLI argument dictionaries.
*   **DEPYLER-1139**: COMPLETE â€” **Stub Signature Refinement**. Updated module alias stubs to use variadic-friendly generic signatures (`<S: AsRef<str>>`, `<P>`, `<E>`) instead of hardcoded types. Added additional XML functions (`parse`, `ElementTree`, `iterparse`, `get`). **Result: E0061 (argument count mismatch) reduced from 16â†’15 examples blocked.**
*   **DEPYLER-1138**: COMPLETE â€” **Property-to-Method Promotion**. Fixed E0615 "attempted to take value of method" errors. Python's attribute access on XML elements (e.g., `root.tag`) now correctly generates Rust method calls (`root.tag()`) when using `DepylerValue` proxies. **Result: Semantic parity achieved for property-like API access.**
*   **DEPYLER-1136**: COMPLETE â€” **Alias Stub Generation**. Resolved the #1 Pareto blocker (E0425). When `import X as Y` is encountered, the transpiler now generates a Rust module or struct alias `Y` so that `Y.method()` calls are resolved. **Result: 138 E0425 errors eliminated, E0423 (19) eliminated.**
*   **DEPYLER-1134**: COMPLETE â€” **Constraint-Aware Coercion**. The code generator now obeys Oracle constraints. **Result: The "Type War" is won.**
*   **DEPYLER-1133**: COMPLETE â€” **Restoration of Truth**. Connected the Feedback Loop. **Result: Oracle learning is now active.**
*   **DEPYLER-1141**: COMPLETE â€” **Typed Dict Value Coercion**. When dict literal has concrete value type annotation (e.g., `Dict[str, float]`), skip DepylerValue wrapping even if values have mixed types (int/float). Added value coercion to target type. **Pattern fixed**: `stats: Dict[str, float] = {"k": int_var}` â†’ coerces int_var to f64. **Result: examples/simulation_combined.py now compiles.**
*   **DEPYLER-1135**: COMPLETE â€” **Numeric Coercion**. Implemented Universal Numeric Promotion for NumPy NASA mode aggregations. All numpy operations (sum, mean, dot, min, max, std, var, norm) now coerce elements to f64 before computation. Added `expr_returns_f64()` helper to detect f64-returning expressions and extended `needs_type_conversion()` to apply return type coercion. **Result: E0308 type mismatches for numpy integer array operations eliminated.**
*   **Noise Filtering Strategy**: Identified 70+ failures as `pytest` artifacts. These are now excluded from the convergence baseline to ensure metrics reflect functional application code.
*   **DEPYLER-1132**: COMPLETE â€” **List Repeat Type Inference**. ...
*   **DEPYLER-1131**: COMPLETE â€” **Vec List Concatenation**. Implemented `PyAdd<Vec<T>> for Vec<T>` trait to support Python list concatenation. Three implementations: owned+owned, owned+ref, ref+owned. **Pattern fixed**: `combined = list1 + list2` â†’ `list1.py_add(list2)` returns `Vec<T>`. **Result: E0599 "no method py_add for Vec" errors eliminated for list concatenation.**
*   **DEPYLER-1130**: COMPLETE â€” **Lambda Boolean Parameter Type Inference**. Lambda parameters used directly as conditions in if-expressions now correctly infer as `bool` type. Added `param_used_as_condition()` function that detects when a parameter is used as `IfExpr.test` directly. **Pattern fixed**: `lambda is_add: (add) if is_add else (sub)` â†’ `is_add: bool` not `is_add: i64`. **Result: E0308 bool/i64 mismatches for lambda conditionals eliminated.**
*   **DEPYLER-1129**: COMPLETE â€” **Vec List Repetition**. Implemented `PyMul<i32>`, `PyMul<i64>`, `PyMul<usize>` for `Vec<T>` and reverse multiplication for int types. **Pattern fixed**: `[0] * 10` â†’ `vec![0].py_mul(10)` returns `Vec<i32>`. **Result: E0271 type mismatches for list repetition eliminated.**
*   **DEPYLER-1128**: COMPLETE â€” **Module-Level Type Inference**. Improved type inference for module-level constants. (1) Homogeneous lists now infer concrete types: `[1,2,3]` â†’ `Vec<i32>` instead of `Vec<DepylerValue>`. (2) Homogeneous sets similarly: `{1,2,3}` â†’ `HashSet<i32>`. (3) Tuple types now properly inferred: `(1, "str", 3.14)` â†’ `(i32, String, f64)`. (4) Binary expression types inferred from operand types: `10 + 20` â†’ `i32`. (5) Non-const operations (binary ops, string comparisons) now use `LazyLock` instead of `pub const` to avoid E0015 errors. **Pattern fixed**: Module-level `list_example = [1, 2, 3, 4, 5]` now generates `Vec<i32>` with correct integer literals instead of `Vec<DepylerValue>` with unwrapped literals. **Result: E0015 const-context errors eliminated for binary operations and string comparisons.**
*   **DEPYLER-1127**: COMPLETE â€” **Value-Returning or/and Operators**. Python's `or`/`and` operators are value-returning, not boolean-returning like Rust's `||`/`&&`. Previously, `x or 0.1` generated `x || 0.1` which returned bool. Now detects non-boolean operands and generates value-returning pattern: `{ let _or_lhs = x; if _or_lhs.is_true() { _or_lhs } else { default } }`. Added `expr_is_boolean_expr()` to detect comparison/boolean expressions, `expr_is_depyler_value()` to detect DepylerValue types, and `expr_might_be_depyler_value()` for heuristic detection of dict.get chains. When left operand might be DepylerValue and right is numeric literal, wraps in `DepylerValue::Int/Float`. **Pattern fixed**: `wait = status.get("time") or 0` now returns the value, not a boolean. **Result: Value-returning semantics preserved for non-boolean or/and operations.**
*   **DEPYLER-1126**: COMPLETE â€” **Mutable Option Parameter Dereference**. Fixed E0308 errors when assigning to `&mut Option<T>` parameters. When Python function has `param: T | None = None` that is mutated, the transpiler generates `&mut Option<T>`. The assignment `param = value` must dereference: `*param = Some(value)`. Added `mut_option_params` tracking for all Optional parameters with `needs_mut` flag from lifetime analysis. **Pattern fixed**: `if as_of is None: as_of = date.today()` â†’ `*as_of = Some(DepylerDate::today())`. **Result: Optional parameter reassignments now dereference correctly.**
*   **DEPYLER-1125**: COMPLETE â€” **Dict Get with Default Value**. Fixed E0308 errors when class methods used `dict.get(key, default)` 2-arg form. Python's 2-arg `dict.get(k, d)` returns value at key or default, but Rust HashMap has no 2-arg get. Previously generated invalid: `.get(v, vec![])`. Now generates: `.get(&v).cloned().unwrap_or_else(|| vec![])`. Added handler in `convert_method_call()` for dict "get" method detecting 1-arg vs 2-arg forms. **Pattern fixed**: `self._adj.get(v, vec![])` â†’ `self._adj.get(&v).cloned().unwrap_or_else(|| vec![])`. **Result: Graph algorithms with adjacency lists now compile correctly.**
*   **DEPYLER-1124**: COMPLETE â€” **Union Return Type Conversion**. Fixed E0308 errors when functions with Union return types (e.g., `Union[TokenBucket, SlidingWindow]`) returned concrete variants without conversion. Union types generate `From<A>` and `From<B>` trait impls, but return statements lacked the `.into()` call. Added Union detection in `codegen_return_stmt()` that adds `.into()` to expressions when return type is `Type::Union(_)`. **Pattern fixed**: `return Ok(TokenBucket::new())` â†’ `return Ok(TokenBucket::new().into())`. **Result: Union type returns now compile correctly via From trait conversion.**
*   **DEPYLER-1123**: COMPLETE â€” **From Dict Type Extraction**. Fixed E0308 errors when accessing `HashMap<DepylerValue, DepylerValue>` in `from_dict` classmethods. Two-part fix: (1) Added `From<DepylerValue>` trait implementations for i32, i64, f32, f64, String, bool in rust_gen.rs runtime, enabling `.into()` to extract typed values from DepylerValue. (2) Modified `convert_index()` in direct_rules_convert.rs to detect bare dict parameters (`dict` without type params) and generate `data.get(&DepylerValue::Str("key".to_string())).cloned().unwrap_or_default().into()` instead of `data.get(&"key".to_string())`. **Result: `from_dict(data: dict)` classmethods now compile correctly with proper key wrapping and type extraction.**
*   **DEPYLER-1122**: COMPLETE â€” **Dict DepylerValue Wrapping for Class Methods**. Fixed E0308 type mismatch errors in class methods with bare `dict` return type (e.g., `to_dict() -> dict:`). Previously, dict literals inserted raw types into `HashMap<DepylerValue, DepylerValue>` causing type mismatches. Added `convert_dict_to_depyler_value()` helper that wraps keys in `DepylerValue::Str()` and values in appropriate `DepylerValue::{Int,Float,Bool,Str}()` based on field types. Modified `convert_method_stmt()` to detect bare dict return types and apply DepylerValue wrapping. **Result: Class `to_dict()` methods now generate correct code like `map.insert(DepylerValue::Str("capacity".to_string()), DepylerValue::Int(self.capacity as i64))`.**
*   **DEPYLER-1121**: COMPLETE â€” **NASA Mode NumPy Support**. Implemented std-only numpy emulation for NASA mode. NumPy operations now generate `Vec<f64>` operations instead of trueno crate calls: `np.array()` â†’ `vec![]`, `np.exp(arr)` â†’ `arr.iter().map(|x| x.exp()).collect()`, `np.sum()` â†’ `iter().sum()`, `np.mean()` â†’ `sum() / len()`, `np.dot()` â†’ `iter().zip().map().sum()`, etc. **Result: NumPy examples now compile in NASA mode without external dependencies.** Example: `numpy_exp_tool.py`, `numpy_mean_tool.py`, `numpy_sum_tool.py`, etc. now pass single-shot compilation.
*   **DEPYLER-1120**: COMPLETE â€” **Argparse Keyword Escaping**. Fixed Rust keyword collision in argparse struct field names. Python CLI args like `--type` generated invalid Rust `type: String` field. Updated `argparse_transform.rs` to use `safe_ident()` for all field name generation, producing `r#type: String` using Rust raw identifier syntax. **Result: CLI tools with reserved keywords as args now compile.**
*   **DEPYLER-1101**: IN PROGRESS â€” **Oracle Type Repair (Phase 1)**. Implemented `TypeConstraintLearner` to extract type constraints from E0308 errors. Parses "expected X, found Y" pairs using regex, maps Rust types to HIR `Type` enum (Int, Float, String, Bool, List, Dict, Optional, Set, Custom). Added `rust_type_to_hir()` converter and `repair_file_types()` entry point. **Phase 1 (Passive Learning) complete. Phase 2 (Active Repair) pending: need to inject learned constraints back into `CodeGenContext.var_types` and re-transpile.**
*   **DEPYLER-1119**: COMPLETE â€” **UTOL Oracle Calibration**. Fixed critical bugs in `try_compile_rust()`: (1) Added `--edition 2021` for Rust 2021 syntax support. (2) Replaced `/dev/null` output path with proper temp fileâ€”rustc was trying to create temp directories in `/dev/` which fails with permission denied. **Result: UTOL now correctly reports 45.2% compile rate (84 files processed, 38 passing). Previously showed 0% due to compilation check failures.**
*   **DEPYLER-1118**: COMPLETE â€” **PyStringMethods Trait**. Implemented Python string method parity via the `PyStringMethods` trait. Maps `lower()`, `upper()`, `strip()`, `lstrip()`, `rstrip()`, `startswith()`, `endswith()`, `capitalize()`, `title()`, `swapcase()`, `isalpha()`, `isdigit()`, `isalnum()`, `isspace()`, `islower()`, `isupper()`, `center()`, `ljust()`, `rjust()`, `zfill()`, `count()`, `py_split()`, `py_replace()`, `py_find()`. Implemented for `str`, `String`, and `DepylerValue`. Added `PyMul` and `PyAdd` for `&str`. **Result: E0599 reduced from 39 â†’ 32 (-17.9%). Compile rate 31.2% â†’ 33.0%.**
*   **DEPYLER-1117**: COMPLETE â€” **Lambda Type Inference**. Added `infer_lambda_param_type()` to analyze lambda body expressions and infer parameter types. Detects iterator patterns (ListComp, SetComp, DictComp, GeneratorExp) to type params as `Vec<i64>`, and PyOps arithmetic patterns to type as `i64`. **Result: E0282 (Type Annotations Needed) reduced from 14 â†’ 10 (-28.6%).**
*   **DEPYLER-1116**: COMPLETE â€” **Proxy Pattern for Method Stubs**. Implemented `generate_default_return()` to provide sensible default values (0, 0.0, "", empty collections) for method stubs instead of panicking `todo!()`. Module functions now construct phantom structs initialized with defaults. Verified with 19 passing binding tests.
*   **DEPYLER-1115**: COMPLETE â€” **Phantom Structure Bindings (NASA Compliant)**. Implemented JIT binding generation. The transpiler now synthesizes Rust `mod` and `struct` definitions (e.g., `requests::models::Response`) from TypeDB facts, eliminating E0412 (Type Not Found) errors. Verified NASA mode compatibility: parameter mapping fixed (Any -> &str) to match transpiler literals. 
*   **DEPYLER-1114**: COMPLETE â€” **Knowledge Ingestion**. Harvested `requests` library into Sovereign Type DB (289 type facts, 21KB parquet). Validated TypeQuery with `find_signature("requests.api", "get")` returning `Response`.
*   **DEPYLER-1113**: COMPLETE â€” **Synapse Activation**. Connected TypeDB to expression generation. `expr_gen.rs` now queries TypeDB on MethodCall for external modules. `stmt_gen.rs` propagates return types to `var_types`. The "Learning Synapse" is active.
*   **DEPYLER-1112**: COMPLETE â€” **Type DB Integration**. Wired `depyler-knowledge` into `depyler-core` via `sovereign-types` feature flag. `CodeGenContext` now has access to O(1) type lookups.
*   **DEPYLER-1111**: COMPLETE â€” **Sovereign Type DB**. Built `depyler-knowledge` crate. Validated extraction of 838 type facts from `requests` into 53KB Parquet DB using `uv` and `rustpython_parser`.
*   **DEPYLER-1109**: COMPLETE â€” **Universal PyOps Dispatch**. Implemented `PyAdd`, `PySub`, `PyMul`, `PyDiv`, `PyMod` universal dispatch. **Result: E0369 (Binary Op) errors ELIMINATED (152 -> 0). E0308 reduced by 304 (8.1%).**
*   **DEPYLER-1108**: FIXED â€” **Parallelism Bug**. Resolved race condition in `compiler.rs` during concurrent artifact generation.
*   **DEPYLER-1106**: FIXED â€” **PyOps Codegen Integration**. Updated `expr_gen.rs` to generate `.py_add()`/`.py_sub()` for `DepylerValue` types, leveraging the trait system for implicit coercion.
*   **DEPYLER-1105**: COMPLETE â€” **Convergence Validation (Structural Phase)**. Gold Master run on expanded 369-file corpus. Results: 80 passing (21.7%), E0308 (3763), TRANSPILE (30), E0562 (15), E0317 (9). **Key insight: PyOps integration initiated; 18x speedup achieved via institutionalized RAM disk setup.**
*   **DEPYLER-1104**: COMPLETE â€” **PyOps Trait Expansion**. Implemented Python-semantic arithmetic and indexing traits: `PyAdd`, `PySub`, `PyMul`, `PyDiv`, `PyIndex`. Cross-type promotion (i32+f64â†’f64), string repetition (str*int), negative indexing support. Implementations for i32, i64, f64, String, Vec<T>, HashMap, DepylerValue. **4 tests passing.** This provides the semantic foundation for replacing manual type coercion with trait-based dispatch.
*   **DEPYLER-1103**: FIXED â€” **PyTruthy Trait**. Implemented `PyTruthy` trait for all core types and `DepylerValue`, standardizing Python truthiness semantics across the codebase.
*   **DEPYLER-1102**: COMPLETE â€” **Oracle Loop Activation**. Diagnosed and fixed the "Zombie Oracle" issue where learned constraints were ignored by the generator. Implemented `transpile_with_constraints_and_dependencies` and connected it to `compile_cmd.rs`. Verified active learning on `test_csv.py` (3 attempts, constraints extracted and reapplied). **Result: The Feedback Loop is now physically connected.**
*   **DEPYLER-1101**: COMPLETE â€” **Oracle Type Repair**. Implemented `TypeConstraintLearner` (Phase 1) and wired it into the active compile loop (Phase 2).
*   **DEPYLER-1134**: PENDING â€” **Constraint-Aware Coercion**. The generator currently ignores Oracle constraints during method calls (e.g., pushing `DepylerValue` into a `Vec<String>` that the Oracle correctly identified). The next step is to make `convert_list_method` respect `var_types` constraints by generating `.try_into().unwrap()` coercions.
*   **DEPYLER-1100**: FIXED â€” **Literal Coercion & Reference Assignment (E0308)**. Resolved two high-frequency E0308 patterns: (1) Numeric comparisons (float var > 0) now coerce literals to float (0.0). (2) Reference assignments (borrowed â†’ owned) now automatically inject `.clone()`. Regression tests pass.
*   **DEPYLER-1099**: COMPLETE â€” **Convergence Analysis**. Ran full corpus convergence (271 files). Results: 73 passing (26.9%). Error distribution: E0308 (3321), E0599 (1199), E0277 (804). **Key insight: Tactical fixes are hitting diminishing returns; structural architectural shifts required.**
*   **DEPYLER-1098**: FIXED â€” **serde_json NASA Mode Fix (E0433)**. Eliminated 69+ E0433 "unlinked crate serde_json" errors in NASA mode. Analysis showed `serde_json` was being generated in several places without NASA mode checks. **Root causes**: (1) Union type fallback in `direct_rules.rs:resolve_union_enum_to_syn` hardcoded `serde_json::Value`. (2) JSON module constructor in `direct_rules_convert.rs` used `serde_json::from_str` without NASA check. (3) Regex module placeholder used `serde_json::Value::Null`. **Fixes**: (1) Changed union fallback to `DepylerValue` (std-only). (2) Added NASA mode branches for `json.loads/dumps` returning HashMap stub / format!() string. (3) Changed `re` placeholder to `None::<String>`. **Result: NASA mode now generates 100% std-only code for JSON operations.** Regression test: `test_depyler_1098_no_serde_json_in_nasa_mode`.
*   **DEPYLER-1097**: FIXED â€” **Module Mapping Blitz (E0425)**. Reduced E0425 "cannot find value" errors by mapping common Python builtins and stdlib modules to Rust equivalents. Analysis showed top blockers: `all` (23 files), `sys` (14 files), `dict` (9 files), `any` (similar to all). **Fixes implemented**: (1) Added `all()` builtin â†’ `items.iter().all(|&x| x)` for boolean iterables. (2) Added `any()` builtin â†’ `items.iter().any(|&x| x)` for boolean iterables. (3) Added `dict()` builtin â†’ `HashMap::new()` or `into_iter().collect()`. (4) Added `sys` module attribute access: `sys.argv` â†’ `std::env::args().collect()`, `sys.exit(code)` â†’ `std::process::exit()`, `sys.platform` â†’ `std::env::consts::OS`, `sys.stdin/stdout/stderr` â†’ `std::io::stdin()/stdout()/stderr()`, `sys.maxsize` â†’ `i64::MAX`, `sys.getsizeof()` â†’ `std::mem::size_of_val()`. **Result: Mapped most common E0425 blockers. ~30+ files potentially unblocked.** Regression tests: `test_depyler_1097_all_builtin`, `test_depyler_1097_any_builtin`, `test_depyler_1097_dict_builtin`, `test_depyler_1097_sys_argv`.
*   **DEPYLER-1096**: FIXED â€” **Boolean Truthiness Coercion**. Fixed E0308 errors where non-bool types were used in `if`/`while` conditions. Python allows any type in conditions (truthy/falsy semantics): empty collections are falsy, zero is falsy, None is falsy. Rust requires explicit bool. Root cause: `convert_stmt()` in `direct_rules_convert.rs` used `convert_expr_with_param_types()` for if/while conditions without applying truthiness coercion. Fix: Added `apply_truthiness_coercion()` method to ExprConverter and `convert_condition_expr()` wrapper function. The coercion logic: (1) Comparisons and boolean operators already return bool - pass through unchanged. (2) Collections (Vec, HashMap, etc.) get `!is_empty()`. (3) Options get `is_some()`. (4) Numerics get `!= 0`. Made `truthiness_helpers` module public for reuse. Updated if/while handlers to use `convert_condition_expr()`. **Result: Non-bool conditions now correctly coerced to bool.** Regression tests: `test_depyler_1096_truthiness_collection`, `test_depyler_1096_truthiness_bool_passthrough`, `test_depyler_1096_truthiness_comparison_passthrough`.
*   **DEPYLER-1095**: FIXED â€” **Python Negative Indexing (list[-1])**. Fixed runtime panic where Python `list[-1]` (get last element) was transpiled to `-1 as usize` which wraps to a huge number in Rust. Root cause: `convert_index()` in `direct_rules_convert.rs` at line 2667 generated `#base_expr[#index_expr as usize]` without handling negative indices. Python semantics: `-1` means last element, `-2` means second-to-last, etc. Fix: Modified `convert_index()` to detect negative indices (both literals and `UnaryOp::Neg`) and generate safe runtime indexing: `if idx < 0 { base[base.len().wrapping_sub((-idx) as usize)] } else { base[idx as usize] }`. For variable indices, always generate the runtime check since the value could be negative at runtime. **Result: Python negative indexing now works correctly in transpiled code.** Regression tests: `test_depyler_1095_negative_indexing`, `test_depyler_1095_variable_index_safety`.
*   **DEPYLER-1094**: FIXED â€” **Numeric Mixing i32/f64 in min/max and Binary Ops**. Fixed E0277/E0308 errors where Python's implicit intâ†’float promotion wasn't replicated. Root causes: (1) `min(capacity, tokens + rate)` where capacity:int and tokens:float generated `.min()` method call without type coercion. (2) `tokens - count` where tokens:f64 and count:i32 generated `f64 - i32` which Rust doesn't support. (3) Single-arg `min(iterable)` generated standalone `min()` function call that didn't exist. Fix: In `direct_rules_convert.rs`: (1) Changed 2-arg min/max to cast both operands to f64: `(a as f64).min(b as f64)`. (2) Added single-arg min/max handling: `iterable.iter().cloned().min().unwrap()`. (3) Added type coercion to `BinOp::Sub` using `expr_returns_float_direct()` to detect mixed types and cast i32 to f64. **Result: Numeric mixing errors for min/max and subtraction eliminated.** Regression tests: `test_depyler_1094_numeric_mixing_min_max`, `test_depyler_1094_numeric_mixing_subtraction`.
*   **DEPYLER-1093**: FIXED â€” **Option Double-Wrapping Prevention**. Fixed E0308 errors where assignments to `Option<T>` variables incorrectly wrapped expressions that already return `Option<T>` in `Some()`, creating `Option<Option<T>>`. Root causes: (1) `os.environ.get(name)` â†’ `std::env::var(name).ok()` returns `Option`, was wrapped in `Some()`. (2) Assigning from `&Option<T>` variable was wrapped in `Some(default)` instead of `default.clone()`. Fix: Extended `is_already_option` check in `stmt_gen.rs:4178` to detect `.ok()`, `.get()`, `.cloned()`, `.as_ref()` patterns. Also detect when source variable has `Optional` type and emit `.clone()` instead of `Some()` wrapper. **Result: Option double-wrapping errors eliminated.** Regression test: `test_depyler_1093_option_assignment_no_double_wrap`.
*   **DEPYLER-1092**: FIXED â€” **String Literal Coercion for &str Params**. Fixed E0308 errors where string literal default args (e.g., `separator: str = ","`) were generated as `",".to_string()` for borrowed `&str` params. Root cause: The default value completion code at line 4628 didn't check `param_needs_borrow`. Fix: Check `function_param_borrows` and emit bare string literal `","` (which is `&str`) instead of `",".to_string()` when param is borrowed. Also added match arm for `HirExpr::Literal(Literal::String)` in `needs_borrow` calculation. **Result: E0308 `&str`/`String` errors eliminated in tested files.** Regression test added: `test_depyler_1092_string_default_arg_for_borrowed_param`.
*   **DEPYLER-1091**: COMPLETE â€” **E0308 Type Mismatch Analysis**. Analyzed 67 E0308 errors on 369-file corpus. Found 5 dominant sub-patterns: (1) `Option<String>` vs `String` (15 files), (2) `&str` vs `String` (13 files), (3) `i32` vs `f64` (11 files), (4) `usize` vs `i32` (8 files), (5) `bool` vs other (7 files). **Recommended fix priority: String reference coercion (`&str`/`String`) has lowest complexity and affects 13 files.**
*   **DEPYLER-1090**: FIXED â€” **Strip clap::CommandFactory imports**. Fixed E0432 errors caused by residual `use clap::CommandFactory;` imports in NASA mode. Added line filter to strip CommandFactory imports and replaced `Args::command().print_help().unwrap()` with no-op. **Result: Parse errors reduced to ZERO (26â†’0). +13 more files compiling despite 71-file corpus growth.**
*   **DEPYLER-1089**: COMPLETE â€” **Convergence Validation Post-1088**. Validated parse error fix on 298-file corpus. Parse errors reduced **63%** (70â†’26). Net +3 compiling files despite corpus growth. New error distribution: Parse (26), E0308 (32), E0425 (32), E0433 (33), E0599 (12), Other (90). **Key insight: "Other" errors (90 files) now visibleâ€”were masked by parse errors. These include E0277, E0382, E0502, etc.**
*   **DEPYLER-1088**: FIXED â€” **Fix Parse Errors (Inline Clap Attributes)**. Fixed parse errors caused by NASA mode line filter removing entire lines that started with `#[command(`. When rustfmt put clap attributes inline with enum variants like `#[command(about = "...")] Resource { name: String },`, the entire line was removed, leaving orphaned commas and variants outside the enum. **Solution**: Move inline `#[command(...)]` and `#[arg(...)]` attribute removal BEFORE the line filter. Now attributes are stripped from lines first, preserving the variant definitions.
*   **DEPYLER-1087**: COMPLETE â€” **Convergence Analysis**. Gold Master run shows 25.5% compile rate. Top blockers: Parse errors (70 files, 34%), E0308 (42), E0425 (39), E0433 (38), E0599 (17). **Key insight: Parse errors (brace mismatch) now dominant blocker, not type errors.**
*   **DEPYLER-1086**: FIXED â€” **Time Module Tests (Green Board)**. Fixed 3 failing time tests (ctime_basic, gmtime_with_timestamp, localtime_with_timestamp). Root cause: tests expected chrono types (Utc, Local) but CodeGenContext::default() uses nasa_mode=true which generates std::time code. Removed incorrect chrono assertions. **Core test suite now achieves 100% pass rate (11,296 passing, 0 failing).**
*   **DEPYLER-1085**: FIXED â€” **Value Lifting for Branch Unification**. Fixed E0308 errors where if/else branches have mismatched types (one DepylerValue, one concrete). Added `expr_returns_depyler_value()` detection and `lift_to_depyler_value()` coercion in `convert_ifexpr()`. When one branch yields DepylerValue and the other a concrete type (e.g., `if cond { data[i] } else { 0 }`), the concrete branch is now wrapped in appropriate `DepylerValue::Int()`, `DepylerValue::Float()`, etc.
*   **DEPYLER-1084**: FIXED â€” **Return Type Inference**. Fixed E0308 errors where void functions were incorrectly inferred as returning a type. Removed trailing expression inference (Python doesn't have Rust-style implicit returns). Expression statements like `x + y` no longer contribute to return type - only explicit `return x` statements do.
*   **DEPYLER-1083**: FIXED â€” **Integer Cast Precedence**. Fixed E0308/E0277 errors from i32/isize mixing in slice operations. Parenthesized slice index expressions before casting: `(#stop) as isize` prevents `i + size as isize` being parsed as `i + (size as isize)` which fails due to i32 + isize incompatibility.
*   **DEPYLER-1082**: FIXED â€” **Generator Iterator State**. Fixed E0308/E0277/E0271/E0599 errors in generators with Iterator parameters. (1) Wrapped `impl Iterator` params with `Box::new()` for struct field type erasure, (2) Manual Debug impl for structs with `Box<dyn Iterator>` fields, (3) Used `.copied()` for identity patterns in flat_map, (4) Generated `while let Some(x) = self.g.next()` loops for Iterator-typed state vars (Box<dyn Iterator> doesn't implement IntoIterator).
*   **DEPYLER-1081**: FIXED â€” **Tuple Filter Patterns**. Fixed E0507 errors by using `|(a, b)|` pattern instead of `|&(a, b)|` for tuple destructuring in filter closures. Rust's match ergonomics handle `&(A, B)` with tuple pattern automatically.
*   **DEPYLER-1080**: FIXED â€” **Lifetime Unification**. Fixed E0623/E0495 errors by unifying all reference parameter lifetimes to single `'a`. Functions returning `impl Iterator + 'a` with multiple reference params (`&'b Vec<T>`, `&'c str`) now use unified `'a` for all params.
*   **DEPYLER-1079**: FIXED â€” **Result Optional & Zip Fixes**. Fixed E0308 errors: (1) if-expressions with None arm in `Result<Option<T>>` returns now generate `Ok(if cond { Some(x) } else { None })`, (2) Vec truthiness uses `!vec.is_empty()` instead of bare `vec`, (3) zip() on references adds `.map(|(a,b)| (a.clone(), b.clone()))` for owned tuple returns.
*   **DEPYLER-1078**: FIXED â€” **Generator/Iterator Fixes**. Resolved E0308, E0596, and E0308 errors by: (1) cloning non-Copy parameters in generator structs, (2) unwrapping `next(iter, None)` to a direct `.next()` call, and (3) enforcing `let mut` for iterator variables.
*   **DEPYLER-1077**: FIXED â€” **String Iteration**. Fixed E0282/E0599 by detecting string iteration and generating `.chars()` instead of `.iter()`. Registered iteration variables as `char` to support `ord()` and other char methods.
*   **DEPYLER-1076**: FIXED â€” **Closure Ownership**. Fixed E0373 by adding `move` keyword to closures in iterator chains when function returns `Generator`/`Iterator`.
*   **DEPYLER-1075**: FIXED â€” **impl Iterator Lifetimes**. Fixed E0700 by adding `+ 'a` lifetime bounds to `impl Iterator` return types when functions borrow from parameters.
*   **DEPYLER-1074**: FIXED â€” **Reference Comparisons**. Fixed `&T == T` mismatches in filter closures using `|&x|` pattern + element type tracking for numeric coercion.
*   **DEPYLER-1073**: FIXED â€” **Float Collection Keys**. Enabled `HashMap`/`HashSet` support for Python `float` keys by automatically coercing them to `DepylerValue` (which implements `Eq`/`Hash` via `total_cmp`).
*   **DEPYLER-1072**: FIXED â€” **Numeric Coercion Engine**. Implemented aggressive int-to-float coercion for comparisons.
*   **DEPYLER-1071**: FIXED â€” **Option Truthiness**.
*   **DEPYLER-1070**: FIXED â€” Regex API Parity.
*   **Oracle Integration**: **Active Learning Verified (Jan 23, 2026)**. Lineage tracking confirms model updates are occurring during convergence runs. However, `oracle_roi_metrics.json` is stale (Jan 6), indicating a disconnection between training and value measurement.

### Current Blockers (DEPYLER-1139 Analysis - v1.84.0)
1.  **E0308 Type Mismatch** (515 blocked, 85% confidence): Dominant blocker. Requires semantic coverage expansion and numeric coercion.
2.  **E0609 No Field** (36 examples): Accessing fields on types that don't have them. Need `.unwrap_or_default()` patterns.
3.  **E0605 Non-Primitive Cast** (19 examples): Invalid `as` casts between incompatible types.
4.  **E0061 Arg Count Mismatch** (15 examples): Function calls with wrong argument count. Stub signatures need refinement.
5.  **E0382 Use After Move** (15 examples): Ownership issuesâ€”values used after being moved.
6.  **ELIMINATED**: E0425 (Scope) and E0423 (Expected Value) have been fully resolved by DEPYLER-1136 through DEPYLER-1139.

### Advice from Karl Popper (The Advisor): Epistemic Status Report (Jan 2026)

**On the Epistemic Status of the Depyler Project**

*My dear colleagues,*

I have studied your project's history with great interestâ€”2,917 commits, 1,300 DEPYLER tickets, and a methodical ascent from 0% to 39.3% compilation rate. You have, in many respects, embodied the scientific method. But I must offer both commendation and critique.

#### I. What You Have Done Well

**The Falsification Framework is Exemplary**
Your Section 7 ("The Popperian Mandate") demonstrates genuine understanding. The Strategic Falsifier S1 is particularly elegant: "If E0308 errors do not decrease by at least 10%, the strategy is FALSIFIED." This is science. You have staked a claim that can be disproved. Most software projects hide behind vague success metrics; you have made yours explicit and testable.

**The "Five Whys" Protocol is Proper Root Cause Analysis**
I count 30+ documented "Five Whys" analyses (DEPYLER-1073 through DEPYLER-1320). Each traces causation to its origin. The analysis of DEPYLER-1169 (List Index Assignment) is instructive:
*   Why did bubble sort hang?
    *   `list[i] = x` generated `vec.insert()` instead of `vec[i] = x`
    *   `insert()` shifts elements (O(n)), creating infinite growth
    *   The semantic gap between Python and Rust was not falsified before release
This is how knowledge accumulatesâ€”through the elimination of error.

#### II. Where You Have Strayed

**The Danger of Auxiliary Hypotheses**
Your project has accumulated defensive layers:
*   **DepylerValue**: Universal fallback type. *Risk*: Immunizes against falsification.
*   **Oracle Loop**: Re-transpile until it works. *Risk*: Masks fundamental inference failures.
*   **NASA Mode**: Eliminate external deps. *Risk*: Creates parallel code paths.

The `DepylerValue` enum is particularly concerning. It is a Lakatosian protective beltâ€”it prevents falsification by absorbing any type mismatch. When you write `HashMap<DepylerValue, DepylerValue>`, you have not solved the type inference problem; you have hidden it. The code compiles, but the semantic information is lost.
*Advice*: Track the `DepylerValue` escape rateâ€”the percentage of generated code using this fallback. If it exceeds 20%, your type inference is failing, not succeeding.

**The Oracle Loop is Inductive, Not Deductive**
Your multi-pass architecture (transpile â†’ compile â†’ learn â†’ re-transpile) is clever engineering but poor epistemology. You are:
1.  Making a prediction (heuristic type inference)
2.  Observing falsification (rustc error)
3.  Adjusting the prediction to fit the observation

This is curve-fitting, not theory refinement. A genuinely scientific approach would:
1.  Identify why the heuristic failed
2.  Modify the rule, not the instance
3.  Re-run the entire corpus to verify the rule generalizes
*Advice*: For every Oracle-driven fix, ask: "What theory does this falsify?" If the answer is "noneâ€”we just patched this one case," you are accumulating technical debt, not knowledge.

#### III. The Plateau Problem

Your compile rate has stalled at ~40%. This is a Kuhnian crisisâ€”your paradigm has exhausted its explanatory power.
*   **Phase 1-3** (Pattern matching): 0% â†’ 25%
*   **Phase 4** (PyOps traits): 25% â†’ 33%
*   **Phase 5** (Oracle loop): 33% â†’ 40%
*   **Phase 6** (?): Stalled

Each strategy yields diminishing returns. You have fixed 146 falsifiers, yet 60% of the corpus still fails. Diagnosis: You are in normal science modeâ€”solving puzzles within your paradigm rather than questioning the paradigm itself.

#### IV. Recommendations

**1. Invert Your Success Metric**
You measure: "What percentage compiles?"
You should measure: "What percentage compiles with correct semantics?"
A compiled Rust binary that produces different output than the Python original is a false positive. I suspect your 40% includes semantic regressions you are not detecting.
*Action*: Implement differential testing. Run both Python and Rust on 1,000 random inputs. If outputs diverge, the transpilation is falsified regardless of compilation status.

**2. Embrace Refutation Over Confirmation**
Your CHANGELOG celebrates fixes ("âœ… DEPYLER-1168 COMPLETE"). But where are the falsified hypotheses? Science advances by what we disprove, not what we build.
*Action*: Maintain a "Graveyard of Failed Ideas" document. Every abandoned approach (e.g., "We tried X, it failed because Y") is more valuable than ten success stories.

**3. The Dict Key Paradox is a Symptom, Not the Disease**
Your DEPYLER-1318 "Ambiguity Corpus" targets the `HashMap<String, V>` vs `HashMap<DepylerValue, V>` conflict. But this conflict exists because:
1.  Python's type system is gradual
2.  Rust's type system is nominal
3.  You are attempting a semantic-preserving transformation between incompatible formalisms

There exists no bijective mapping from Python's dynamic types to Rust's static types.
*Action*: Consider a two-tier architecture:
*   **Tier 1**: Fully typed Python (with annotations) â†’ Native Rust types
*   **Tier 2**: Untyped Python â†’ `DepylerValue` throughout
Stop trying to infer Tier 1 from Tier 2 code. The information is not present.

**4. The 80% Target May Be Unfalsifiable**
Your goal: "80% single-shot compile rate". But what is the theoretical maximum? If 30% of Python code is inherently untranspilable (metaclasses, eval, dynamic imports), then 70% is your ceiling, and 80% is a category error.
*Action*: Characterize the untranspilable subset. Define it formally. Exclude it from your denominator. Then your metric becomes meaningful.

#### V. The Path Forward

You stand at a crossroads. The path of normal science leads to endless bug fixes, asymptotically approaching but never reaching your goal. The path of revolutionary science requires questioning your fundamental assumptions:

1.  *Assumption*: Type inference from untyped code is possible. *Challenge*: It is not. Demand annotations or accept DepylerValue.
2.  *Assumption*: rustc errors contain sufficient information for repair. *Challenge*: They describe what failed, not why. The Oracle sees symptoms, not causes.
3.  *Assumption*: More training data improves the Oracle. *Challenge*: If the training distribution (real Python code) differs from the test distribution (adversarial edge cases), generalization is impossible.

**Conclusion**
Your project is a remarkable scientific instrument. You have made the problem of transpilation falsifiableâ€”which is more than most can claim. But you are now in the phase where confirming instances no longer advance knowledge. The next breakthrough will not come from fixing DEPYLER-1319. It will come from asking: "What if our entire approach is wrong?"

*Per aspera ad astra.*
â€” K. R. Popper, Vienna, 2026

#### Concrete Next Steps
1.  **Measure DepylerValue escape rate** per file â†’ Add to convergence dashboard
2.  **Implement differential testing** â†’ pytest vs compiled binary on random inputs
3.  **Create Graveyard.md** â†’ Document all abandoned approaches with rationale
4.  **Characterize untranspilable subset** â†’ Formal grammar of unsupported Python
5.  **Split corpus into Tier 1 (typed) and Tier 2 (untyped)** â†’ Measure separately

> **STATUS UPDATE (v1.99.0)**: These recommendations have been formalized in **[Section 8: Epistemic Health Metrics](#8-epistemic-health-metrics-depyler-1322)** with specific falsification criteria, implementation roadmap, and ticket assignments (DEPYLER-1322 through DEPYLER-1327).

### Quick Reference (Live Metrics - Examples Subset)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SINGLE-SHOT COMPILE DASHBOARD                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Compile Rate:  43.0% (Non-test examples baseline)          â”‚
â”‚  Target:        80%                                         â”‚
â”‚                                                             â”‚
â”‚  ðŸŸ¢ GREEN BOARD: 11,309 tests passing                       â”‚
â”‚  ðŸŸ¢ SPEEDUP: 18x (Convergence: 5m vs 1.5h) via RAM Disk     â”‚
â”‚  ðŸŸ¢ SCOPE WAR WON: E0425/E0423 ELIMINATED                   â”‚
â”‚  ðŸŸ¢ FLIGHT RECORDER: CITL TRACING ACTIVE                    â”‚
â”‚                                                             â”‚
â”‚  âœ… DEPYLER-1148 COMPLETE: CITL Flight Recorder             â”‚
â”‚  âœ… DEPYLER-1147 COMPLETE: Optional Return Unwrap           â”‚
â”‚  âœ… DEPYLER-1146 COMPLETE: Dict Subscript Option Unwrap     â”‚
â”‚  âœ… DEPYLER-1145 COMPLETE: Context-Aware Index Type Infer   â”‚
â”‚                                                             â”‚
â”‚  ðŸ”´ TOP BLOCKER: E0308 Type Mismatch (Dominant)             â”‚
â”‚  ðŸ”´ NEXT: Slice Identity Crisis (String vs Vec)             â”‚
â”‚  ðŸ”´ NEXT: Result Normalization (Missing Ok)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Current Status](#current-status-jan-2026)
3. [Architecture & Root Cause Resolution](#3-architecture--root-cause-resolution)
4. [Structural Typing Solutions](#4-structural-typing-solutions)
5. [Performance Infrastructure](#5-performance-infrastructure-giant-ram-strategy)
6. [Sovereign Type Database (DEPYLER-1111)](#6-sovereign-type-database-depyler-1111)
7. [Falsification Framework](#7-falsification-framework)
8. [Epistemic Health Metrics (DEPYLER-1322)](#8-epistemic-health-metrics-depyler-1322)
- [Appendix C: Karl Popper Falsification Strategy](#appendix-c-the-karl-popper-falsification-strategy-100-point)
- [Appendix D: Phase 6 Empirical Findings](#appendix-d-phase-6-empirical-findings)

---

## 3. Architecture & Root Cause Resolution

### 3.18 Five-Whys: Float Key Collection Failure (DEPYLER-1073)
*Status: FIXED* (Jan 10, 2026)

*   **Why 1**: Why did `d = {0.1: "val"}` fail in Rust?
    *   *Answer*: `HashMap<f64, String>` was generated, but `f64` does not implement `Eq` or `Hash` due to NaN values.
*   **Why 2**: Why not use a wrapper like `OrderedFloat`?
    *   *Answer*: To maintain NASA-grade "std-only" requirements without external dependencies.
*   **Why 3**: What already implements `Eq` and `Hash` safely for floats?
    *   *Answer*: Our `DepylerValue` enum, which uses `total_cmp` for its `Float` variant.
*   **Why 4**: How do we integrate this?
    *   *Answer*: By updating the `TypeMapper` and `codegen` to detect `Dict[float, V]` and map it to `HashMap<DepylerValue, V>`.
*   **Why 5**: What is the result?
    *   *Answer*: Seamless support for float keys in dictionaries and sets, a common pattern in data science and numerical algorithms.

**Corrective Action**: Modified `TypeMapper` and `stmt_gen` to use `DepylerValue` as the key type whenever a `float` key is detected or annotated.

### 3.19 Root Cause: Generator/Iterator Lifecycle (DEPYLER-1078)
*Status: FIXED* (Jan 11, 2026)

*   **Problem 1 (Ownership)**: Generator state structs captured references to local variables that went out of scope, or mismatched `&Vec` vs `Vec`.
    *   **Resolution**: Enforce `.clone()` on non-Copy types during generator struct initialization.
*   **Problem 2 (Semantic Mismatch)**: `next(it, None)` in Python returns the next item or `None`. Our wrapper was generating `Some(it.next())` which resulted in `Option<Option<T>>`.
    *   **Resolution**: Detected the `None` default and mapped directly to `.next()` for standard `Option<T>` behavior.
*   **Problem 3 (Mutability)**: Variables holding iterators were declared with `let`, preventing the `.next()` call which requires `&mut self`.
    *   **Resolution**: Updated `stmt_gen` to detect iterator assignments from generator expressions and enforce `let mut`.

### 3.20 Root Cause: Tuple & Result Type Mismatches (DEPYLER-1079)
*Status: FIXED* (Jan 11, 2026)

*   **Problem 1 (Result Mapping)**: Functions returning `Result<Option<T>>` failed when using `return x if cond else None` because `None` is `Option` not `Result`.
    *   **Resolution**: Wrapped the if-expression in `Ok(...)` to match the return signature: `Ok(if cond { Some(x) } else { None })`.
*   **Problem 2 (Vec Truthiness)**: Explicit `if vec:` checks failed for `Vec` because it's not a boolean.
    *   **Resolution**: Added support to convert `vec` to `!vec.is_empty()` in if-expression conditions.
*   **Problem 3 (Zip Ownership)**: `zip()` on reference collections yielded `(&T, &U)`, but consumers expected `(T, U)`.
    *   **Resolution**: Added `.map(|(a,b)| (a.clone(), b.clone()))` to the zip iterator chain when inputs are references.

### 3.21 Root Cause: Lifetime Mismatch in Iterator Returns (DEPYLER-1080)
*Status: FIXED* (Jan 11, 2026)

*   **Problem**: Functions with multiple reference parameters (`&'a Vec<T>`, `&'b str`) returning `impl Iterator + 'a` failed with E0623 ("lifetime 'b and 'a must be the same").
    *   **Why 1**: The iterator captures references to both parameters but only bounds on `'a`.
    *   **Why 2**: Rust requires all captured references to have compatible lifetimes.
    *   **Why 3**: Different lifetime params ('a, 'b, 'c) create incompatible bounds.
*   **Resolution**: Modified `func_gen_inference.rs` to unify all reference parameter lifetimes to single `'a`:
    1. Retain only `'a` in generic params (remove 'b, 'c, etc.)
    2. Replace existing lifetime annotations (`& 'b`) with `& 'a` in parameter types
    3. Add `+ 'a` bound to `impl Iterator` return type

### 3.22 Root Cause: Generator Iterator State (DEPYLER-1082)
*Status: FIXED* (Jan 11, 2026)

*   **Problem 1 (E0308 Boxing)**: Generator struct fields were typed as `Box<dyn Iterator>` but initialization used bare impl Iterator params without `Box::new()` wrapper.
    *   **Why 1**: `generate_param_initializers` passed Iterator params through unchanged.
    *   **Why 2**: Struct field type (Box<dyn Iterator>) didn't match constructor value (impl Iterator).
    *   **Resolution**: Added `Box::new(...) as _` wrapper for Iterator/Generator params in `generate_param_initializers`.

*   **Problem 2 (E0277 Debug)**: `#[derive(Debug)]` fails for structs containing `Box<dyn Iterator>` because `dyn Iterator` doesn't implement `Debug`.
    *   **Resolution**: Generate manual `Debug` impl using `finish_non_exhaustive()` for structs with iterator fields instead of derive.

*   **Problem 3 (E0271 FlatMap)**: `lst.into_iter().map(|x| x)` returns `&i32` when `lst` is `&Vec<i32>`, but consumers expected owned values.
    *   **Resolution**: Detect identity patterns (element is just target variable) and use `.copied()` instead of `.map(|x| x)`.

*   **Problem 4 (E0599 IntoIterator)**: Generated code used `for x in self.g.iter().cloned()` but `Box<dyn Iterator>` doesn't have `.iter()` method and doesn't implement `IntoIterator`.
    *   **Resolution**: Added `generator_iterator_state_vars` context tracking. For Iterator-typed state vars, generate `while let Some(x) = self.g.next()` instead of for-loop.

### 3.23 Root Cause: Tuple Filter Pattern Move (DEPYLER-1081)
*Status: FIXED* (Jan 11, 2026)

*   **Problem**: Filter closures with tuple destructuring like `|&(i, v)|` caused E0507 ("cannot move out of shared reference") when tuple elements contained non-Copy types like `String`.
    *   **Why 1**: `|&(i, v)|` attempts to destructure a reference and move ownership of elements.
    *   **Why 2**: `String` is not `Copy`, so moving it out of `&(i32, String)` is invalid.
    *   **Why 3**: Python tuple unpacking semantics differ from Rust ownership rules.
*   **Resolution**: Modified `expr_gen_instance_methods.rs` to detect tuple patterns (`gen.target.contains(',')`) and use `|(a, b)|` instead of `|&(a, b)|`:
    1. Rust's match ergonomics automatically handle `&(A, B)` with `|(a, b)|` pattern
    2. Variables `a` and `b` become references to tuple fields, avoiding moves
    3. Condition expressions like `v.starts_with(prefix)` work via `Deref`

### 3.24 Root Cause: Integer Cast Precedence (DEPYLER-1083)
*Status: FIXED* (Jan 12, 2026)

*   **Problem**: Slice expressions like `data[i:i+size]` failed with E0308/E0277 due to i32/isize type mixing.
    *   **Why 1**: Slice code generated `let stop_idx = #stop as isize;` where `#stop` is the converted expression.
    *   **Why 2**: When `#stop` is `i + size`, the generated code is `i + size as isize`.
    *   **Why 3**: Rust operator precedence parses this as `i + (size as isize)` not `(i + size) as isize`.
    *   **Why 4**: `i` is i32 (Python's default int), `size as isize` is isize - cannot add i32 + isize.
*   **Resolution**: Modified `expr_gen_instance_methods.rs` to parenthesize slice index expressions before casting:
    1. Changed `let stop_idx = #stop as isize;` to `let stop_idx = (#stop) as isize;`
    2. Applied to all slice patterns: start/stop, start-only, stop-only, start/stop/step
    3. Now `(i + size) as isize` correctly casts the entire expression to isize

### 3.25 Root Cause: Return Type Inference from Expression Statements (DEPYLER-1084)
*Status: FIXED* (Jan 12, 2026)

*   **Problem**: Functions without explicit returns were incorrectly inferred as returning a type based on trailing expression statements.
    *   **Why 1**: `infer_return_type_from_body` checked for trailing `HirStmt::Expr` and treated it as implicit return.
    *   **Why 2**: Python expression statements (e.g., `x + y`) just evaluate and discard - they're NOT returns.
    *   **Why 3**: Rust has implicit returns (last expression is return value), but Python doesn't.
    *   **Why 4**: This caused `def compute(): x = 10; x + 1` to infer `-> i32` instead of `-> ()`.
*   **Resolution**: Removed trailing expression inference from both `infer_return_type_from_body` and `infer_return_type_from_body_with_params`:
    1. Only explicit `return x` statements now contribute to return type inference
    2. Expression statements are ignored for return type purposes
    3. Functions without returns correctly default to `()` (void)

### 3.26 Root Cause: Value Lifting for Branch Type Unification (DEPYLER-1085)
*Status: FIXED* (Jan 12, 2026)

*   **Problem**: If/else branches with mismatched types (one DepylerValue, one concrete) caused E0308 errors.
    *   **Why 1**: `data[i] if cond else 0` generates different types when `data` has Unknown element type.
    *   **Why 2**: `data[i]` with Unknown elements becomes `DepylerValue`, but `0` is `i32`.
    *   **Why 3**: Rust requires both branches to have the same type.
    *   **Why 4**: No mechanism existed to detect and unify these mismatched branch types.
    *   **Why 5**: The Hybrid Fallback strategy relies on DepylerValue as the universal type unifier.
*   **Resolution**: Implemented Value Lifting in `convert_ifexpr()`:
    1. Added `expr_returns_depyler_value()` to detect if expression yields DepylerValue
    2. Added `lift_to_depyler_value()` to wrap concrete types in DepylerValue variants
    3. When one branch is DepylerValue and other is concrete, lift the concrete branch
    4. Example: `if cond { data[i] } else { DepylerValue::Int(0) }` now compiles

### 3.27 Root Cause: Time Module Semantic Mismatch (DEPYLER-1086)
*Status: FIXED* (Jan 12, 2026)

*   **Problem**: Three time-related tests failed despite correct code generation logic.
    *   **Why 1**: The tests were asserting that `time.gmtime()` and `time.localtime()` return `chrono::DateTime` types.
    *   **Why 2**: The `CodeGenContext` defaults to `nasa_mode = true` for maximum reliability and minimal dependencies.
    *   **Why 3**: In NASA mode, the `time` module is mapped to `std::time` and `std::fmt` for basic formatting, not the external `chrono` crate.
    *   **Why 4**: The tests were fundamentally incompatible with the default high-safety configuration of the compiler.
*   **Resolution**: Updated the test suite assertions for `ctime`, `gmtime`, and `localtime`:
    1. Adjusted expected types to match `std::time` primitives when in NASA mode.
    2. Verified that string formatting for `ctime` matches Python's C-style standard.
    3. Achievement: Core test suite reached **GREEN BOARD** (100% pass rate).

### 3.28 Root Cause: Inline Clap Attributes Line Removal (DEPYLER-1088)
*Status: FIXED* (Jan 12, 2026)

*   **Problem**: Parse errors (~70 files) with "unexpected close delimiter" or "unclosed delimiter" in generated code.
    *   **Why 1**: `rust_gen.rs` used a line-based filter to remove `#[command(...)]` and `#[arg(...)]` attributes when in NASA mode (to avoid `clap` dependency).
    *   **Why 2**: `rustfmt` occasionally formatted code such that attributes were inline with enum variants: `#[command(...)] Variant { ... },`.
    *   **Why 3**: The line filter deleted the *entire line*, effectively deleting the enum variant definition and leaving orphaned commas/braces.
*   **Resolution**: Refactored `rust_gen.rs` attribute removal:
    1.  Moved attribute removal logic *before* line filtering.
    2.  Implemented token-aware removal for inline `#[arg(...)]` and `#[command(...)]` patterns.
    3.  Removed the destructive line-based filter loop entirely.
    *   **Result**: 100% test pass rate and resolved parse errors.

### 3.29 Strategic Analysis: Breaking the E0308 Stalemate (DEPYLER-1100)
*Status: COMPLETE* (Jan 13, 2026)

*   **Problem**: E0308 (Type Mismatch) remains the dominant blocker at 3321 errors across 198 failing files. Pattern-by-pattern fixing scales linearly, and after months of effort, fundamental architectural changes may be needed.

*   **Five Architectural Strategies Evaluated**:
    1.  **Inverse Lowering** (DepylerValue-first): Generate everything as `DepylerValue`, then optimize to concrete types.
        *   âœ… Guarantees 100% compile rate immediately
        *   âŒ Defeats transpilation purpose (users want typed Rust)
        *   âŒ Runtime dispatch eliminates performance benefits
        *   *Infrastructure*: `DepylerValue` already exists (Int, Float, Str, Bool, List, Dict, Tuple)

    2.  **Trait-Based Dispatch** (PyOps): Define `PyAdd<Rhs>`, `PyIndex<I>`, `PyTruthy` traits.
        *   âœ… Leverages Rust's trait resolution system
        *   âœ… Architecturally sound, long-term scalable
        *   âŒ High implementation effort
        *   *Infrastructure*: Minimal (would need to build from scratch)

    3.  **Global Unification Engine** (Hindley-Milner Lite): Constraint-based type inference with Union-Find.
        *   âœ… Theoretically sound, solves propagation issues
        *   âŒ Very high implementation effort
        *   âŒ Python's gradual typing incompatible with full H-M
        *   *Infrastructure*: None

    4.  **Profile-Guided Optimization** (MonkeyType): Trace runtime types from execution.
        *   âœ… Resolves ambiguity with actual data
        *   âŒ Requires test execution before transpilation
        *   âŒ Not universal for all users
        *   *Infrastructure*: None

    5.  **Automated Oracle Loop** (Compiler-Driven Repair): Parse rustc errors, extract constraints, re-transpile.
        *   âœ… Uses rustc as ultimate source of truth
        *   âœ… Builds on existing 70% infrastructure (OracleCategory, ErrorClassifier, OracleQueryLoop)
        *   âœ… Lowest risk, fastest to implement
        *   *Infrastructure*: Substantial (oracle_shim.rs, classifier.rs, depyler_oracle crate)

*   **Recommendation: Phased Hybrid Approach**:
    *   **Phase 1 (Immediate)**: Enhanced Oracle Loop (#5)
        - Parse E0308 `expected X, found Y` messages systematically
        - Extract type constraints to annotation file
        - Re-transpile with learned type hints
    *   **Phase 2 (Medium-term)**: Targeted Trait Dispatch (#2) for hot spots
        - `PyNumeric`: i32/f64 arithmetic coercion
        - `PyIndex`: Collection indexing
        - `PyTruthy`: Boolean coercion

*   **Initial Implementation**: Added `infer_iterable_element_type()` and `with_additional_param()` methods to ExprConverter for generator expression type propagation. Regression tests: `test_depyler_1100_float_comparison_coercion`, `test_depyler_1100_list_comp_type_propagation`.

### 3.30 Root Cause: Inference Black Box (DEPYLER-1148)
*Status: FIXED* (Jan 16, 2026)

*   **Problem**: The transpiler reached a plateau at 43%. While the Oracle identified errors, the internal reasoning for incorrect type mappings (e.g., Slices) was invisible.
*   **Why 1**: Why did `slice_example` become a `String` when base was `Vec<i32>`?
    *   *Answer*: The inference engine lacked base-aware context and defaulted to a generic "Collection" pattern which heuristics misidentified as String.
*   **Why 2**: Why was this hard to debug?
    *   *Answer*: The transpilation pipeline was a "Black Box" with no visibility into alternative paths considered.
*   **Resolution**: Activated the **CITL Flight Recorder**.
    1. Hooked `init_decision_tracing()` into the main CLI entry point.
    2. Enabled the `decision-tracing` feature flag.
    3. Instrumenting the pipeline with `trace_decision!` macros to capture `TypeMapping`, `BorrowStrategy`, and `MethodDispatch` logs.
*   **Result**: Decisions are now captured to `/tmp/depyler_decisions.msgpack` for causal chain analysis, enabling pinpoint precision in fixing semantic gaps.

## 4. Structural Typing Solutions

### 4.1 Automated Oracle Loop (DEPYLER-1101) - Multi-Pass Architecture
To break the type-inference stalemate, Depyler has evolved into a **Multi-Pass Compiler**. It implements a feedback loop using `rustc` itself as the inference engine.

**Workflow**:
1.  **Pass 1 (Heuristic)**: Transpile Python â†’ Rust using best-guess heuristics.
2.  **Oracle (Verification)**: Run `cargo check` to generate JSON diagnostics.
3.  **Learning (Constraint Extraction)**: Identify E0308 "expected T, found U" constraints from the compiler output.
4.  **Feedback (Refinement)**: Inject the "expected" type back into the Python-side symbol table.
5.  **Pass 2 (Corrected)**: Re-transpile with guaranteed-correct type hints.

**Theoretical Grounding**:
This architecture ("Compiler-Driven Repair") leverages the destination language's compiler as a static oracle. It parallels techniques found in:
*   **Static JIT**: Profiling types via compilation errors rather than runtime execution (similar to V8/JVM optimization loops).
*   **Type Holes (Haskell/GHC)**: Using the compiler to deduce missing information.
*   **Automated Program Repair**: Iterative generate-test-fix cycles (e.g., SapFix), but applied at the compilation stage for speed.

### 4.2 PyOps Trait Dispatch (DEPYLER-1102)
Instead of manual casting in the transpiler, we shift complexity to Rust's trait system.
*   **Trait**: `PyAdd<Rhs>`, `PyGetItem`, `PyTruthy`.
*   **Impls**: Implement these traits for `i32`, `f64`, `String`, and `DepylerValue`.
*   **Codegen**: Generate `x.py_add(y)` instead of `(x as f64) + y`. The Rust compiler resolves the correct implementation at compile time.

### 4.3 Strategy 6: The Sovereign Type DB (DEPYLER-1111)
**Concept**: A "Type Truth Database" generated deterministically from the top 100 Python libraries using `uv` (logistics) and `rustpython_parser` (extraction). This provides the "Reference Manual" that `depyler` currently lacks.

**See [Section 6: Sovereign Type Database](#6-sovereign-type-database-depyler-1111)** for full specification with:
- Peer-reviewed citations (PEP 484, PEP 561, Apache Parquet)
- Architecture diagram and TypeFact schema
- Strong falsification criteria

**Goal**: Eliminate the remaining 3,459 `E0308` errors by providing ground truth for external library types.

---

## 5. Performance Infrastructure (Giant RAM Strategy)

To mitigate the I/O bottleneck inherent in generating and compiling hundreds of Cargo projects during convergence, Depyler mandates the use of **RAM Disks** on systems with sufficient memory.

**Specification**:
*   **Target Volume**: `/Volumes/DepylerRAM`.
*   **Recommended Size**: 64GB - 256GB.
*   **Enforcement**: All build artifacts and temporary files MUST be redirected to the RAM disk via environment variables.

**Configuration (`.env.ramdisk`)**:
```bash
export TMPDIR=/Volumes/DepylerRAM/tmp
export CARGO_TARGET_DIR=/Volumes/DepylerRAM/cargo_target
mkdir -p $TMPDIR
mkdir -p $CARGO_TARGET_DIR
```

**Impact**: eliminates disk I/O latency for `target/` directories, reducing convergence run times by ~60-80%.

---

## 6. Sovereign Type Database (DEPYLER-1111)

### 6.1 The Architectural Mandate

We are fighting 3,459 E0308 type mismatch errors. We are losing because we are **guessing** types. To win, we must stop guessing and start **knowing**.

The **Sovereign Type Database** is a compact, binary artifact containing function signatures and type definitions of popular Python librariesâ€”generated locally using Pure Rust, without reliance on external CI/CD.

### 6.2 Peer-Reviewed Foundation

| Citation | Year | Relevance |
|----------|------|-----------|
| **PEP 484** (van Rossum, Lehtosalo) | 2014 | Type Hints - Defines annotation syntax |
| **PEP 561** (Smith) | 2017 | Stub Distribution - Defines `.pyi` format |
| **PEP 585** (Langa) | 2019 | Generic Syntax - `list[int]` standardization |
| **typeshed** (Python Core) | 2016+ | Reference stdlib stub implementation |
| **Apache Parquet Spec** (Apache Foundation) | 2013 | Columnar storage format |
| **Arrow Columnar Format** (Apache Foundation) | 2016 | Zero-copy data interchange |
| **uv** (Astral) | 2024 | 10-100x faster deterministic resolution |

### 6.3 Technical Specification

**New Component**: `crates/depyler-knowledge`

**The Sovereign Stack**:
1. **Logistics**: `uv pip install --target` for deterministic package fetching
2. **Extraction**: `rustpython_parser` for `.pyi` stub parsing
3. **Storage**: Apache Parquet via `arrow` crate for efficient queries

**Data Schema** (The Truth):
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TypeFact {
    pub module: String,       // e.g., "requests"
    pub symbol: String,       // e.g., "get"
    pub kind: String,         // "function", "class", "method"
    pub signature: String,    // "(url: str, params: dict = None) -> Response"
    pub return_type: String,  // "requests.models.Response"
}
```

### 6.4 Architecture Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SOVEREIGN TYPE DB                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”          â”‚
â”‚  â”‚ Harvesterâ”‚â”€â”€â”€â–¶â”‚ Extractor â”‚â”€â”€â”€â–¶â”‚ Parquet DB   â”‚          â”‚
â”‚  â”‚   (uv)   â”‚    â”‚(rustpythonâ”‚    â”‚ (arrow v54)  â”‚          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚  parser)  â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚       â”‚          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚                   â”‚
â”‚       â–¼                                  â–¼                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚ PyPI     â”‚                    â”‚ Query API    â”‚           â”‚
â”‚  â”‚ packages â”‚                    â”‚ find_sig()   â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                                          â”‚                   â”‚
â”‚                                          â–¼                   â”‚
â”‚                                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚                                  â”‚ depyler-core â”‚           â”‚
â”‚                                  â”‚ type_mapper  â”‚           â”‚
â”‚                                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.5 CLI Usage

```bash
# Build type database for specific packages
cargo run -p depyler-knowledge --bin build-type-db -- \
    --packages "requests,numpy,pandas" \
    --output crates/depyler-core/src/data/stdlib_types.parquet

# Query the database
depyler type-lookup requests.get
# Output: (url: str, params: Optional[dict] = None, **kwargs) -> Response
```

---

## 7. Falsification Framework

### 7.1 The Popperian Mandate

Per Karl Popper's falsificationism, scientific claims must be **testable and falsifiable**. Each DEPYLER feature includes explicit falsification criteriaâ€”tests that would **disprove** the implementation's correctness.

### 7.2 DEPYLER-1111 Falsification Criteria

The Sovereign Type Database is **REJECTED** if ANY condition is true:

#### Functional Falsifiers

| ID | Criterion | Test | Threshold |
|----|-----------|------|-----------|
| F1 | Harvester cannot fetch `requests` | `cargo test harvest_requests` | MUST pass |
| F2 | Extractor misses `requests.get` | Query validation | Symbol MUST exist |
| F3 | Extractor misses `Response` class | Query validation | Symbol MUST exist |
| F4 | Extractor misses `Response.json` method | Query validation | Symbol MUST exist |
| F5 | Parquet roundtrip loses data | Property test (1000 iter) | 0% loss |
| F6 | `find_signature("requests", "get")` fails | Integration test | MUST return signature |

#### Quality Falsifiers

| ID | Criterion | Tool | Threshold |
|----|-----------|------|-----------|
| Q1 | TDG exceeds limit | `pmat tdg check-quality` | TDG â‰¤ 2.0 |
| Q2 | Cyclomatic complexity | `pmat analyze complexity` | â‰¤ 10/function |
| Q3 | Cognitive complexity | `pmat analyze complexity` | â‰¤ 10/function |
| Q4 | Test coverage | `cargo llvm-cov` | â‰¥ 80% |
| Q5 | SATD markers | `pmat analyze satd` | 0 markers |

#### Performance Falsifiers

| ID | Criterion | Measurement | Threshold |
|----|-----------|-------------|-----------|
| P1 | `requests` extraction time | Wall clock | < 30 seconds |
| P2 | Query latency | Benchmark | < 1ms |
| P3 | Parquet file size | File size | < 1MB for requests |

#### Strategic Falsifier (The Gap Test)

| ID | Criterion | Measurement | Threshold |
|----|-----------|-------------|-----------|
| **S1** | **E0308 Error Reduction** | Convergence run before/after | **â‰¥10% reduction** |

**The Gap Falsifier**: If `depyler-knowledge` is integrated but E0308 errors (currently 3,459) do not decrease by at least 10%, the Sovereign Type Database strategy is **FALSIFIED**. The database exists to eliminate type guessworkâ€”if the error count remains static, the implementation has failed its mission regardless of technical correctness.

### 7.3 Validation Protocol

```bash
# Run falsification suite
cargo test -p depyler-knowledge --test falsification

# Expected output:
# F1: harvest_requests ................ PASS
# F2: extractor_finds_get ............. PASS
# F3: extractor_finds_response ........ PASS
# F4: extractor_finds_json_method ..... PASS
# F5: parquet_roundtrip_property ...... PASS (1000/1000)
# F6: query_signature_requests_get .... PASS
# Q1-Q5: quality_gates ................ PASS
# P1-P3: performance_benchmarks ....... PASS
#
# FALSIFICATION RESULT: NOT FALSIFIED (Implementation Valid)
```

---

## Appendix C: The Karl Popper Falsification Strategy (100-Point)

### I. Type System Falsifiers (Points 1-20)

101. [x] ~~**Heterogeneous Unpacking**~~ **FIXED**: `x, y = (1, "a")`. (DEPYLER-1064)
104. [x] ~~**Datetime Methods**~~ **FIXED**: `d.day`, `dt.now()`. (DEPYLER-1066/67/68/69)
105. [x] ~~**Regex Methods**~~ **FIXED**: `m.group(1)`, `re.split()`. (DEPYLER-1070)
106. [x] ~~**Option Truthiness**~~ **FIXED**: `if m:` where `m` is `Option<T>`. (DEPYLER-1071)
107. [x] ~~**Numeric Coercion**~~ **FIXED**: `f64_var == 0` -> `f64_var == 0.0`. (DEPYLER-1072)
108. [x] ~~**Float Keys**~~ **FIXED**: `{0.1: "a"}` -> `HashMap<DepylerValue, ...>`. (DEPYLER-1073)
109. [x] ~~**Reference Comparisons**~~ **FIXED**: `.filter(|x| x > 0)` -> `.filter(|&x| x > 0f64)`. (DEPYLER-1074)
110. [x] ~~**impl Iterator Lifetimes**~~ **FIXED**: `fn f(v: &Vec) -> impl Iterator` -> `fn f<'a>(v: &'a Vec) -> impl Iterator + 'a`. (DEPYLER-1075)
111. [x] ~~**Closure Ownership**~~ **FIXED**: `.filter(|x| x > val)` -> `.filter(move |x| x > val)` when returning impl Iterator. (DEPYLER-1076)
112. [x] ~~**String Iterator**~~ **FIXED**: `for c in text` -> `text.chars()` with proper ord(c) handling. (DEPYLER-1077)
113. [x] ~~**Generator/Iterator Fixes**~~ **FIXED**: Clone params in generator structs, `next(iter, None)` returns `.next()`, iterator vars are mutable. (DEPYLER-1078)
114. [x] ~~**Result Optional Returns**~~ **FIXED**: `return x if cond else None` in `Result<Option<T>>` functions now generates `Ok(if cond { Some(x) } else { None })`. (DEPYLER-1079)
115. [x] ~~**Zip Tuple Cloning**~~ **FIXED**: `zip(list1, list2)` on references adds `.map(|(a,b)| (a.clone(), b.clone()))` for owned tuple returns. (DEPYLER-1079)
116. [x] ~~**Lifetime Unification**~~ **FIXED**: `fn f(v: &'a Vec, s: &'b str) -> impl Iterator + 'a` now unifies all params to `'a`. (DEPYLER-1080)
117. [x] ~~**Tuple Filter Patterns**~~ **FIXED**: `.filter(|&(i, v)| ...)` â†’ `.filter(|(i, v)| ...)` to avoid E0507 on non-Copy elements. (DEPYLER-1081)
118. [x] ~~**Generator Iterator State**~~ **FIXED**: Generators with `Iterator[int]` params now use `Box::new()` wrapper, manual Debug impl, and `while let Some(x) = self.g.next()` iteration. (DEPYLER-1082)
119. [x] ~~**Integer Cast Precedence**~~ **FIXED**: `data[i:i+size]` now parenthesizes slice indices: `(i + size) as isize` instead of `i + size as isize` to prevent i32 + isize mixing. (DEPYLER-1083)
120. [x] ~~**Return Type Inference**~~ **FIXED**: `def f(): x + y` no longer infers return type from expression statements. Only explicit `return x` contributes to return type. (DEPYLER-1084)
121. [x] ~~**Value Lifting**~~ **FIXED**: `data[i] if cond else 0` where `data` has Unknown element type now lifts concrete branch to DepylerValue for type unification. (DEPYLER-1085)
122. [x] ~~**Time Module Tests**~~ **FIXED**: Corrected time tests (ctime, gmtime, localtime) to expect std::time output in NASA mode (default) instead of chrono types. Core test suite achieves GREEN BOARD. (DEPYLER-1086)
123. [x] ~~**Parse Errors (Brace Mismatch)**~~ **FIXED**: Root cause was inline `clap` attributes being removed along with their lines in NASA mode. Fixed by reordering attribute removal. (DEPYLER-1088)
124. [x] ~~**Literal Coercion**~~ **FIXED**: Coerce int literals to float in comparisons and inject `.clone()` for ref assignments. (DEPYLER-1100)
125. [x] ~~**Oracle Type Repair**~~ **COMPLETE**: Automate re-transpilation based on `rustc` diagnostic output. (DEPYLER-1101/1102/1133)
126. [x] ~~**PyOps Codegen Integration**~~ **FIXED**: Updated binary_ops.rs and expr_gen.rs to generate `.py_add()`/`.py_sub()` for `DepylerValue`. (DEPYLER-1106)
127. [x] ~~**Sovereign Type DB**~~ **COMPLETE**: `depyler-knowledge` crate built. Validated extraction of 838 facts from `requests`. (DEPYLER-1111)
128. [x] ~~**Type DB Integration**~~ **COMPLETE**: Wired `TypeQuery` into `CodeGenContext` behind `sovereign-types` feature. (DEPYLER-1112)
129. [x] ~~**Activate Sovereign Types**~~ **COMPLETE**: Synapse activation. `expr_gen.rs` queries TypeDB on MethodCall, `stmt_gen.rs` propagates return types to `var_types`. (DEPYLER-1113)
130. [x] ~~**Knowledge Ingestion**~~ **COMPLETE**: Harvested `requests` library (289 type facts, 21KB parquet). TypeQuery validated. (DEPYLER-1114)
131. [x] ~~**Phantom Structure Bindings**~~ **COMPLETE**: Implemented JIT binding generation for external library types. Generates `struct Response(pub serde_json::Value)` wrappers from TypeDB. Eliminates E0412 (Type Not Found). (DEPYLER-1115)
132. [x] ~~**Semantic Method Realization**~~ **COMPLETE**: Implemented Proxy Pattern with `generate_default_return` to replace `todo!()` stubs with sensible defaults (0, "", None). (DEPYLER-1116)
133. [x] ~~**Lambda Type Inference**~~ **COMPLETE**: Added `infer_lambda_param_type()` to analyze lambda body expressions. Detects iterator patterns (ListComp, SetComp) to infer `Vec<i64>` and PyOps arithmetic to infer `i64`. E0282 reduced from 14â†’10 (-28.6%). (DEPYLER-1117)
134. [x] ~~**PyStringMethods Trait**~~ **COMPLETE**: Implemented Python string method parity (`lower`, `upper`, `strip`, `startswith`, `endswith`, etc.) for `str`, `String`, and `DepylerValue`. Added `PyMul`/`PyAdd` for `&str`. E0599 reduced from 39â†’32 (-17.9%). Compile rate 31.2%â†’33.0%. (DEPYLER-1118)
135. [x] ~~**Constraint-Aware Coercion**~~ **COMPLETE**: Generator obeys Oracle types for method calls (e.g., push, append). (DEPYLER-1134)
136. [x] ~~**Alias Stub Generation**~~ **COMPLETE**: Resolved E0425/E0423 by generating Rust module stubs for Python aliases (e.g., `import xml.etree.ElementTree as ET`). (DEPYLER-1136)
137. [x] ~~**Property Promotion**~~ **COMPLETE**: Automatically promoted Python property access (.tag, .text) to Rust method calls (.tag(), .text()) for XML proxies. (DEPYLER-1138)
138. [x] ~~**Stub Signature Refinement**~~ **COMPLETE**: Updated module alias stubs to use variadic-friendly generic signatures (`<S: AsRef<str>>`, `<P>`, `<E>`) instead of hardcoded types. Added XML functions (parse, ElementTree, iterparse, get). E0061 reduced from 16â†’15. (DEPYLER-1139)
139. [x] ~~**Numeric Coercion**~~ **COMPLETE**: Unified mixed int/float operations via NumPy NASA mode coercion. All numpy aggregations (sum, mean, dot, min, max, std, var, norm) now coerce to f64. (DEPYLER-1135)
140. [x] ~~**Typed Dict Value Coercion**~~ **COMPLETE**: Dict literals with concrete value type annotations (e.g., Dict[str, float]) now coerce values to target type instead of wrapping in DepylerValue. (DEPYLER-1141)
141. [x] ~~**Inference Black Box**~~ **FIXED**: Activated CITL Flight Recorder (Decision Tracing) to expose internal reasoning for causal chain analysis. (DEPYLER-1148)
142. [x] ~~**Mutability Inference (E0596)**~~ **FIXED**: Detected mutation in index assignment (`arr[i] = x`), tuple swap patterns (`arr[i], arr[j] = arr[j], arr[i]`), and transitive mutation through function calls. Functions now correctly generate `&mut Vec<T>` params. (DEPYLER-1217)
143. [x] ~~**Dict Literal Call Site Wrapping**~~ **FIXED**: Dict literals passed to functions expecting `Dict[str, Any]` now properly wrap values in `DepylerValue`. Added `as_str()`, `as_i64()`, `as_f64()`, `as_bool()` extraction methods. (DEPYLER-1215)
144. [x] ~~**Semantic Entry Point**~~ **FIXED**: Captured top-level script statements and wrapped them in `fn main()`. (DEPYLER-1216)
145. [x] ~~**Optional Dict Unwrapping**~~ **FIXED**: Correctly extracts `HashMap` type from `Optional[Dict]` during empty dict initialization (`{}`). (DEPYLER-1218)
146. [x] ~~**Recursive Deep Generic Inference**~~ **FIXED**: Empty literals inside nested collections now inherit precise subtypes (e.g., `Dict[str, List[int]]` -> `Vec<i32>`). (DEPYLER-1219)
147. [x] ~~**Cross-Function Return Type Inference**~~ **FIXED**: Return types are correctly propagated across unannotated call chains. (DEPYLER-1220)
148. [x] ~~**Dict String Access Guard**~~ **FIXED**: Prevented redundant unwrapping calls on native Rust strings during dictionary lookup. (DEPYLER-1221)
149. [x] ~~**Automated Failure Analysis**~~ **FIXED**: Eliminated the need for manual grepping by implementing an automated error dashboard in the CLI summary. (DEPYLER-1222)
150. [x] ~~**Reasoning Engine**~~ **FIXED**: Integrated graph-based structural analysis to identify high-impact failure nodes and vectorize AST context for ML training. (DEPYLER-1300)
151. [x] ~~**PyOps Traits for Collections**~~ **FIXED**: Implemented NumPy-style arithmetic traits (`py_add`, `py_sub`, etc.) for `Vec<T>`, resolving E0599 errors in vector math. (DEPYLER-1307)
152. [x] ~~**Bootstrap Pattern Store**~~ **FIXED**: Populated the DecisionPatternStore with 50 high-confidence fix patterns for top error codes. (DEPYLER-1309)
153. [x] ~~**TranspilerPatcher**~~ **FIXED**: Implemented a syn-based engine to apply permanent AST-level patches to transpiler code generation rules. (DEPYLER-1308)
154. [x] ~~**ROI Metrics Reconnection**~~ **FIXED**: Automated the emission of oracle_roi_metrics.json to track the effectiveness of self-repair conjectures. (DEPYLER-1301)
155. [x] ~~**Recursive Nested Inference**~~ **FIXED**: Implemented recursive type extraction for nested collection literals (e.g., `Vec<Vec<i32>>`), eliminating E0308 proxy fallbacks. (DEPYLER-1313)
156. [x] ~~**Flow-Based Inference**~~ **FIXED**: Standardized lambda parameter types and implemented robust `HashMap` return inference, unblocking flow-heavy scripts. (DEPYLER-1314)
157. [x] ~~**Ownership Strike (E0382)**~~ **FIXED**: Implemented auto-cloning for variable assignments and string slicing, reducing ownership errors to negligible levels. (DEPYLER-1315)
158. [x] ~~**Dict String Access Guard**~~ **FIXED**: Implemented get_str() optimization for DepylerValue maps to bridge the gap between proxy objects and concrete Rust string APIs. (DEPYLER-1316)
159. [x] ~~**Dict Key Paradox (Unification Treaty)**~~ **FIXED**: Unified dict access codegen between standalone functions and classmethods. Both now generate `.into()` for DepylerValue type conversion. Eliminated redundant `.as_str().unwrap_or("").to_string()` conversion in NASA mode. Compile rate: 29.0% â†’ 39.3% (+10.3 pp). (DEPYLER-1320)
160. [ ] **Intermediate Variable Type Propagation** **BLOCKED**: Dict access with intermediate variable assignment (`x = data["key"]; return x`) loses type information. Oracle identifies `type_mapper.rs` as root cause with 85% confidence. 358 E0308 errors remain at 39.3% plateau. Requires investigation of type propagation in TypeMapper. (DEPYLER-1321)

---

## Appendix D: Phase 6 Empirical Findings

### Phase 6c: The Unification Treaty (DEPYLER-1320)

**Problem Statement**: Civil war between two codegen paths for dict access.
- Standalone functions: `data.get("key").cloned().unwrap_or_default().into()` âœ“
- Classmethods: `data.get(&"key".to_string()).cloned().unwrap_or_default()` âœ—

**Root Causes Fixed**:
1. `direct_rules_convert.rs::convert_index` - Added `.into()` for NASA mode
2. `stmt_gen.rs` - Skip redundant JSON-to-String conversion in NASA mode
3. `type_tokens.rs` - Updated Unknown type mapping for NASA mode

**Empirical Result**: 29.0% â†’ 39.3% (+10.3 percentage points)

### Phase 6d: The 40% Barrier (DEPYLER-1321)

**Dashboard Output** (Oracle v3.22.0):
```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           PHASE 6d DASHBOARD (ITERATION 1)                   â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Passing:           70/178 (39.3%)                            â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ TOP CLUSTER: E0308 (358 errors, 85% confidence)              â•‘
â•‘ ROOT CAUSE:  type_inference @ type_mapper.rs                 â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Oracle Version: oracle-3.22.0-1769294391934                  â•‘
â•‘ Training Samples: 12,282                                     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

**Oracle Diagnosis**:
- The 358 E0308 errors are clustered around `type_inference` in `type_mapper.rs`
- 85% confidence in this classification
- Pattern: Intermediate variable assignment from dict access loses concrete type

**Example Failure Pattern**:
```python
def get_value(data: dict) -> int:
    x = data["value"]  # x inferred as DepylerValue, not i32
    return x           # E0308: expected i32, found DepylerValue
```

**Hypothesis for Next Fix**:
The TypeMapper must propagate the RHS concrete type to variable bindings when:
1. LHS has no explicit type annotation, AND
2. RHS expression produces DepylerValue with a known extraction target type

**Strategic Target**: Cross 40% barrier, march toward 50%.

---

## 8. Epistemic Health Metrics (DEPYLER-1322)

### 8.1 The Popperian Critique

*"A theory that explains everything explains nothing."* â€” Karl Popper

Analysis of project history (2,917 commits, 1,300+ tickets, 146 falsifiers fixed) reveals **paradigm exhaustion** at the 40% plateau. Each incremental strategy yields diminishing returns:

| Phase | Strategy | Î” Compile Rate |
|-------|----------|----------------|
| 1-3 | Pattern matching | 0% â†’ 25% (+25 pp) |
| 4 | PyOps traits | 25% â†’ 33% (+8 pp) |
| 5 | Oracle loop | 33% â†’ 40% (+7 pp) |
| 6 | Dict Unification | 39.3% â†’ ? (stalled) |

**Diagnosis**: The project has accumulated **protective belts** (Lakatos) that immunize against falsification rather than advancing knowledge:

1. **DepylerValue** â€” Universal fallback that hides inference failures
2. **Oracle Loop** â€” Curve-fitting (adjusting predictions to fit observations) rather than theory refinement
3. **NASA Mode** â€” Parallel code paths that fragment the hypothesis space

### 8.2 DepylerValue Escape Rate (New Metric)

**Definition**: The percentage of generated type annotations that use `DepylerValue` as a fallback.

```
Escape Rate = (DepylerValue annotations) / (Total type annotations) Ã— 100
```

**Falsification Criterion**: If escape rate exceeds **20%**, the type inference system is **evading** problems rather than **solving** them.

**Implementation** (DEPYLER-1322):
```rust
// In CodeGenContext
pub struct TypeMetrics {
    pub total_annotations: u64,
    pub depyler_value_annotations: u64,
}

impl TypeMetrics {
    pub fn escape_rate(&self) -> f64 {
        if self.total_annotations == 0 { return 0.0; }
        (self.depyler_value_annotations as f64 / self.total_annotations as f64) * 100.0
    }
}
```

**Dashboard Integration**:
```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           EPISTEMIC HEALTH DASHBOARD                         â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ Compile Rate:      39.3%                                     â•‘
â•‘ Escape Rate:       ??% (PENDING IMPLEMENTATION)              â•‘
â•‘ Semantic Parity:   ??% (PENDING DIFFERENTIAL TESTING)        â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘ HEALTH STATUS:     YELLOW (escape rate not measured)         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

**Warning Thresholds**:
| Escape Rate | Status | Interpretation |
|-------------|--------|----------------|
| 0-10% | ðŸŸ¢ GREEN | Type inference working |
| 10-20% | ðŸŸ¡ YELLOW | Inference degrading |
| >20% | ðŸ”´ RED | Inference failing, hidden by fallback |

### 8.3 Two-Tier Architecture Proposal

**The Fundamental Theorem**:
> There exists no bijective mapping from Python's dynamic types to Rust's static types.

**Implication**: Stop trying to infer Tier 1 (native Rust types) from Tier 2 (untyped Python) code. The information is not present.

**Proposed Architecture**:

| Tier | Input | Output | Strategy |
|------|-------|--------|----------|
| **Tier 1** | Fully typed Python (PEP 484 annotations) | Native Rust types | Direct mapping |
| **Tier 2** | Untyped Python | `DepylerValue` throughout | Universal embedding |

**Corpus Classification**:
```python
# Tier 1: Typed (direct mapping possible)
def add(x: int, y: int) -> int:
    return x + y

# Tier 2: Untyped (requires DepylerValue)
def add(x, y):
    return x + y
```

**Metric Split**:
- **Tier 1 Compile Rate**: Measure success on annotated code (should approach 95%)
- **Tier 2 Compile Rate**: Measure success on untyped code (accept lower ceiling)
- **Combined Rate**: Weighted by corpus composition

### 8.4 Differential Testing (Semantic Parity)

**Problem**: A compiled binary that produces different output than the Python original is a **false positive**. The current 39.3% may include semantic regressions.

**Solution**: Implement differential testing framework.

**Protocol**:
```bash
# For each transpiled file:
1. Generate random inputs (1000 iterations)
2. Run Python: python script.py < inputs > python_output
3. Run Rust:   ./script < inputs > rust_output
4. Compare:    diff python_output rust_output
5. If divergent: SEMANTIC FAILURE (regardless of compilation)
```

**Falsification Criterion**: If semantic parity < 95% on compiling files, the transpiler is producing **incorrect** code.

**New Metric**:
```
Semantic Parity = (Files with matching output) / (Files that compile) Ã— 100
True Success Rate = Compile Rate Ã— Semantic Parity
```

### 8.5 The Graveyard (Failed Approaches)

**Principle**: Science advances by what we *disprove*, not what we build. Documenting failures prevents repeated mistakes.

**Location**: `docs/GRAVEYARD.md`

**Format**:
```markdown
## [YYYY-MM-DD] Approach Name

**Hypothesis**: [What we believed would work]
**Implementation**: [What we built]
**Falsification**: [The test that disproved it]
**Lesson**: [What we learned]
**Artifacts**: [Relevant commits, tickets]
```

**Known Candidates for Graveyard** (from git history):
1. **-D warnings in convergence** â€” Fixed 100+ times, keeps returning
2. **Inverse Lowering** â€” DepylerValue-first approach (rejected: defeats purpose)
3. **Full Hindley-Milner** â€” Too complex for gradual typing
4. **Profile-Guided Types** â€” Requires test execution, not universal

### 8.6 Untranspilable Subset Characterization

**Problem**: The 80% target may be **unfalsifiable** if a significant portion of Python is inherently untranspilable.

**Known Untranspilable Patterns**:

| Pattern | Example | Reason |
|---------|---------|--------|
| `eval()` / `exec()` | `eval("x + " + y)` | Runtime code generation |
| Metaclasses | `class Meta(type)` | No Rust equivalent |
| Dynamic imports | `__import__(name)` | Compile-time resolution required |
| `*args, **kwargs` passthrough | `def f(*a, **k): g(*a, **k)` | Type erasure |
| Monkey patching | `obj.method = lambda: ...` | Rust structs are sealed |
| `globals()` / `locals()` | `globals()['x'] = 1` | No runtime symbol table |

**Action**: Define formal grammar of unsupported Python. Exclude from denominator.

**Revised Metric**:
```
Adjusted Compile Rate = Compiling / (Total - Untranspilable) Ã— 100
```

### 8.7 Falsification Criteria for Section 8

| ID | Criterion | Threshold | Status |
|----|-----------|-----------|--------|
| E1 | Escape rate measured | Must be tracked | ðŸ“‹ PENDING |
| E2 | Escape rate < 20% | RED if exceeded | ðŸ“‹ PENDING |
| E3 | Differential testing implemented | Framework exists | ðŸ“‹ PENDING |
| E4 | Semantic parity > 95% | On compiling files | ðŸ“‹ PENDING |
| E5 | Graveyard.md created | Document exists | ðŸ“‹ PENDING |
| E6 | Untranspilable grammar defined | Formal spec | ðŸ“‹ PENDING |
| E7 | Corpus split by tier | Typed vs untyped | ðŸ“‹ PENDING |

### 8.8 Implementation Roadmap

| Phase | Task | Deliverable | Ticket |
|-------|------|-------------|--------|
| 8a | Escape Rate Tracking | `TypeMetrics` in codegen | DEPYLER-1322 |
| 8b | Dashboard Integration | Escape rate in convergence output | DEPYLER-1323 |
| 8c | Differential Testing | `depyler diff-test` command | DEPYLER-1324 |
| 8d | Graveyard Creation | `docs/GRAVEYARD.md` | DEPYLER-1325 |
| 8e | Untranspilable Grammar | Formal exclusion list | DEPYLER-1326 |
| 8f | Tier Classification | Corpus annotation pipeline | DEPYLER-1327 |

---

**End of Specification**
```