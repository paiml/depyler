# 1.0 Single-Shot Compile Specification: The Unified Standard

**Version**: 1.2.0 (Enhanced Debugging & Falsification)
**Date**: 2026-01-09
**Status**: **ACTIVE IMPLEMENTATION**
**Authors**: Depyler Team
**Based On**:
- `pareto-complete-single-shot.md` (Strategy)
- `root-cause-single-shot-compile.md` (Architecture Status)
- `nasa-single-shot-compile.md` (Safety Standards)
- `single-shot-compile-spec.md` (User Experience)

---

## 1. Executive Summary

### Vision
Enable Python developers to compile **ANY** Python script to a highly optimized, type-safe Rust binary with a single command. The system must operate without manual intervention, achieving "NASA-grade" reliability through rigorous type inference and semantic verification.

```bash
# The Promise
depyler compile my_script.py --release
# Result: ./my_script (native binary, 10-50x faster)
```

### Current Status (Jan 2026)
The project has emerged from "Architectural Halt". The core architectural flaws (fragile string matching, naive type mapping) have been resolved.
*   **Compile Rate**: 68/181 (37.5%) — up from 22% baseline
*   **Verification**: The "Falsification Suite" (designed to break the compiler) now compiles successfully
*   **Next Milestone**: 80% Convergence (Pareto-Complete Phase)
*   **Primary Blocker**: E0308 Type Mismatch — heterogeneous dict type inference

### Quick Reference (Live Metrics)

```
┌─────────────────────────────────────────────────────────────┐
│  SINGLE-SHOT COMPILE DASHBOARD                              │
├─────────────────────────────────────────────────────────────┤
│  Compile Rate:  68/181 (37.5%)  ████████░░░░░░░░░░░░  38%   │
│  Target:        80%             ████████████████░░░░  80%   │
│                                                             │
│  Top Blocker:   E0308 - Heterogeneous dict type inference   │
│  Last Fix:      DEPYLER-1040 - Attribute access detection   │
│                                                             │
│  RC Status:     RC-1 ✅  RC-2 ✅  RC-3 ✅                    │
│  Falsification: PASSING                                     │
└─────────────────────────────────────────────────────────────┘
```

---

## 2. User Experience & CLI

### 2.1 Design Principles
1.  **"Just Works"**: No knowledge of Rust, Cargo, or lifetimes required.
2.  **Intelligent Defaults**: Workload detection selects the optimal profile.
3.  **Fast Feedback**: Errors are mapped back to Python source lines.

### 2.2 Command Interface

```bash
USAGE:
    depyler compile [OPTIONS] <SCRIPT>

ARGS:
    <SCRIPT>    Python script to compile (.py file)

OPTIONS:
    --profile <PROFILE>   Optimization profile [auto|release|perf-ultra|min-size]
    --pgo                 Enable Profile-Guided Optimization
    --verify              Run differential testing (Python vs Rust output)
    --target <TARGET>     Cross-compile (e.g., aarch64-unknown-linux-gnu)
```

---

## 3. Architecture & Root Cause Resolution

### 3.1 Post-Mortem Resolution (RC-1 to RC-3)
We have eradicated the "fragile regex" architecture in favor of robust AST analysis.

| Root Cause | Issue | Fix Implementation | Status |
|------------|-------|--------------------|--------|
| **RC-1** | For-loops destroyed by string matching | `syn::parse2` AST extraction | **FIXED** |
| **RC-2** | Naive `Dict[str, Any]` mapping | `DepylerValue` sum type injection | **FIXED** |
| **RC-3** | `try/except` return type mismatch | Binary expr inference + `Ok()` wrapping | **FIXED** |

### 3.2 Correctness-First Architecture
We adhere to the **Toyota Way** principles: correctness before optimization.

1.  **Renacer Tracing**: Observability into every transpilation decision (AST -> HIR -> Rust).
2.  **Scalar-First Inference**: Hindley-Milner type inference (Algorithm W) is used instead of premature SIMD/ML optimization.
3.  **Differential Testing**: We validate `Output(Python) == Output(Rust)` to ensure semantic equivalence.

### 3.3 Debugging & Observability Protocol
To prevent "Whack-a-Mole" debugging, we utilize **Renacer** for full-stack observability.

**Workflow**:
1.  **Trace Generation**: `depyler transpile input.py --trace > trace.json`
2.  **Source Map Analysis**: `renacer --map input.rs.sourcemap.json --analyze error.log`
3.  **Decision Audit**: Review `trace.json` to see *why* a type was inferred as `Unknown`.

**Key Tracing Points**:
*   `type_inference::infer_expr`: Log every inference decision and constraint source.
*   `stmt_gen::visit_assign`: Log variable symbol table updates.
*   `hir_lowering::lower_expr`: Log HIR to Rust AST transformation choices.

### 3.4 Root Cause Analysis: The Five Whys Standard
Every architectural failure must undergo a "Five Whys" analysis before code is written.

**Example: The E0308 Const Inference Failure (DEPYLER-1040)**

*   **Why 1**: Why does `pub const x: String = !true` fail to compile?
    *   *Answer*: Rust expects `bool` for `!true`, but the variable is typed as `String`.
*   **Why 2**: Why is the variable typed as `String`?
    *   *Answer*: The transpiler defaulted to `String` because it couldn't infer the type.
*   **Why 3**: Why couldn't it infer the type of `!true`?
    *   *Answer*: The `const_gen` module uses a different, simpler type inference path than function bodies.
*   **Why 4**: Why does `const_gen` use a simpler path?
    *   *Answer*: Historical technical debt; it was assumed consts would be simple literals (strings/ints).
*   **Why 5**: Why wasn't this caught earlier?
    *   *Answer*: Tests only covered simple literals, not complex expressions like `not True` or `~0xFF`.

**Corrective Action**: Unify `const_gen` inference with the main `expr_ty` inference engine (remove the simplified path).

### 3.5 Five-Whys: Heterogeneous Dict Attribute Access (DEPYLER-1040 Part 2)

**Symptom**: `comprehensive_cli.rs` generates `HashMap<String, String>` but values have different types (String, bool, int, Option<T>).

*   **Why 1**: Why does the generated HashMap have type `HashMap<String, String>` instead of `HashMap<String, DepylerValue>`?
    *   *Answer*: The `dict_has_mixed_types()` function didn't detect mixed types in the dict literal.

*   **Why 2**: Why didn't `dict_has_mixed_types()` detect mixed types?
    *   *Answer*: All values were `HirExpr::Attribute` (e.g., `args.debug`, `args.count`), which the function treated uniformly.

*   **Why 3**: Why were Attribute expressions treated uniformly?
    *   *Answer*: The function only checked for literal types (bool, int, float, string) and Variables with known types. Attribute accesses fell through to a generic "complex expression" category.

*   **Why 4**: Why did "complex expression" category not trigger mixed-type detection?
    *   *Answer*: All Attribute values set the same flag (`has_complex_expr = true`), so there was only ONE distinct "type" detected (not 2+).

*   **Why 5**: Why wasn't this architecture tested earlier?
    *   *Answer*: Test cases used simple literal dicts (`{"a": 1, "b": "str"}`) not struct field access dicts (`{"a": args.x, "b": args.y}`).

**Corrective Action**: Count unknown-type Attribute accesses separately. If 2+ unknown Attributes exist, assume they're different types and use `DepylerValue`. Implemented in commit `DEPYLER-1040`.

**Validation**: `comprehensive_cli.rs` now compiles (was failing with E0308).

---

## 4. Strategy: The Path to 80% (Pareto-Complete)

### 4.1 The Diagnosis
The "73-point gap" between feature coverage (95%) and compilation success (22%) was caused by **flow-insensitive type inference**. We are fixing this by implementing **Pareto-Complete Type Inference**.

### 4.2 Error Distribution Analysis
(Based on ~1400 errors across 113 failing files, Jan 2026 - Post DEPYLER-1040)

| Error Code | Count | Category | Fix Strategy | Status |
|------------|-------|----------|--------------|--------|
| **E0308** | 474 | Type Mismatch | Dict Attribute detection, const inference | **IN PROGRESS** |
| **E0425** | 189 | Undefined Variable | Variable hoisting, import handling | Pending |
| **E0599** | 179 | Method Not Found | DepylerValue traits, container detection | Partial ✅ |
| **E0277** | 149 | Trait Bounds | Derive `Clone`/`Debug`, iterator traits | Pending |
| **E0433** | 78 | Failed to Resolve | Module path resolution | Pending |
| **E0282** | 62 | Type Annotations Needed | Explicit type hints | Pending |

### 4.3 Implementation Phases

**Phase 1: E0308 Type Mismatch (The 40% Fix)** — **IN PROGRESS**
*   **DEPYLER-1040**: Fix heterogeneous dict Attribute detection. ✅ **DONE** (comprehensive_cli.rs compiles)
*   **DEPYLER-1040b**: Fix const declaration type inference. ⬅️ **NEXT**
*   **DEPYLER-1041**: Fix binary expression type unification.
*   **DEPYLER-1042**: Fix `HashMap<String, DepylerValue>` return consistency.

**Phase 2: E0599 Method Not Found** — **PARTIAL**
*   **DEPYLER-1043**: Implement `Display`, `len`, `chars`, `insert` on `DepylerValue`. ✅ **DONE**
*   **DEPYLER-1044**: Fix container type detection for Attribute access. ✅ **DONE**
*   **DEPYLER-1044b**: Fix `.contains_key()` vs `.contains()` for Vec. ✅ **DONE**

---

## 5. The NASA Standard (95%+ Goal)

For mission-critical reliability, we define a "Falsification Checklist" based on **NASA-GB-8719.13**.

### 5.1 Single-Shot Definition
A compile is only successful if:
1.  `depyler transpile` succeeds.
2.  `rustc` succeeds (exit code 0).
3.  **Constraint**: No manual intervention, no `todo!()` macros, no `#![allow(warnings)]`.

---

## 6. Verification & Quality Gates

### 6.1 PMAT Gates (Blocking)
*   **TDG Score**: Must be ≤ 2.0 (Grade A-).
*   **Coverage**: ≥ 85% line coverage.
*   **Mutation Kill Rate**: ≥ 80% (via `cargo-mutants`).

### 6.2 The Falsification Protocol
To ensure we aren't fooling ourselves, we run "Falsification Tests" designed to disprove our progress.

*   **F1 (Type Annotation)**: Does adding explicit types improve convergence? (If not, type inference isn't the root cause).
*   **F2 (Flow Prototype)**: Does bidirectional inference improve convergence by >10%?
*   **F3 (Error Isolation)**: Does fixing all type errors leave >50% files failing?

---

## Appendix A: Historical Intelligence Report

### A.1 The "Whack-a-Mole" Era (2024 - Late 2025)
*   **Strategy**: Fix errors as they appear (`fix: resolve E0308 in test_x`).
*   **Outcome**: 257+ commits in 3-day bursts, yet compilation rate stagnated at ~15-22%.
*   **Lesson**: Fixing symptoms (codegen output) without fixing the disease (type inference architecture) leads to infinite regression.

### A.2 The "Correctness-First" Pivot (Current)
*   **Strategy**: "Toyota Way" - Stop the line. Fix Root Causes (RC-1/2/3).
*   **Key Shift**: From regex/string matching to AST/syn parsing. From "fixing errors" to "fixing inference".
*   **Result**: Compile rate jumped to 38.3% immediately after RC fixes.

---

## Appendix B: Peer-Reviewed Foundations

The architecture is grounded in the following computer science literature. Each strategy maps directly to a verified concept.

1.  **Type Inference**: Milner, R. (1978). "A Theory of Type Polymorphism in Programming." *Journal of Computer and System Sciences*.
    *   *Application*: Our **Scalar-First Inference** uses Algorithm W (Constraint Solving) rather than ad-hoc heuristics.
2.  **Abstract Interpretation**: Cousot, P. & Cousot, R. (1977). "Abstract Interpretation: A Unified Lattice Model for Static Analysis." *POPL '77*.
    *   *Application*: Our **Flow Analysis** approximates runtime values to determine types (e.g., `Option<T>` vs `T`).
3.  **Differential Testing**: McKeeman, W. M. (1998). "Differential Testing for Software." *Digital Technical Journal*.
    *   *Application*: Our **Verification Suite** compares `Output(Python) == Output(Rust)` to detect semantic drift.
4.  **Technical Debt**: Scully, D., et al. (2015). "Hidden Technical Debt in Machine Learning Systems." *NIPS*.
    *   *Application*: We explicitly rejected "Aprender" (ML-based regression) to avoid the "Pipeline Jungle" antipattern.
5.  **Program Slicing**: Weiser, M. (1984). "Program Slicing." *IEEE Transactions on Software Engineering*.
    *   *Application*: **Renacer Tracing** slices the transpilation process to map output errors back to input source lines.

---

## Appendix C: The Karl Popper Falsification Strategy (100-Point)

Per Karl Popper's philosophy, we do not prove the compiler works; we exhaustively try to prove it fails. If it survives these 100 falsification attempts, we provisionally accept it as "NASA-Ready".

### I. Type System Falsifiers (Points 1-20)
*If any of these occur, the Type System hypothesis is FALSE.*

1.  [ ] `Type::Unknown` present in generated code.
2.  [ ] `rustc` reports E0308 (Type Mismatch) on valid Python input.
3.  [ ] Generic type parameters (`T`) are undeclared in `impl` blocks.
4.  [ ] Trait bounds (`T: Display`) missing for utilized methods.
5.  [ ] Return type inference fails for branching logic (`if/else` returns diff types).
6.  [ ] Numeric literals (`42`) cannot infer concrete type (`i32` vs `f64`).
7.  [ ] `E0282` (Type annotations needed) emitted by rustc.
8.  [ ] Conflicting trait implementations (`E0119`).
9.  [ ] Associated type missing (`Item` in Iterator).
10. [ ] Sizedness violation (`dyn Trait` without `Box`).
11. [ ] Union type (`int | str`) fails to map to Enum.
12. [ ] `Optional[T]` fails to map to `Option<T>`.
13. [ ] Dict assignment fails to unify key types.
14. [ ] List comprehension infers `Vec<Any>` instead of `Vec<T>`.
15. [ ] Lambda closure return type inference fails.
16. [ ] Class field types inconsistent across `__init__` paths.
17. [ ] Method overriding breaks signature compatibility.
18. [ ] Nested generics (`List[Dict[str, int]]`) fail to parse.
19. [ ] `TypeVar` remains unsubstituted in output.
20. [ ] Structural typing (Protocols) fails to generate Traits.

### II. Borrow Checker Falsifiers (Points 21-40)
*If any of these occur, the Ownership Model is FALSE.*

21. [ ] `E0596` (Cannot borrow immutable as mutable).
22. [ ] `E0507` (Cannot move out of borrowed content).
23. [ ] `E0382` (Use of moved value).
24. [ ] `E0502` (Mutable borrow occurs while immutable borrow active).
25. [ ] `E0499` (Multiple mutable borrows).
26. [ ] `E0597` (Value does not live long enough).
27. [ ] Lifetime mismatch (`'a` vs `'b`) in function signature.
28. [ ] Missing lifetime specifier (`E0106`).
29. [ ] `Clone` called on non-Clone type.
30. [ ] Unnecessary `clone()` detected by Clippy.
31. [ ] `self` mutation in non-`mut` method.
32. [ ] Field access on moved struct.
33. [ ] Return reference to local variable (`E0515`).
34. [ ] Closure captures variable incorrectly (move vs ref).
35. [ ] Iterator invalidation (modifying collection while iterating).
36. [ ] `RefCell` panic potential (runtime borrow check).
37. [ ] `Rc` cycle potential (memory leak).
38. [ ] Raw pointer usage (`*const`) detected.
39. [ ] `transmute` usage detected (Unsafe!).
40. [ ] `unsafe` block generated without justification.

### III. Semantic Equivalence Falsifiers (Points 41-60)
*If output differs, the Translation is FALSE.*

41. [ ] Stdout output differs between Python and Rust.
42. [ ] Integer overflow wraps in Rust but promotes in Python (without handling).
43. [ ] Float precision differs significantly.
44. [ ] String encoding (UTF-8) handling differs.
45. [ ] Exception not correctly mapped to `Result` or panic.
46. [ ] `None` handling differs (Option unwrapping).
47. [ ] List mutation visibility differs (reference semantics).
48. [ ] Dict iteration order assumptions broken.
49. [ ] Set operation semantics differ.
50. [ ] Slice indexing (negative indices) panics in Rust.
51. [ ] `__str__` / `Display` output format mismatch.
52. [ ] Default argument mutation persistence (Python quirk) missing.
53. [ ] Generator lazy evaluation semantics broken.
54. [ ] Context manager (`with`) cleanup order differs.
55. [ ] Decorator execution order differs.
56. [ ] Class inheritance method resolution order (MRO) differs.
57. [ ] Multiple inheritance flattening fails.
58. [ ] Property getter/setter side-effects missing.
59. [ ] Static/Class method behavior mismatch.
60. [ ] Magic method (`__add__`, etc.) precedence mismatch.

### IV. Stdlib & Ecosystem Falsifiers (Points 61-80)
*If stdlib fails, the Utility is FALSE.*

61. [ ] `os.path` function missing or incorrect.
62. [ ] `json.dumps` output format differs.
63. [ ] `re.match` group capturing differs.
64. [ ] `datetime` arithmetic mismatch.
65. [ ] `collections.defaultdict` behavior missing.
66. [ ] `argparse` output (help text) differs.
67. [ ] `itertools` infinite iterator handling fails.
68. [ ] `functools.partial` semantics broken.
69. [ ] `math` function precision/rounding mismatch.
70. [ ] `random` seeding/distribution mismatch (where relevant).
71. [ ] `hashlib` output mismatch.
72. [ ] `base64` encoding/decoding mismatch.
73. [ ] `struct.pack` endianness mismatch.
74. [ ] `socket` blocking/non-blocking behavior mismatch.
75. [ ] `threading` lock acquisition order differs.
76. [ ] `subprocess` env var inheritance differs.
77. [ ] `pathlib` path normalization differs.
78. [ ] `typing` generics lost in translation.
79. [ ] `enum` values mismatch.
80. [ ] `dataclass` equality logic mismatch.

### V. Code Quality & Performance Falsifiers (Points 81-100)
*If quality is low, the Engineering is FALSE.*

81. [ ] Cyclomatic Complexity > 10 in generated function.
82. [ ] Cognitive Complexity > 10.
83. [ ] Generated function > 50 lines (without good reason).
84. [ ] TDG Score > 2.0 (Technical Debt).
85. [ ] Test coverage of generated crate < 80%.
86. [ ] Clippy emits ANY warning.
87. [ ] `rustfmt` alters generated code (formatting instability).
88. [ ] Dead code detected (`udeps`).
89. [ ] Duplicate code blocks > 10%.
90. [ ] SATD (Self-Admitted Technical Debt) comments in output.
91. [ ] Rust binary slower than Python (Performance Regression).
92. [ ] Memory usage > 2x Python (Leak/Bloat).
93. [ ] Compile time > 60s for simple script.
94. [ ] Binary size > 10MB for simple script.
95. [ ] Startup time > 100ms.
96. [ ] Panic reachable in safe code (unwrap/expect).
97. [ ] Buffer overflow potential (Miri check).
98. [ ] Data race potential (ThreadSanitizer).
99. [ ] Undefined Behavior detected (Miri).
100. [ ] Security vulnerability (cargo audit) in dependencies.

---

**End of Specification**
