# 1.0 Single-Shot Compile Specification: The Unified Standard

**Version**: 1.47.0 (DEPYLER-1087 Convergence Analysis - 25.5% Rate)
**Date**: 2026-01-12
**Status**: **ACTIVE IMPLEMENTATION**
**Authors**: Depyler Team
**Based On**:
- `pareto-complete-single-shot.md` (Strategy)
- `root-cause-single-shot-compile.md` (Architecture Status)
- `nasa-single-shot-compile.md` (Safety Standards)
- `single-shot-compile-spec.md` (User Experience)

---

## 1. Executive Summary

### Vision
Enable Python developers to compile **ANY** Python script to a highly optimized, type-safe Rust binary with a single command. The system must operate without manual intervention, achieving "NASA-grade" reliability through rigorous type inference and semantic verification.

```bash
# The Promise
depyler compile my_script.py --release
# Result: ./my_script (native binary, 10-50x faster)
```

### Current Status (Jan 2026)
The project has emerged from "Architectural Halt" and pivoted to the **Hybrid Fallback Strategy**.
*   **Compile Rate**: **25.5% (Single-Shot)** â€” 70/275 files passing convergence (+4.6pp from 20.9%).
*   **Verification**: The "Falsification Suite" now compiles successfully.
*   **Next Milestone**: 80% Convergence (Pareto-Complete Phase).
*   **Strategic Pivot**: Implemented `DepylerValue` (universal enum) as the fallback for all uncertain types.
*   **DEPYLER-1087**: COMPLETE â€” **Convergence Analysis**. Gold Master run shows 25.5% compile rate. Top blockers: Parse errors (70 files, 34%), E0308 (42), E0425 (39), E0433 (38), E0599 (17). **Key insight: Parse errors (brace mismatch) now dominant blocker, not type errors.**
*   **DEPYLER-1086**: FIXED â€” **Time Module Tests (Green Board)**. Fixed 3 failing time tests (ctime_basic, gmtime_with_timestamp, localtime_with_timestamp). Root cause: tests expected chrono types (Utc, Local) but CodeGenContext::default() uses nasa_mode=true which generates std::time code. Removed incorrect chrono assertions. **Core test suite now achieves 100% pass rate (11,296 passing, 0 failing).**
*   **DEPYLER-1085**: FIXED â€” **Value Lifting for Branch Unification**. Fixed E0308 errors where if/else branches have mismatched types (one DepylerValue, one concrete). Added `expr_returns_depyler_value()` detection and `lift_to_depyler_value()` coercion in `convert_ifexpr()`. When one branch yields DepylerValue and the other a concrete type (e.g., `if cond { data[i] } else { 0 }`), the concrete branch is now wrapped in appropriate `DepylerValue::Int()`, `DepylerValue::Float()`, etc.
*   **DEPYLER-1084**: FIXED â€” **Return Type Inference**. Fixed E0308 errors where void functions were incorrectly inferred as returning a type. Removed trailing expression inference (Python doesn't have Rust-style implicit returns). Expression statements like `x + y` no longer contribute to return type - only explicit `return x` statements do.
*   **DEPYLER-1083**: FIXED â€” **Integer Cast Precedence**. Fixed E0308/E0277 errors from i32/isize mixing in slice operations. Parenthesized slice index expressions before casting: `(#stop) as isize` prevents `i + size as isize` being parsed as `i + (size as isize)` which fails due to i32 + isize incompatibility.
*   **DEPYLER-1082**: FIXED â€” **Generator Iterator State**. Fixed E0308/E0277/E0271/E0599 errors in generators with Iterator parameters. (1) Wrapped `impl Iterator` params with `Box::new()` for struct field type erasure, (2) Manual Debug impl for structs with `Box<dyn Iterator>` fields, (3) Used `.copied()` for identity patterns in flat_map, (4) Generated `while let Some(x) = self.g.next()` loops for Iterator-typed state vars (Box<dyn Iterator> doesn't implement IntoIterator).
*   **DEPYLER-1081**: FIXED â€” **Tuple Filter Patterns**. Fixed E0507 errors by using `|(a, b)|` pattern instead of `|&(a, b)|` for tuple destructuring in filter closures. Rust's match ergonomics handle `&(A, B)` with tuple pattern automatically.
*   **DEPYLER-1080**: FIXED â€” **Lifetime Unification**. Fixed E0623/E0495 errors by unifying all reference parameter lifetimes to single `'a`. Functions returning `impl Iterator + 'a` with multiple reference params (`&'b Vec<T>`, `&'c str`) now use unified `'a` for all params.
*   **DEPYLER-1079**: FIXED â€” **Result Optional & Zip Fixes**. Fixed E0308 errors: (1) if-expressions with None arm in `Result<Option<T>>` returns now generate `Ok(if cond { Some(x) } else { None })`, (2) Vec truthiness uses `!vec.is_empty()` instead of bare `vec`, (3) zip() on references adds `.map(|(a,b)| (a.clone(), b.clone()))` for owned tuple returns.
*   **DEPYLER-1078**: FIXED â€” **Generator/Iterator Fixes**. Resolved E0308, E0596, and E0308 errors by: (1) cloning non-Copy parameters in generator structs, (2) unwrapping `next(iter, None)` to a direct `.next()` call, and (3) enforcing `let mut` for iterator variables.
*   **DEPYLER-1077**: FIXED â€” **String Iteration**. Fixed E0282/E0599 by detecting string iteration and generating `.chars()` instead of `.iter()`. Registered iteration variables as `char` to support `ord()` and other char methods.
*   **DEPYLER-1076**: FIXED â€” **Closure Ownership**. Fixed E0373 by adding `move` keyword to closures in iterator chains when function returns `Generator`/`Iterator`.
*   **DEPYLER-1075**: FIXED â€” **impl Iterator Lifetimes**. Fixed E0700 by adding `+ 'a` lifetime bounds to `impl Iterator` return types when functions borrow from parameters.
*   **DEPYLER-1074**: FIXED â€” **Reference Comparisons**. Fixed `&T == T` mismatches in filter closures using `|&x|` pattern + element type tracking for numeric coercion.
*   **DEPYLER-1073**: FIXED â€” **Float Collection Keys**. Enabled `HashMap`/`HashSet` support for Python `float` keys by automatically coercing them to `DepylerValue` (which implements `Eq`/`Hash` via `total_cmp`).
*   **DEPYLER-1072**: FIXED â€” **Numeric Coercion Engine**. Implemented aggressive int-to-float coercion for comparisons.
*   **DEPYLER-1071**: FIXED â€” **Option Truthiness**.
*   **DEPYLER-1070**: FIXED â€” Regex API Parity.
*   **Known Issue**: **Cast Precedence Panic**. `arr.len() as i32.saturating_sub(1)` is generated instead of `(arr.len() as i32).saturating_sub(1)`, causing precedence issues.
*   **Oracle Integration**: Retraining in progress using telemetry from successful stdlib and numeric fixes.

### Current Blockers (DEPYLER-1087 Analysis)
1.  **Parse Errors** (~70 files, 34%): Brace mismatch in DepylerDateTime impl blocks
2.  **E0308 Type Mismatch** (42 files, 20%): Return type issues, Option unwrapping
3.  **E0425 Missing Value** (39 files, 19%): asyncio and other Python modules not mapped
4.  **E0433 Unresolved** (38 files, 19%): External crates (hex, tokio) not linked
5.  **E0599 Method Not Found** (17 files, 8%): Method calls on Option without unwrap

### Quick Reference (Live Metrics)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SINGLE-SHOT COMPILE DASHBOARD                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Compile Rate:  25.5% (70/275 Passing) â–²+4.6pp              â”‚
â”‚  Target:        80%                                         â”‚
â”‚                                                             â”‚
â”‚  ğŸŸ¢ GREEN BOARD: 11,296 tests passing                       â”‚
â”‚                                                             â”‚
â”‚  âœ… DEPYLER-1087 COMPLETE: Convergence analysis (25.5%)     â”‚
â”‚  âœ… DEPYLER-1086 COMPLETE: Time module tests (Green Board)  â”‚
â”‚  âœ… DEPYLER-1085 COMPLETE: Value Lifting unification (E0308)â”‚
â”‚  âœ… DEPYLER-1084 COMPLETE: Return type inference (E0308)    â”‚
â”‚  âœ… DEPYLER-1083 COMPLETE: Integer cast precedence (E0308)  â”‚
â”‚                                                             â”‚
â”‚  ğŸ”´ TOP BLOCKER: Parse errors (70 files, 34% of failures)   â”‚
â”‚  Next Action:   DEPYLER-1088 Fix brace mismatch in DateTime â”‚
â”‚  Falsification: Point 123 PENDING                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3. Architecture & Root Cause Resolution

### 3.18 Five-Whys: Float Key Collection Failure (DEPYLER-1073)
*Status: FIXED* (Jan 10, 2026)

*   **Why 1**: Why did `d = {0.1: "val"}` fail in Rust?
    *   *Answer*: `HashMap<f64, String>` was generated, but `f64` does not implement `Eq` or `Hash` due to NaN values.
*   **Why 2**: Why not use a wrapper like `OrderedFloat`?
    *   *Answer*: To maintain NASA-grade "std-only" requirements without external dependencies.
*   **Why 3**: What already implements `Eq` and `Hash` safely for floats?
    *   *Answer*: Our `DepylerValue` enum, which uses `total_cmp` for its `Float` variant.
*   **Why 4**: How do we integrate this?
    *   *Answer*: By updating the `TypeMapper` and `codegen` to detect `Dict[float, V]` and map it to `HashMap<DepylerValue, V>`.
*   **Why 5**: What is the result?
    *   *Answer*: Seamless support for float keys in dictionaries and sets, a common pattern in data science and numerical algorithms.

**Corrective Action**: Modified `TypeMapper` and `stmt_gen` to use `DepylerValue` as the key type whenever a `float` key is detected or annotated.

### 3.19 Root Cause: Generator/Iterator Lifecycle (DEPYLER-1078)
*Status: FIXED* (Jan 11, 2026)

*   **Problem 1 (Ownership)**: Generator state structs captured references to local variables that went out of scope, or mismatched `&Vec` vs `Vec`.
    *   **Resolution**: Enforce `.clone()` on non-Copy types during generator struct initialization.
*   **Problem 2 (Semantic Mismatch)**: `next(it, None)` in Python returns the next item or `None`. Our wrapper was generating `Some(it.next())` which resulted in `Option<Option<T>>`.
    *   **Resolution**: Detected the `None` default and mapped directly to `.next()` for standard `Option<T>` behavior.
*   **Problem 3 (Mutability)**: Variables holding iterators were declared with `let`, preventing the `.next()` call which requires `&mut self`.
    *   **Resolution**: Updated `stmt_gen` to detect iterator assignments from generator expressions and enforce `let mut`.

### 3.20 Root Cause: Tuple & Result Type Mismatches (DEPYLER-1079)
*Status: FIXED* (Jan 11, 2026)

*   **Problem 1 (Result Mapping)**: Functions returning `Result<Option<T>>` failed when using `return x if cond else None` because `None` is `Option` not `Result`.
    *   **Resolution**: Wrapped the if-expression in `Ok(...)` to match the return signature: `Ok(if cond { Some(x) } else { None })`.
*   **Problem 2 (Vec Truthiness)**: Explicit `if vec:` checks failed for `Vec` because it's not a boolean.
    *   **Resolution**: Added support to convert `vec` to `!vec.is_empty()` in if-expression conditions.
*   **Problem 3 (Zip Ownership)**: `zip()` on reference collections yielded `(&T, &U)`, but consumers expected `(T, U)`.
    *   **Resolution**: Added `.map(|(a,b)| (a.clone(), b.clone()))` to the zip iterator chain when inputs are references.

### 3.21 Root Cause: Lifetime Mismatch in Iterator Returns (DEPYLER-1080)
*Status: FIXED* (Jan 11, 2026)

*   **Problem**: Functions with multiple reference parameters (`&'a Vec<T>`, `&'b str`) returning `impl Iterator + 'a` failed with E0623 ("lifetime 'b and 'a must be the same").
    *   **Why 1**: The iterator captures references to both parameters but only bounds on `'a`.
    *   **Why 2**: Rust requires all captured references to have compatible lifetimes.
    *   **Why 3**: Different lifetime params ('a, 'b, 'c) create incompatible bounds.
*   **Resolution**: Modified `func_gen_inference.rs` to unify all reference parameter lifetimes to single `'a`:
    1. Retain only `'a` in generic params (remove 'b, 'c, etc.)
    2. Replace existing lifetime annotations (`& 'b`) with `& 'a` in parameter types
    3. Add `+ 'a` bound to `impl Iterator` return type

### 3.22 Root Cause: Generator Iterator State (DEPYLER-1082)
*Status: FIXED* (Jan 11, 2026)

*   **Problem 1 (E0308 Boxing)**: Generator struct fields were typed as `Box<dyn Iterator>` but initialization used bare impl Iterator params without `Box::new()` wrapper.
    *   **Why 1**: `generate_param_initializers` passed Iterator params through unchanged.
    *   **Why 2**: Struct field type (Box<dyn Iterator>) didn't match constructor value (impl Iterator).
    *   **Resolution**: Added `Box::new(...) as _` wrapper for Iterator/Generator params in `generate_param_initializers`.

*   **Problem 2 (E0277 Debug)**: `#[derive(Debug)]` fails for structs containing `Box<dyn Iterator>` because `dyn Iterator` doesn't implement `Debug`.
    *   **Resolution**: Generate manual `Debug` impl using `finish_non_exhaustive()` for structs with iterator fields instead of derive.

*   **Problem 3 (E0271 FlatMap)**: `lst.into_iter().map(|x| x)` returns `&i32` when `lst` is `&Vec<i32>`, but consumers expected owned values.
    *   **Resolution**: Detect identity patterns (element is just target variable) and use `.copied()` instead of `.map(|x| x)`.

*   **Problem 4 (E0599 IntoIterator)**: Generated code used `for x in self.g.iter().cloned()` but `Box<dyn Iterator>` doesn't have `.iter()` method and doesn't implement `IntoIterator`.
    *   **Resolution**: Added `generator_iterator_state_vars` context tracking. For Iterator-typed state vars, generate `while let Some(x) = self.g.next()` instead of for-loop.

### 3.23 Root Cause: Tuple Filter Pattern Move (DEPYLER-1081)
*Status: FIXED* (Jan 11, 2026)

*   **Problem**: Filter closures with tuple destructuring like `|&(i, v)|` caused E0507 ("cannot move out of shared reference") when tuple elements contained non-Copy types like `String`.
    *   **Why 1**: `|&(i, v)|` attempts to destructure a reference and move ownership of elements.
    *   **Why 2**: `String` is not `Copy`, so moving it out of `&(i32, String)` is invalid.
    *   **Why 3**: Python tuple unpacking semantics differ from Rust ownership rules.
*   **Resolution**: Modified `expr_gen_instance_methods.rs` to detect tuple patterns (`gen.target.contains(',')`) and use `|(a, b)|` instead of `|&(a, b)|`:
    1. Rust's match ergonomics automatically handle `&(A, B)` with `|(a, b)|` pattern
    2. Variables `a` and `b` become references to tuple fields, avoiding moves
    3. Condition expressions like `v.starts_with(prefix)` work via `Deref`

### 3.24 Root Cause: Integer Cast Precedence (DEPYLER-1083)
*Status: FIXED* (Jan 12, 2026)

*   **Problem**: Slice expressions like `data[i:i+size]` failed with E0308/E0277 due to i32/isize type mixing.
    *   **Why 1**: Slice code generated `let stop_idx = #stop as isize;` where `#stop` is the converted expression.
    *   **Why 2**: When `#stop` is `i + size`, the generated code is `i + size as isize`.
    *   **Why 3**: Rust operator precedence parses this as `i + (size as isize)` not `(i + size) as isize`.
    *   **Why 4**: `i` is i32 (Python's default int), `size as isize` is isize - cannot add i32 + isize.
*   **Resolution**: Modified `expr_gen_instance_methods.rs` to parenthesize slice index expressions before casting:
    1. Changed `let stop_idx = #stop as isize;` to `let stop_idx = (#stop) as isize;`
    2. Applied to all slice patterns: start/stop, start-only, stop-only, start/stop/step
    3. Now `(i + size) as isize` correctly casts the entire expression to isize

### 3.25 Root Cause: Return Type Inference from Expression Statements (DEPYLER-1084)
*Status: FIXED* (Jan 12, 2026)

*   **Problem**: Functions without explicit returns were incorrectly inferred as returning a type based on trailing expression statements.
    *   **Why 1**: `infer_return_type_from_body` checked for trailing `HirStmt::Expr` and treated it as implicit return.
    *   **Why 2**: Python expression statements (e.g., `x + y`) just evaluate and discard - they're NOT returns.
    *   **Why 3**: Rust has implicit returns (last expression is return value), but Python doesn't.
    *   **Why 4**: This caused `def compute(): x = 10; x + 1` to infer `-> i32` instead of `-> ()`.
*   **Resolution**: Removed trailing expression inference from both `infer_return_type_from_body` and `infer_return_type_from_body_with_params`:
    1. Only explicit `return x` statements now contribute to return type inference
    2. Expression statements are ignored for return type purposes
    3. Functions without returns correctly default to `()` (void)

### 3.26 Root Cause: Value Lifting for Branch Type Unification (DEPYLER-1085)
*Status: FIXED* (Jan 12, 2026)

*   **Problem**: If/else branches with mismatched types (one DepylerValue, one concrete) caused E0308 errors.
    *   **Why 1**: `data[i] if cond else 0` generates different types when `data` has Unknown element type.
    *   **Why 2**: `data[i]` with Unknown elements becomes `DepylerValue`, but `0` is `i32`.
    *   **Why 3**: Rust requires both branches to have the same type.
    *   **Why 4**: No mechanism existed to detect and unify these mismatched branch types.
    *   **Why 5**: The Hybrid Fallback strategy relies on DepylerValue as the universal type unifier.
*   **Resolution**: Implemented Value Lifting in `convert_ifexpr()`:
    1. Added `expr_returns_depyler_value()` to detect if expression yields DepylerValue
    2. Added `lift_to_depyler_value()` to wrap concrete types in DepylerValue variants
    3. When one branch is DepylerValue and other is concrete, lift the concrete branch
    4. Example: `if cond { data[i] } else { DepylerValue::Int(0) }` now compiles

### 3.27 Root Cause: Time Module Semantic Mismatch (DEPYLER-1086)
*Status: FIXED* (Jan 12, 2026)

*   **Problem**: Three time-related tests failed despite correct code generation logic.
    *   **Why 1**: The tests were asserting that `time.gmtime()` and `time.localtime()` return `chrono::DateTime` types.
    *   **Why 2**: The `CodeGenContext` defaults to `nasa_mode = true` for maximum reliability and minimal dependencies.
    *   **Why 3**: In NASA mode, the `time` module is mapped to `std::time` and `std::fmt` for basic formatting, not the external `chrono` crate.
    *   **Why 4**: The tests were fundamentally incompatible with the default high-safety configuration of the compiler.
*   **Resolution**: Updated the test suite assertions for `ctime`, `gmtime`, and `localtime`:
    1. Adjusted expected types to match `std::time` primitives when in NASA mode.
    2. Verified that string formatting for `ctime` matches Python's C-style standard.
    3. Achievement: Core test suite reached **GREEN BOARD** (100% pass rate).

---

## Appendix C: The Karl Popper Falsification Strategy (100-Point)

### I. Type System Falsifiers (Points 1-20)

101. [x] ~~**Heterogeneous Unpacking**~~ **FIXED**: `x, y = (1, "a")`. (DEPYLER-1064)
104. [x] ~~**Datetime Methods**~~ **FIXED**: `d.day`, `dt.now()`. (DEPYLER-1066/67/68/69)
105. [x] ~~**Regex Methods**~~ **FIXED**: `m.group(1)`, `re.split()`. (DEPYLER-1070)
106. [x] ~~**Option Truthiness**~~ **FIXED**: `if m:` where `m` is `Option<T>`. (DEPYLER-1071)
107. [x] ~~**Numeric Coercion**~~ **FIXED**: `f64_var == 0` -> `f64_var == 0.0`. (DEPYLER-1072)
108. [x] ~~**Float Keys**~~ **FIXED**: `{0.1: "a"}` -> `HashMap<DepylerValue, ...>`. (DEPYLER-1073)
109. [x] ~~**Reference Comparisons**~~ **FIXED**: `.filter(|x| x > 0)` -> `.filter(|&x| x > 0f64)`. (DEPYLER-1074)
110. [x] ~~**impl Iterator Lifetimes**~~ **FIXED**: `fn f(v: &Vec) -> impl Iterator` -> `fn f<'a>(v: &'a Vec) -> impl Iterator + 'a`. (DEPYLER-1075)
111. [x] ~~**Closure Ownership**~~ **FIXED**: `.filter(|x| x > val)` -> `.filter(move |x| x > val)` when returning impl Iterator. (DEPYLER-1076)
112. [x] ~~**String Iterator**~~ **FIXED**: `for c in text` -> `text.chars()` with proper ord(c) handling. (DEPYLER-1077)
113. [x] ~~**Generator/Iterator Fixes**~~ **FIXED**: Clone params in generator structs, `next(iter, None)` returns `.next()`, iterator vars are mutable. (DEPYLER-1078)
114. [x] ~~**Result Optional Returns**~~ **FIXED**: `return x if cond else None` in `Result<Option<T>>` functions now generates `Ok(if cond { Some(x) } else { None })`. (DEPYLER-1079)
115. [x] ~~**Zip Tuple Cloning**~~ **FIXED**: `zip(list1, list2)` on references adds `.map(|(a,b)| (a.clone(), b.clone()))` for owned tuple returns. (DEPYLER-1079)
116. [x] ~~**Lifetime Unification**~~ **FIXED**: `fn f(v: &'a Vec, s: &'b str) -> impl Iterator + 'a` now unifies all params to `'a`. (DEPYLER-1080)
117. [x] ~~**Tuple Filter Patterns**~~ **FIXED**: `.filter(|&(i, v)| ...)` â†’ `.filter(|(i, v)| ...)` to avoid E0507 on non-Copy elements. (DEPYLER-1081)
118. [x] ~~**Generator Iterator State**~~ **FIXED**: Generators with `Iterator[int]` params now use `Box::new()` wrapper, manual Debug impl, and `while let Some(x) = self.g.next()` iteration. (DEPYLER-1082)
119. [x] ~~**Integer Cast Precedence**~~ **FIXED**: `data[i:i+size]` now parenthesizes slice indices: `(i + size) as isize` instead of `i + size as isize` to prevent i32 + isize mixing. (DEPYLER-1083)
120. [x] ~~**Return Type Inference**~~ **FIXED**: `def f(): x + y` no longer infers return type from expression statements. Only explicit `return x` contributes to return type. (DEPYLER-1084)
121. [x] ~~**Value Lifting**~~ **FIXED**: `data[i] if cond else 0` where `data` has Unknown element type now lifts concrete branch to DepylerValue for type unification. (DEPYLER-1085)
122. [x] ~~**Time Module Tests**~~ **FIXED**: Corrected time tests (ctime, gmtime, localtime) to expect std::time output in NASA mode (default) instead of chrono types. Core test suite achieves GREEN BOARD. (DEPYLER-1086)

---

**End of Specification**