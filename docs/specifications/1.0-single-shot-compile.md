# 1.0 Single-Shot Compile Specification: The Unified Standard

**Version**: 1.86.0 (DEPYLER-1149: Set Literal Type Inference)
**Date**: 2026-01-20
**Status**: **ACTIVE IMPLEMENTATION**
**Authors**: Depyler Team
**Based On**:
- `pareto-complete-single-shot.md` (Strategy)
- `root-cause-single-shot-compile.md` (Architecture Status)
- `nasa-single-shot-compile.md` (Safety Standards)
- `single-shot-compile-spec.md` (User Experience)

---

## 1. Executive Summary

### Vision
Enable Python developers to compile **ANY** Python script to a highly optimized, type-safe Rust binary with a single command. The system must operate without manual intervention, achieving "NASA-grade" reliability through rigorous type inference and semantic verification.

```bash
# The Promise
depyler compile my_script.py --release
# Result: ./my_script (native binary, 10-50x faster)
```

### Current Status (Jan 2026)
The project has moved to the **Semantic Refinement Phase**. The "Scope War" (E0425) has been won, and the structural barriers between the Oracle, the Knowledge Base, and the Generator have been dismantled.
*   **Compile Rate**: **43.0%** (Non-test examples baseline).
*   **DEPYLER-1149**: COMPLETE ‚Äî **Set Literal Type Inference**. Fixed 42 E0308 `HashSet<DepylerValue>` errors by adding element type inference for set literals. Previously, all set literals were unconditionally typed as `HashSet<DepylerValue>` regardless of element types. Added `infer_collection_element_type()` helper in `stmt_gen.rs` that examines set literal elements: all integers ‚Üí `HashSet<i32>`, all floats ‚Üí `HashSet<f64>`, all strings ‚Üí `HashSet<String>`, mixed/unknown ‚Üí `HashSet<DepylerValue>`. **Pattern fixed**: `s = {1, 2, 3}` now generates `let s: HashSet<i32>` instead of `HashSet<DepylerValue>`. **Result: 41 E0308 errors eliminated (97.6% reduction), 7 files unblocked.**
*   **DEPYLER-1148**: COMPLETE ‚Äî **CITL Flight Recorder**. Activated dormant Decision Tracing infrastructure in the main CLI. Added `init_decision_tracing()` hook to `main.rs`. When built with `--features decision-tracing`, the transpiler now captures all inference logic (TypeMapping, BorrowStrategy, etc.) to a memory-mapped binary log (`/tmp/depyler_decisions.msgpack`). **Result: The "Black Box" of inference is now observable for causal chain analysis.**
*   **DEPYLER-1147**: COMPLETE ‚Äî **Optional Parameter Return Unwrap**. Fixed E0308 errors where functions returning `T` were incorrectly returning `&Option<T>` from optional parameters. Added automatic dereferencing and unwrapping (`(*maybe_val).unwrap()`) for return statements. **Result: 12 examples unblocked.**
*   **DEPYLER-1146**: COMPLETE ‚Äî **Dict Subscript Option Unwrap**. Fixed E0308 errors where `dict[key]` access on `DepylerValue` maps returned `Option<DepylerValue>` instead of the value itself. Added `.unwrap_or_default()` to subscript expressions. **Result: 18 examples unblocked.**
*   **DEPYLER-1145**: COMPLETE ‚Äî **Context-Aware Index Type Inference**. Fixed "expected DepylerValue, found i32" by tracking concrete element types in module constants. `list_example[0]` now correctly infers the element type (e.g., `i32`) instead of defaulting to proxy.
*   **DEPYLER-1144**: COMPLETE ‚Äî **Contextual List Literals**. Integer literals in lists are now coerced to float (`vec![0.0]`) when passed to `Vec<f64>` parameters (e.g., `Polynomial([0])`).
*   **DEPYLER-1143**: COMPLETE ‚Äî **Argparse Heterogeneity**. Enhanced `dict_has_mixed_types` to check argparse trackers, ensuring proper `DepylerValue` wrapping for heterogeneous CLI argument dictionaries.
*   **DEPYLER-1139**: COMPLETE ‚Äî **Stub Signature Refinement**. Updated module alias stubs to use variadic-friendly generic signatures (`<S: AsRef<str>>`, `<P>`, `<E>`) instead of hardcoded types. Added additional XML functions (`parse`, `ElementTree`, `iterparse`, `get`). **Result: E0061 (argument count mismatch) reduced from 16‚Üí15 examples blocked.**
*   **DEPYLER-1138**: COMPLETE ‚Äî **Property-to-Method Promotion**. Fixed E0615 "attempted to take value of method" errors. Python's attribute access on XML elements (e.g., `root.tag`) now correctly generates Rust method calls (`root.tag()`) when using `DepylerValue` proxies. **Result: Semantic parity achieved for property-like API access.**
*   **DEPYLER-1136**: COMPLETE ‚Äî **Alias Stub Generation**. Resolved the #1 Pareto blocker (E0425). When `import X as Y` is encountered, the transpiler now generates a Rust module or struct alias `Y` so that `Y.method()` calls are resolved. **Result: 138 E0425 errors eliminated, E0423 (19) eliminated.**
*   **DEPYLER-1134**: COMPLETE ‚Äî **Constraint-Aware Coercion**. The code generator now obeys Oracle constraints. **Result: The "Type War" is won.**
*   **DEPYLER-1133**: COMPLETE ‚Äî **Restoration of Truth**. Connected the Feedback Loop. **Result: Oracle learning is now active.**
*   **DEPYLER-1141**: COMPLETE ‚Äî **Typed Dict Value Coercion**. When dict literal has concrete value type annotation (e.g., `Dict[str, float]`), skip DepylerValue wrapping even if values have mixed types (int/float). Added value coercion to target type. **Pattern fixed**: `stats: Dict[str, float] = {"k": int_var}` ‚Üí coerces int_var to f64. **Result: examples/simulation_combined.py now compiles.**
*   **DEPYLER-1135**: COMPLETE ‚Äî **Numeric Coercion**. Implemented Universal Numeric Promotion for NumPy NASA mode aggregations. All numpy operations (sum, mean, dot, min, max, std, var, norm) now coerce elements to f64 before computation. Added `expr_returns_f64()` helper to detect f64-returning expressions and extended `needs_type_conversion()` to apply return type coercion. **Result: E0308 type mismatches for numpy integer array operations eliminated.**
*   **Noise Filtering Strategy**: Identified 70+ failures as `pytest` artifacts. These are now excluded from the convergence baseline to ensure metrics reflect functional application code.
*   **DEPYLER-1132**: COMPLETE ‚Äî **List Repeat Type Inference**. ...
*   **DEPYLER-1131**: COMPLETE ‚Äî **Vec List Concatenation**. Implemented `PyAdd<Vec<T>> for Vec<T>` trait to support Python list concatenation. Three implementations: owned+owned, owned+ref, ref+owned. **Pattern fixed**: `combined = list1 + list2` ‚Üí `list1.py_add(list2)` returns `Vec<T>`. **Result: E0599 "no method py_add for Vec" errors eliminated for list concatenation.**
*   **DEPYLER-1130**: COMPLETE ‚Äî **Lambda Boolean Parameter Type Inference**. Lambda parameters used directly as conditions in if-expressions now correctly infer as `bool` type. Added `param_used_as_condition()` function that detects when a parameter is used as `IfExpr.test` directly. **Pattern fixed**: `lambda is_add: (add) if is_add else (sub)` ‚Üí `is_add: bool` not `is_add: i64`. **Result: E0308 bool/i64 mismatches for lambda conditionals eliminated.**
*   **DEPYLER-1129**: COMPLETE ‚Äî **Vec List Repetition**. Implemented `PyMul<i32>`, `PyMul<i64>`, `PyMul<usize>` for `Vec<T>` and reverse multiplication for int types. **Pattern fixed**: `[0] * 10` ‚Üí `vec![0].py_mul(10)` returns `Vec<i32>`. **Result: E0271 type mismatches for list repetition eliminated.**
*   **DEPYLER-1128**: COMPLETE ‚Äî **Module-Level Type Inference**. Improved type inference for module-level constants. (1) Homogeneous lists now infer concrete types: `[1,2,3]` ‚Üí `Vec<i32>` instead of `Vec<DepylerValue>`. (2) Homogeneous sets similarly: `{1,2,3}` ‚Üí `HashSet<i32>`. (3) Tuple types now properly inferred: `(1, "str", 3.14)` ‚Üí `(i32, String, f64)`. (4) Binary expression types inferred from operand types: `10 + 20` ‚Üí `i32`. (5) Non-const operations (binary ops, string comparisons) now use `LazyLock` instead of `pub const` to avoid E0015 errors. **Pattern fixed**: Module-level `list_example = [1, 2, 3, 4, 5]` now generates `Vec<i32>` with correct integer literals instead of `Vec<DepylerValue>` with unwrapped literals. **Result: E0015 const-context errors eliminated for binary operations and string comparisons.**
*   **DEPYLER-1127**: COMPLETE ‚Äî **Value-Returning or/and Operators**. Python's `or`/`and` operators are value-returning, not boolean-returning like Rust's `||`/`&&`. Previously, `x or 0.1` generated `x || 0.1` which returned bool. Now detects non-boolean operands and generates value-returning pattern: `{ let _or_lhs = x; if _or_lhs.is_true() { _or_lhs } else { default } }`. Added `expr_is_boolean_expr()` to detect comparison/boolean expressions, `expr_is_depyler_value()` to detect DepylerValue types, and `expr_might_be_depyler_value()` for heuristic detection of dict.get chains. When left operand might be DepylerValue and right is numeric literal, wraps in `DepylerValue::Int/Float`. **Pattern fixed**: `wait = status.get("time") or 0` now returns the value, not a boolean. **Result: Value-returning semantics preserved for non-boolean or/and operations.**
*   **DEPYLER-1126**: COMPLETE ‚Äî **Mutable Option Parameter Dereference**. Fixed E0308 errors when assigning to `&mut Option<T>` parameters. When Python function has `param: T | None = None` that is mutated, the transpiler generates `&mut Option<T>`. The assignment `param = value` must dereference: `*param = Some(value)`. Added `mut_option_params` tracking for all Optional parameters with `needs_mut` flag from lifetime analysis. **Pattern fixed**: `if as_of is None: as_of = date.today()` ‚Üí `*as_of = Some(DepylerDate::today())`. **Result: Optional parameter reassignments now dereference correctly.**
*   **DEPYLER-1125**: COMPLETE ‚Äî **Dict Get with Default Value**. Fixed E0308 errors when class methods used `dict.get(key, default)` 2-arg form. Python's 2-arg `dict.get(k, d)` returns value at key or default, but Rust HashMap has no 2-arg get. Previously generated invalid: `.get(v, vec![])`. Now generates: `.get(&v).cloned().unwrap_or_else(|| vec![])`. Added handler in `convert_method_call()` for dict "get" method detecting 1-arg vs 2-arg forms. **Pattern fixed**: `self._adj.get(v, vec![])` ‚Üí `self._adj.get(&v).cloned().unwrap_or_else(|| vec![])`. **Result: Graph algorithms with adjacency lists now compile correctly.**
*   **DEPYLER-1124**: COMPLETE ‚Äî **Union Return Type Conversion**. Fixed E0308 errors when functions with Union return types (e.g., `Union[TokenBucket, SlidingWindow]`) returned concrete variants without conversion. Union types generate `From<A>` and `From<B>` trait impls, but return statements lacked the `.into()` call. Added Union detection in `codegen_return_stmt()` that adds `.into()` to expressions when return type is `Type::Union(_)`. **Pattern fixed**: `return Ok(TokenBucket::new())` ‚Üí `return Ok(TokenBucket::new().into())`. **Result: Union type returns now compile correctly via From trait conversion.**
*   **DEPYLER-1123**: COMPLETE ‚Äî **From Dict Type Extraction**. Fixed E0308 errors when accessing `HashMap<DepylerValue, DepylerValue>` in `from_dict` classmethods. Two-part fix: (1) Added `From<DepylerValue>` trait implementations for i32, i64, f32, f64, String, bool in rust_gen.rs runtime, enabling `.into()` to extract typed values from DepylerValue. (2) Modified `convert_index()` in direct_rules_convert.rs to detect bare dict parameters (`dict` without type params) and generate `data.get(&DepylerValue::Str("key".to_string())).cloned().unwrap_or_default().into()` instead of `data.get(&"key".to_string())`. **Result: `from_dict(data: dict)` classmethods now compile correctly with proper key wrapping and type extraction.**
*   **DEPYLER-1122**: COMPLETE ‚Äî **Dict DepylerValue Wrapping for Class Methods**. Fixed E0308 type mismatch errors in class methods with bare `dict` return type (e.g., `to_dict() -> dict:`). Previously, dict literals inserted raw types into `HashMap<DepylerValue, DepylerValue>` causing type mismatches. Added `convert_dict_to_depyler_value()` helper that wraps keys in `DepylerValue::Str()` and values in appropriate `DepylerValue::{Int,Float,Bool,Str}()` based on field types. Modified `convert_method_stmt()` to detect bare dict return types and apply DepylerValue wrapping. **Result: Class `to_dict()` methods now generate correct code like `map.insert(DepylerValue::Str("capacity".to_string()), DepylerValue::Int(self.capacity as i64))`.**
*   **DEPYLER-1121**: COMPLETE ‚Äî **NASA Mode NumPy Support**. Implemented std-only numpy emulation for NASA mode. NumPy operations now generate `Vec<f64>` operations instead of trueno crate calls: `np.array()` ‚Üí `vec![]`, `np.exp(arr)` ‚Üí `arr.iter().map(|x| x.exp()).collect()`, `np.sum()` ‚Üí `iter().sum()`, `np.mean()` ‚Üí `sum() / len()`, `np.dot()` ‚Üí `iter().zip().map().sum()`, etc. **Result: NumPy examples now compile in NASA mode without external dependencies.** Example: `numpy_exp_tool.py`, `numpy_mean_tool.py`, `numpy_sum_tool.py`, etc. now pass single-shot compilation.
*   **DEPYLER-1120**: COMPLETE ‚Äî **Argparse Keyword Escaping**. Fixed Rust keyword collision in argparse struct field names. Python CLI args like `--type` generated invalid Rust `type: String` field. Updated `argparse_transform.rs` to use `safe_ident()` for all field name generation, producing `r#type: String` using Rust raw identifier syntax. **Result: CLI tools with reserved keywords as args now compile.**
*   **DEPYLER-1101**: IN PROGRESS ‚Äî **Oracle Type Repair (Phase 1)**. Implemented `TypeConstraintLearner` to extract type constraints from E0308 errors. Parses "expected X, found Y" pairs using regex, maps Rust types to HIR `Type` enum (Int, Float, String, Bool, List, Dict, Optional, Set, Custom). Added `rust_type_to_hir()` converter and `repair_file_types()` entry point. **Phase 1 (Passive Learning) complete. Phase 2 (Active Repair) pending: need to inject learned constraints back into `CodeGenContext.var_types` and re-transpile.**
*   **DEPYLER-1119**: COMPLETE ‚Äî **UTOL Oracle Calibration**. Fixed critical bugs in `try_compile_rust()`: (1) Added `--edition 2021` for Rust 2021 syntax support. (2) Replaced `/dev/null` output path with proper temp file‚Äîrustc was trying to create temp directories in `/dev/` which fails with permission denied. **Result: UTOL now correctly reports 45.2% compile rate (84 files processed, 38 passing). Previously showed 0% due to compilation check failures.**
*   **DEPYLER-1118**: COMPLETE ‚Äî **PyStringMethods Trait**. Implemented Python string method parity via the `PyStringMethods` trait. Maps `lower()`, `upper()`, `strip()`, `lstrip()`, `rstrip()`, `startswith()`, `endswith()`, `capitalize()`, `title()`, `swapcase()`, `isalpha()`, `isdigit()`, `isalnum()`, `isspace()`, `islower()`, `isupper()`, `center()`, `ljust()`, `rjust()`, `zfill()`, `count()`, `py_split()`, `py_replace()`, `py_find()`. Implemented for `str`, `String`, and `DepylerValue`. Added `PyMul` and `PyAdd` for `&str`. **Result: E0599 reduced from 39 ‚Üí 32 (-17.9%). Compile rate 31.2% ‚Üí 33.0%.**
*   **DEPYLER-1117**: COMPLETE ‚Äî **Lambda Type Inference**. Added `infer_lambda_param_type()` to analyze lambda body expressions and infer parameter types. Detects iterator patterns (ListComp, SetComp, DictComp, GeneratorExp) to type params as `Vec<i64>`, and PyOps arithmetic patterns to type as `i64`. **Result: E0282 (Type Annotations Needed) reduced from 14 ‚Üí 10 (-28.6%).**
*   **DEPYLER-1116**: COMPLETE ‚Äî **Proxy Pattern for Method Stubs**. Implemented `generate_default_return()` to provide sensible default values (0, 0.0, "", empty collections) for method stubs instead of panicking `todo!()`. Module functions now construct phantom structs initialized with defaults. Verified with 19 passing binding tests.
*   **DEPYLER-1115**: COMPLETE ‚Äî **Phantom Structure Bindings (NASA Compliant)**. Implemented JIT binding generation. The transpiler now synthesizes Rust `mod` and `struct` definitions (e.g., `requests::models::Response`) from TypeDB facts, eliminating E0412 (Type Not Found) errors. Verified NASA mode compatibility: parameter mapping fixed (Any -> &str) to match transpiler literals. 
*   **DEPYLER-1114**: COMPLETE ‚Äî **Knowledge Ingestion**. Harvested `requests` library into Sovereign Type DB (289 type facts, 21KB parquet). Validated TypeQuery with `find_signature("requests.api", "get")` returning `Response`.
*   **DEPYLER-1113**: COMPLETE ‚Äî **Synapse Activation**. Connected TypeDB to expression generation. `expr_gen.rs` now queries TypeDB on MethodCall for external modules. `stmt_gen.rs` propagates return types to `var_types`. The "Learning Synapse" is active.
*   **DEPYLER-1112**: COMPLETE ‚Äî **Type DB Integration**. Wired `depyler-knowledge` into `depyler-core` via `sovereign-types` feature flag. `CodeGenContext` now has access to O(1) type lookups.
*   **DEPYLER-1111**: COMPLETE ‚Äî **Sovereign Type DB**. Built `depyler-knowledge` crate. Validated extraction of 838 type facts from `requests` into 53KB Parquet DB using `uv` and `rustpython_parser`.
*   **DEPYLER-1109**: COMPLETE ‚Äî **Universal PyOps Dispatch**. Implemented `PyAdd`, `PySub`, `PyMul`, `PyDiv`, `PyMod` universal dispatch. **Result: E0369 (Binary Op) errors ELIMINATED (152 -> 0). E0308 reduced by 304 (8.1%).**
*   **DEPYLER-1108**: FIXED ‚Äî **Parallelism Bug**. Resolved race condition in `compiler.rs` during concurrent artifact generation.
*   **DEPYLER-1106**: FIXED ‚Äî **PyOps Codegen Integration**. Updated `expr_gen.rs` to generate `.py_add()`/`.py_sub()` for `DepylerValue` types, leveraging the trait system for implicit coercion.
*   **DEPYLER-1105**: COMPLETE ‚Äî **Convergence Validation (Structural Phase)**. Gold Master run on expanded 369-file corpus. Results: 80 passing (21.7%), E0308 (3763), TRANSPILE (30), E0562 (15), E0317 (9). **Key insight: PyOps integration initiated; 18x speedup achieved via institutionalized RAM disk setup.**
*   **DEPYLER-1104**: COMPLETE ‚Äî **PyOps Trait Expansion**. Implemented Python-semantic arithmetic and indexing traits: `PyAdd`, `PySub`, `PyMul`, `PyDiv`, `PyIndex`. Cross-type promotion (i32+f64‚Üíf64), string repetition (str*int), negative indexing support. Implementations for i32, i64, f64, String, Vec<T>, HashMap, DepylerValue. **4 tests passing.** This provides the semantic foundation for replacing manual type coercion with trait-based dispatch.
*   **DEPYLER-1103**: FIXED ‚Äî **PyTruthy Trait**. Implemented `PyTruthy` trait for all core types and `DepylerValue`, standardizing Python truthiness semantics across the codebase.
*   **DEPYLER-1102**: COMPLETE ‚Äî **Oracle Loop Activation**. Diagnosed and fixed the "Zombie Oracle" issue where learned constraints were ignored by the generator. Implemented `transpile_with_constraints_and_dependencies` and connected it to `compile_cmd.rs`. Verified active learning on `test_csv.py` (3 attempts, constraints extracted and reapplied). **Result: The Feedback Loop is now physically connected.**
*   **DEPYLER-1101**: COMPLETE ‚Äî **Oracle Type Repair**. Implemented `TypeConstraintLearner` (Phase 1) and wired it into the active compile loop (Phase 2).
*   **DEPYLER-1134**: PENDING ‚Äî **Constraint-Aware Coercion**. The generator currently ignores Oracle constraints during method calls (e.g., pushing `DepylerValue` into a `Vec<String>` that the Oracle correctly identified). The next step is to make `convert_list_method` respect `var_types` constraints by generating `.try_into().unwrap()` coercions.
*   **DEPYLER-1100**: FIXED ‚Äî **Literal Coercion & Reference Assignment (E0308)**. Resolved two high-frequency E0308 patterns: (1) Numeric comparisons (float var > 0) now coerce literals to float (0.0). (2) Reference assignments (borrowed ‚Üí owned) now automatically inject `.clone()`. Regression tests pass.
*   **DEPYLER-1099**: COMPLETE ‚Äî **Convergence Analysis**. Ran full corpus convergence (271 files). Results: 73 passing (26.9%). Error distribution: E0308 (3321), E0599 (1199), E0277 (804). **Key insight: Tactical fixes are hitting diminishing returns; structural architectural shifts required.**
*   **DEPYLER-1098**: FIXED ‚Äî **serde_json NASA Mode Fix (E0433)**. Eliminated 69+ E0433 "unlinked crate serde_json" errors in NASA mode. Analysis showed `serde_json` was being generated in several places without NASA mode checks. **Root causes**: (1) Union type fallback in `direct_rules.rs:resolve_union_enum_to_syn` hardcoded `serde_json::Value`. (2) JSON module constructor in `direct_rules_convert.rs` used `serde_json::from_str` without NASA check. (3) Regex module placeholder used `serde_json::Value::Null`. **Fixes**: (1) Changed union fallback to `DepylerValue` (std-only). (2) Added NASA mode branches for `json.loads/dumps` returning HashMap stub / format!() string. (3) Changed `re` placeholder to `None::<String>`. **Result: NASA mode now generates 100% std-only code for JSON operations.** Regression test: `test_depyler_1098_no_serde_json_in_nasa_mode`.
*   **DEPYLER-1097**: FIXED ‚Äî **Module Mapping Blitz (E0425)**. Reduced E0425 "cannot find value" errors by mapping common Python builtins and stdlib modules to Rust equivalents. Analysis showed top blockers: `all` (23 files), `sys` (14 files), `dict` (9 files), `any` (similar to all). **Fixes implemented**: (1) Added `all()` builtin ‚Üí `items.iter().all(|&x| x)` for boolean iterables. (2) Added `any()` builtin ‚Üí `items.iter().any(|&x| x)` for boolean iterables. (3) Added `dict()` builtin ‚Üí `HashMap::new()` or `into_iter().collect()`. (4) Added `sys` module attribute access: `sys.argv` ‚Üí `std::env::args().collect()`, `sys.exit(code)` ‚Üí `std::process::exit()`, `sys.platform` ‚Üí `std::env::consts::OS`, `sys.stdin/stdout/stderr` ‚Üí `std::io::stdin()/stdout()/stderr()`, `sys.maxsize` ‚Üí `i64::MAX`, `sys.getsizeof()` ‚Üí `std::mem::size_of_val()`. **Result: Mapped most common E0425 blockers. ~30+ files potentially unblocked.** Regression tests: `test_depyler_1097_all_builtin`, `test_depyler_1097_any_builtin`, `test_depyler_1097_dict_builtin`, `test_depyler_1097_sys_argv`.
*   **DEPYLER-1096**: FIXED ‚Äî **Boolean Truthiness Coercion**. Fixed E0308 errors where non-bool types were used in `if`/`while` conditions. Python allows any type in conditions (truthy/falsy semantics): empty collections are falsy, zero is falsy, None is falsy. Rust requires explicit bool. Root cause: `convert_stmt()` in `direct_rules_convert.rs` used `convert_expr_with_param_types()` for if/while conditions without applying truthiness coercion. Fix: Added `apply_truthiness_coercion()` method to ExprConverter and `convert_condition_expr()` wrapper function. The coercion logic: (1) Comparisons and boolean operators already return bool - pass through unchanged. (2) Collections (Vec, HashMap, etc.) get `!is_empty()`. (3) Options get `is_some()`. (4) Numerics get `!= 0`. Made `truthiness_helpers` module public for reuse. Updated if/while handlers to use `convert_condition_expr()`. **Result: Non-bool conditions now correctly coerced to bool.** Regression tests: `test_depyler_1096_truthiness_collection`, `test_depyler_1096_truthiness_bool_passthrough`, `test_depyler_1096_truthiness_comparison_passthrough`.
*   **DEPYLER-1095**: FIXED ‚Äî **Python Negative Indexing (list[-1])**. Fixed runtime panic where Python `list[-1]` (get last element) was transpiled to `-1 as usize` which wraps to a huge number in Rust. Root cause: `convert_index()` in `direct_rules_convert.rs` at line 2667 generated `#base_expr[#index_expr as usize]` without handling negative indices. Python semantics: `-1` means last element, `-2` means second-to-last, etc. Fix: Modified `convert_index()` to detect negative indices (both literals and `UnaryOp::Neg`) and generate safe runtime indexing: `if idx < 0 { base[base.len().wrapping_sub((-idx) as usize)] } else { base[idx as usize] }`. For variable indices, always generate the runtime check since the value could be negative at runtime. **Result: Python negative indexing now works correctly in transpiled code.** Regression tests: `test_depyler_1095_negative_indexing`, `test_depyler_1095_variable_index_safety`.
*   **DEPYLER-1094**: FIXED ‚Äî **Numeric Mixing i32/f64 in min/max and Binary Ops**. Fixed E0277/E0308 errors where Python's implicit int‚Üífloat promotion wasn't replicated. Root causes: (1) `min(capacity, tokens + rate)` where capacity:int and tokens:float generated `.min()` method call without type coercion. (2) `tokens - count` where tokens:f64 and count:i32 generated `f64 - i32` which Rust doesn't support. (3) Single-arg `min(iterable)` generated standalone `min()` function call that didn't exist. Fix: In `direct_rules_convert.rs`: (1) Changed 2-arg min/max to cast both operands to f64: `(a as f64).min(b as f64)`. (2) Added single-arg min/max handling: `iterable.iter().cloned().min().unwrap()`. (3) Added type coercion to `BinOp::Sub` using `expr_returns_float_direct()` to detect mixed types and cast i32 to f64. **Result: Numeric mixing errors for min/max and subtraction eliminated.** Regression tests: `test_depyler_1094_numeric_mixing_min_max`, `test_depyler_1094_numeric_mixing_subtraction`.
*   **DEPYLER-1093**: FIXED ‚Äî **Option Double-Wrapping Prevention**. Fixed E0308 errors where assignments to `Option<T>` variables incorrectly wrapped expressions that already return `Option<T>` in `Some()`, creating `Option<Option<T>>`. Root causes: (1) `os.environ.get(name)` ‚Üí `std::env::var(name).ok()` returns `Option`, was wrapped in `Some()`. (2) Assigning from `&Option<T>` variable was wrapped in `Some(default)` instead of `default.clone()`. Fix: Extended `is_already_option` check in `stmt_gen.rs:4178` to detect `.ok()`, `.get()`, `.cloned()`, `.as_ref()` patterns. Also detect when source variable has `Optional` type and emit `.clone()` instead of `Some()` wrapper. **Result: Option double-wrapping errors eliminated.** Regression test: `test_depyler_1093_option_assignment_no_double_wrap`.
*   **DEPYLER-1092**: FIXED ‚Äî **String Literal Coercion for &str Params**. Fixed E0308 errors where string literal default args (e.g., `separator: str = ","`) were generated as `",".to_string()` for borrowed `&str` params. Root cause: The default value completion code at line 4628 didn't check `param_needs_borrow`. Fix: Check `function_param_borrows` and emit bare string literal `","` (which is `&str`) instead of `",".to_string()` when param is borrowed. Also added match arm for `HirExpr::Literal(Literal::String)` in `needs_borrow` calculation. **Result: E0308 `&str`/`String` errors eliminated in tested files.** Regression test added: `test_depyler_1092_string_default_arg_for_borrowed_param`.
*   **DEPYLER-1091**: COMPLETE ‚Äî **E0308 Type Mismatch Analysis**. Analyzed 67 E0308 errors on 369-file corpus. Found 5 dominant sub-patterns: (1) `Option<String>` vs `String` (15 files), (2) `&str` vs `String` (13 files), (3) `i32` vs `f64` (11 files), (4) `usize` vs `i32` (8 files), (5) `bool` vs other (7 files). **Recommended fix priority: String reference coercion (`&str`/`String`) has lowest complexity and affects 13 files.**
*   **DEPYLER-1090**: FIXED ‚Äî **Strip clap::CommandFactory imports**. Fixed E0432 errors caused by residual `use clap::CommandFactory;` imports in NASA mode. Added line filter to strip CommandFactory imports and replaced `Args::command().print_help().unwrap()` with no-op. **Result: Parse errors reduced to ZERO (26‚Üí0). +13 more files compiling despite 71-file corpus growth.**
*   **DEPYLER-1089**: COMPLETE ‚Äî **Convergence Validation Post-1088**. Validated parse error fix on 298-file corpus. Parse errors reduced **63%** (70‚Üí26). Net +3 compiling files despite corpus growth. New error distribution: Parse (26), E0308 (32), E0425 (32), E0433 (33), E0599 (12), Other (90). **Key insight: "Other" errors (90 files) now visible‚Äîwere masked by parse errors. These include E0277, E0382, E0502, etc.**
*   **DEPYLER-1088**: FIXED ‚Äî **Fix Parse Errors (Inline Clap Attributes)**. Fixed parse errors caused by NASA mode line filter removing entire lines that started with `#[command(`. When rustfmt put clap attributes inline with enum variants like `#[command(about = "...")] Resource { name: String },`, the entire line was removed, leaving orphaned commas and variants outside the enum. **Solution**: Move inline `#[command(...)]` and `#[arg(...)]` attribute removal BEFORE the line filter. Now attributes are stripped from lines first, preserving the variant definitions.
*   **DEPYLER-1087**: COMPLETE ‚Äî **Convergence Analysis**. Gold Master run shows 25.5% compile rate. Top blockers: Parse errors (70 files, 34%), E0308 (42), E0425 (39), E0433 (38), E0599 (17). **Key insight: Parse errors (brace mismatch) now dominant blocker, not type errors.**
*   **DEPYLER-1086**: FIXED ‚Äî **Time Module Tests (Green Board)**. Fixed 3 failing time tests (ctime_basic, gmtime_with_timestamp, localtime_with_timestamp). Root cause: tests expected chrono types (Utc, Local) but CodeGenContext::default() uses nasa_mode=true which generates std::time code. Removed incorrect chrono assertions. **Core test suite now achieves 100% pass rate (11,296 passing, 0 failing).**
*   **DEPYLER-1085**: FIXED ‚Äî **Value Lifting for Branch Unification**. Fixed E0308 errors where if/else branches have mismatched types (one DepylerValue, one concrete). Added `expr_returns_depyler_value()` detection and `lift_to_depyler_value()` coercion in `convert_ifexpr()`. When one branch yields DepylerValue and the other a concrete type (e.g., `if cond { data[i] } else { 0 }`), the concrete branch is now wrapped in appropriate `DepylerValue::Int()`, `DepylerValue::Float()`, etc.
*   **DEPYLER-1084**: FIXED ‚Äî **Return Type Inference**. Fixed E0308 errors where void functions were incorrectly inferred as returning a type. Removed trailing expression inference (Python doesn't have Rust-style implicit returns). Expression statements like `x + y` no longer contribute to return type - only explicit `return x` statements do.
*   **DEPYLER-1083**: FIXED ‚Äî **Integer Cast Precedence**. Fixed E0308/E0277 errors from i32/isize mixing in slice operations. Parenthesized slice index expressions before casting: `(#stop) as isize` prevents `i + size as isize` being parsed as `i + (size as isize)` which fails due to i32 + isize incompatibility.
*   **DEPYLER-1082**: FIXED ‚Äî **Generator Iterator State**. Fixed E0308/E0277/E0271/E0599 errors in generators with Iterator parameters. (1) Wrapped `impl Iterator` params with `Box::new()` for struct field type erasure, (2) Manual Debug impl for structs with `Box<dyn Iterator>` fields, (3) Used `.copied()` for identity patterns in flat_map, (4) Generated `while let Some(x) = self.g.next()` loops for Iterator-typed state vars (Box<dyn Iterator> doesn't implement IntoIterator).
*   **DEPYLER-1081**: FIXED ‚Äî **Tuple Filter Patterns**. Fixed E0507 errors by using `|(a, b)|` pattern instead of `|&(a, b)|` for tuple destructuring in filter closures. Rust's match ergonomics handle `&(A, B)` with tuple pattern automatically.
*   **DEPYLER-1080**: FIXED ‚Äî **Lifetime Unification**. Fixed E0623/E0495 errors by unifying all reference parameter lifetimes to single `'a`. Functions returning `impl Iterator + 'a` with multiple reference params (`&'b Vec<T>`, `&'c str`) now use unified `'a` for all params.
*   **DEPYLER-1079**: FIXED ‚Äî **Result Optional & Zip Fixes**. Fixed E0308 errors: (1) if-expressions with None arm in `Result<Option<T>>` returns now generate `Ok(if cond { Some(x) } else { None })`, (2) Vec truthiness uses `!vec.is_empty()` instead of bare `vec`, (3) zip() on references adds `.map(|(a,b)| (a.clone(), b.clone()))` for owned tuple returns.
*   **DEPYLER-1078**: FIXED ‚Äî **Generator/Iterator Fixes**. Resolved E0308, E0596, and E0308 errors by: (1) cloning non-Copy parameters in generator structs, (2) unwrapping `next(iter, None)` to a direct `.next()` call, and (3) enforcing `let mut` for iterator variables.
*   **DEPYLER-1077**: FIXED ‚Äî **String Iteration**. Fixed E0282/E0599 by detecting string iteration and generating `.chars()` instead of `.iter()`. Registered iteration variables as `char` to support `ord()` and other char methods.
*   **DEPYLER-1076**: FIXED ‚Äî **Closure Ownership**. Fixed E0373 by adding `move` keyword to closures in iterator chains when function returns `Generator`/`Iterator`.
*   **DEPYLER-1075**: FIXED ‚Äî **impl Iterator Lifetimes**. Fixed E0700 by adding `+ 'a` lifetime bounds to `impl Iterator` return types when functions borrow from parameters.
*   **DEPYLER-1074**: FIXED ‚Äî **Reference Comparisons**. Fixed `&T == T` mismatches in filter closures using `|&x|` pattern + element type tracking for numeric coercion.
*   **DEPYLER-1073**: FIXED ‚Äî **Float Collection Keys**. Enabled `HashMap`/`HashSet` support for Python `float` keys by automatically coercing them to `DepylerValue` (which implements `Eq`/`Hash` via `total_cmp`).
*   **DEPYLER-1072**: FIXED ‚Äî **Numeric Coercion Engine**. Implemented aggressive int-to-float coercion for comparisons.
*   **DEPYLER-1071**: FIXED ‚Äî **Option Truthiness**.
*   **DEPYLER-1070**: FIXED ‚Äî Regex API Parity.
*   **Oracle Integration**: Retraining in progress using telemetry from successful stdlib and numeric fixes.

### Current Blockers (DEPYLER-1139 Analysis - v1.84.0)
1.  **E0308 Type Mismatch** (515 blocked, 85% confidence): Dominant blocker. Requires semantic coverage expansion and numeric coercion.
2.  **E0609 No Field** (36 examples): Accessing fields on types that don't have them. Need `.unwrap_or_default()` patterns.
3.  **E0605 Non-Primitive Cast** (19 examples): Invalid `as` casts between incompatible types.
4.  **E0061 Arg Count Mismatch** (15 examples): Function calls with wrong argument count. Stub signatures need refinement.
5.  **E0382 Use After Move** (15 examples): Ownership issues‚Äîvalues used after being moved.
6.  **ELIMINATED**: E0425 (Scope) and E0423 (Expected Value) have been fully resolved by DEPYLER-1136 through DEPYLER-1139.

### Advice from Karl Popper (The Advisor)

"We have moved from **Guesswork** to **Observation**. With the activation of the **CITL Flight Recorder (DEPYLER-1148)**, we no longer need to speculate why a type inference failed; we can *observe* the decision path.

The **Scope War** is behind us. The new battleground is **Semantic Fidelity** (E0308).

**The Theory of 80% Convergence**:
Our hypothesis is that 80% of Python code can be transpiled single-shot by correctly inferring types and mapping semantics. The Rust compiler (our falsifier) currently rejects 57% of our attempts, primarily due to Type Mismatches (E0308).

**Strategic Directive**:
1.  **Exploit the Flight Recorder**: Do not fix bugs blindly. Use the traces. If a slice is inferred as `String` instead of `&[T]`, find the *exact line* in the trace where the heuristic failed. Correct the heuristic, don't just patch the output.
2.  **The Slice Identity Crisis**: Python uses `[start:stop]` for both strings and lists. Rust demands distinction (`&str` vs `&[T]`). The inference engine must look at the *operand type*, not just the syntax. Falsify the 'everything is a string' assumption.
3.  **Result Normalization**: `Result<Option<T>>` is a messy type. Normalize it. Standardize on `anyhow::Result` or a unified error handling strategy to stop the `Ok(Some(Unwrap))` madness.
4.  **Knowledge Base Expansion**: We have the machinery. Feed it more truth. `numpy`, `pandas`, `xml.etree`.

**The Path Forward**:
We are now in the **Refinement Phase**. We must systematically eliminate errors by refining our theories (inference rules) based on empirical data (traces and rustc errors). Progress will now be measured by the *precision* of our inference, not just the volume of code generated."

### Quick Reference (Live Metrics - Examples Subset)

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  SINGLE-SHOT COMPILE DASHBOARD                              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Compile Rate:  43.0% (Non-test examples baseline)          ‚îÇ
‚îÇ  Target:        80%                                         ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  üü¢ GREEN BOARD: 11,309 tests passing                       ‚îÇ
‚îÇ  üü¢ SPEEDUP: 18x (Convergence: 5m vs 1.5h) via RAM Disk     ‚îÇ
‚îÇ  üü¢ SCOPE WAR WON: E0425/E0423 ELIMINATED                   ‚îÇ
‚îÇ  üü¢ FLIGHT RECORDER: CITL TRACING ACTIVE                    ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  ‚úÖ DEPYLER-1148 COMPLETE: CITL Flight Recorder             ‚îÇ
‚îÇ  ‚úÖ DEPYLER-1147 COMPLETE: Optional Return Unwrap           ‚îÇ
‚îÇ  ‚úÖ DEPYLER-1146 COMPLETE: Dict Subscript Option Unwrap     ‚îÇ
‚îÇ  ‚úÖ DEPYLER-1145 COMPLETE: Context-Aware Index Type Infer   ‚îÇ
‚îÇ                                                             ‚îÇ
‚îÇ  üî¥ TOP BLOCKER: E0308 Type Mismatch (Dominant)             ‚îÇ
‚îÇ  üî¥ NEXT: Slice Identity Crisis (String vs Vec)             ‚îÇ
‚îÇ  üî¥ NEXT: Result Normalization (Missing Ok)                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## Table of Contents

1. [Executive Summary](#1-executive-summary)
2. [Current Status](#current-status-jan-2026)
3. [Architecture & Root Cause Resolution](#3-architecture--root-cause-resolution)
4. [Structural Typing Solutions](#4-structural-typing-solutions)
5. [Performance Infrastructure](#5-performance-infrastructure-giant-ram-strategy)
6. [Sovereign Type Database (DEPYLER-1111)](#6-sovereign-type-database-depyler-1111)
7. [Falsification Framework](#7-falsification-framework)
- [Appendix C: Karl Popper Falsification Strategy](#appendix-c-the-karl-popper-falsification-strategy-100-point)

---

## 3. Architecture & Root Cause Resolution

### 3.18 Five-Whys: Float Key Collection Failure (DEPYLER-1073)
*Status: FIXED* (Jan 10, 2026)

*   **Why 1**: Why did `d = {0.1: "val"}` fail in Rust?
    *   *Answer*: `HashMap<f64, String>` was generated, but `f64` does not implement `Eq` or `Hash` due to NaN values.
*   **Why 2**: Why not use a wrapper like `OrderedFloat`?
    *   *Answer*: To maintain NASA-grade "std-only" requirements without external dependencies.
*   **Why 3**: What already implements `Eq` and `Hash` safely for floats?
    *   *Answer*: Our `DepylerValue` enum, which uses `total_cmp` for its `Float` variant.
*   **Why 4**: How do we integrate this?
    *   *Answer*: By updating the `TypeMapper` and `codegen` to detect `Dict[float, V]` and map it to `HashMap<DepylerValue, V>`.
*   **Why 5**: What is the result?
    *   *Answer*: Seamless support for float keys in dictionaries and sets, a common pattern in data science and numerical algorithms.

**Corrective Action**: Modified `TypeMapper` and `stmt_gen` to use `DepylerValue` as the key type whenever a `float` key is detected or annotated.

### 3.19 Root Cause: Generator/Iterator Lifecycle (DEPYLER-1078)
*Status: FIXED* (Jan 11, 2026)

*   **Problem 1 (Ownership)**: Generator state structs captured references to local variables that went out of scope, or mismatched `&Vec` vs `Vec`.
    *   **Resolution**: Enforce `.clone()` on non-Copy types during generator struct initialization.
*   **Problem 2 (Semantic Mismatch)**: `next(it, None)` in Python returns the next item or `None`. Our wrapper was generating `Some(it.next())` which resulted in `Option<Option<T>>`.
    *   **Resolution**: Detected the `None` default and mapped directly to `.next()` for standard `Option<T>` behavior.
*   **Problem 3 (Mutability)**: Variables holding iterators were declared with `let`, preventing the `.next()` call which requires `&mut self`.
    *   **Resolution**: Updated `stmt_gen` to detect iterator assignments from generator expressions and enforce `let mut`.

### 3.20 Root Cause: Tuple & Result Type Mismatches (DEPYLER-1079)
*Status: FIXED* (Jan 11, 2026)

*   **Problem 1 (Result Mapping)**: Functions returning `Result<Option<T>>` failed when using `return x if cond else None` because `None` is `Option` not `Result`.
    *   **Resolution**: Wrapped the if-expression in `Ok(...)` to match the return signature: `Ok(if cond { Some(x) } else { None })`.
*   **Problem 2 (Vec Truthiness)**: Explicit `if vec:` checks failed for `Vec` because it's not a boolean.
    *   **Resolution**: Added support to convert `vec` to `!vec.is_empty()` in if-expression conditions.
*   **Problem 3 (Zip Ownership)**: `zip()` on reference collections yielded `(&T, &U)`, but consumers expected `(T, U)`.
    *   **Resolution**: Added `.map(|(a,b)| (a.clone(), b.clone()))` to the zip iterator chain when inputs are references.

### 3.21 Root Cause: Lifetime Mismatch in Iterator Returns (DEPYLER-1080)
*Status: FIXED* (Jan 11, 2026)

*   **Problem**: Functions with multiple reference parameters (`&'a Vec<T>`, `&'b str`) returning `impl Iterator + 'a` failed with E0623 ("lifetime 'b and 'a must be the same").
    *   **Why 1**: The iterator captures references to both parameters but only bounds on `'a`.
    *   **Why 2**: Rust requires all captured references to have compatible lifetimes.
    *   **Why 3**: Different lifetime params ('a, 'b, 'c) create incompatible bounds.
*   **Resolution**: Modified `func_gen_inference.rs` to unify all reference parameter lifetimes to single `'a`:
    1. Retain only `'a` in generic params (remove 'b, 'c, etc.)
    2. Replace existing lifetime annotations (`& 'b`) with `& 'a` in parameter types
    3. Add `+ 'a` bound to `impl Iterator` return type

### 3.22 Root Cause: Generator Iterator State (DEPYLER-1082)
*Status: FIXED* (Jan 11, 2026)

*   **Problem 1 (E0308 Boxing)**: Generator struct fields were typed as `Box<dyn Iterator>` but initialization used bare impl Iterator params without `Box::new()` wrapper.
    *   **Why 1**: `generate_param_initializers` passed Iterator params through unchanged.
    *   **Why 2**: Struct field type (Box<dyn Iterator>) didn't match constructor value (impl Iterator).
    *   **Resolution**: Added `Box::new(...) as _` wrapper for Iterator/Generator params in `generate_param_initializers`.

*   **Problem 2 (E0277 Debug)**: `#[derive(Debug)]` fails for structs containing `Box<dyn Iterator>` because `dyn Iterator` doesn't implement `Debug`.
    *   **Resolution**: Generate manual `Debug` impl using `finish_non_exhaustive()` for structs with iterator fields instead of derive.

*   **Problem 3 (E0271 FlatMap)**: `lst.into_iter().map(|x| x)` returns `&i32` when `lst` is `&Vec<i32>`, but consumers expected owned values.
    *   **Resolution**: Detect identity patterns (element is just target variable) and use `.copied()` instead of `.map(|x| x)`.

*   **Problem 4 (E0599 IntoIterator)**: Generated code used `for x in self.g.iter().cloned()` but `Box<dyn Iterator>` doesn't have `.iter()` method and doesn't implement `IntoIterator`.
    *   **Resolution**: Added `generator_iterator_state_vars` context tracking. For Iterator-typed state vars, generate `while let Some(x) = self.g.next()` instead of for-loop.

### 3.23 Root Cause: Tuple Filter Pattern Move (DEPYLER-1081)
*Status: FIXED* (Jan 11, 2026)

*   **Problem**: Filter closures with tuple destructuring like `|&(i, v)|` caused E0507 ("cannot move out of shared reference") when tuple elements contained non-Copy types like `String`.
    *   **Why 1**: `|&(i, v)|` attempts to destructure a reference and move ownership of elements.
    *   **Why 2**: `String` is not `Copy`, so moving it out of `&(i32, String)` is invalid.
    *   **Why 3**: Python tuple unpacking semantics differ from Rust ownership rules.
*   **Resolution**: Modified `expr_gen_instance_methods.rs` to detect tuple patterns (`gen.target.contains(',')`) and use `|(a, b)|` instead of `|&(a, b)|`:
    1. Rust's match ergonomics automatically handle `&(A, B)` with `|(a, b)|` pattern
    2. Variables `a` and `b` become references to tuple fields, avoiding moves
    3. Condition expressions like `v.starts_with(prefix)` work via `Deref`

### 3.24 Root Cause: Integer Cast Precedence (DEPYLER-1083)
*Status: FIXED* (Jan 12, 2026)

*   **Problem**: Slice expressions like `data[i:i+size]` failed with E0308/E0277 due to i32/isize type mixing.
    *   **Why 1**: Slice code generated `let stop_idx = #stop as isize;` where `#stop` is the converted expression.
    *   **Why 2**: When `#stop` is `i + size`, the generated code is `i + size as isize`.
    *   **Why 3**: Rust operator precedence parses this as `i + (size as isize)` not `(i + size) as isize`.
    *   **Why 4**: `i` is i32 (Python's default int), `size as isize` is isize - cannot add i32 + isize.
*   **Resolution**: Modified `expr_gen_instance_methods.rs` to parenthesize slice index expressions before casting:
    1. Changed `let stop_idx = #stop as isize;` to `let stop_idx = (#stop) as isize;`
    2. Applied to all slice patterns: start/stop, start-only, stop-only, start/stop/step
    3. Now `(i + size) as isize` correctly casts the entire expression to isize

### 3.25 Root Cause: Return Type Inference from Expression Statements (DEPYLER-1084)
*Status: FIXED* (Jan 12, 2026)

*   **Problem**: Functions without explicit returns were incorrectly inferred as returning a type based on trailing expression statements.
    *   **Why 1**: `infer_return_type_from_body` checked for trailing `HirStmt::Expr` and treated it as implicit return.
    *   **Why 2**: Python expression statements (e.g., `x + y`) just evaluate and discard - they're NOT returns.
    *   **Why 3**: Rust has implicit returns (last expression is return value), but Python doesn't.
    *   **Why 4**: This caused `def compute(): x = 10; x + 1` to infer `-> i32` instead of `-> ()`.
*   **Resolution**: Removed trailing expression inference from both `infer_return_type_from_body` and `infer_return_type_from_body_with_params`:
    1. Only explicit `return x` statements now contribute to return type inference
    2. Expression statements are ignored for return type purposes
    3. Functions without returns correctly default to `()` (void)

### 3.26 Root Cause: Value Lifting for Branch Type Unification (DEPYLER-1085)
*Status: FIXED* (Jan 12, 2026)

*   **Problem**: If/else branches with mismatched types (one DepylerValue, one concrete) caused E0308 errors.
    *   **Why 1**: `data[i] if cond else 0` generates different types when `data` has Unknown element type.
    *   **Why 2**: `data[i]` with Unknown elements becomes `DepylerValue`, but `0` is `i32`.
    *   **Why 3**: Rust requires both branches to have the same type.
    *   **Why 4**: No mechanism existed to detect and unify these mismatched branch types.
    *   **Why 5**: The Hybrid Fallback strategy relies on DepylerValue as the universal type unifier.
*   **Resolution**: Implemented Value Lifting in `convert_ifexpr()`:
    1. Added `expr_returns_depyler_value()` to detect if expression yields DepylerValue
    2. Added `lift_to_depyler_value()` to wrap concrete types in DepylerValue variants
    3. When one branch is DepylerValue and other is concrete, lift the concrete branch
    4. Example: `if cond { data[i] } else { DepylerValue::Int(0) }` now compiles

### 3.27 Root Cause: Time Module Semantic Mismatch (DEPYLER-1086)
*Status: FIXED* (Jan 12, 2026)

*   **Problem**: Three time-related tests failed despite correct code generation logic.
    *   **Why 1**: The tests were asserting that `time.gmtime()` and `time.localtime()` return `chrono::DateTime` types.
    *   **Why 2**: The `CodeGenContext` defaults to `nasa_mode = true` for maximum reliability and minimal dependencies.
    *   **Why 3**: In NASA mode, the `time` module is mapped to `std::time` and `std::fmt` for basic formatting, not the external `chrono` crate.
    *   **Why 4**: The tests were fundamentally incompatible with the default high-safety configuration of the compiler.
*   **Resolution**: Updated the test suite assertions for `ctime`, `gmtime`, and `localtime`:
    1. Adjusted expected types to match `std::time` primitives when in NASA mode.
    2. Verified that string formatting for `ctime` matches Python's C-style standard.
    3. Achievement: Core test suite reached **GREEN BOARD** (100% pass rate).

### 3.28 Root Cause: Inline Clap Attributes Line Removal (DEPYLER-1088)
*Status: FIXED* (Jan 12, 2026)

*   **Problem**: Parse errors (~70 files) with "unexpected close delimiter" or "unclosed delimiter" in generated code.
    *   **Why 1**: `rust_gen.rs` used a line-based filter to remove `#[command(...)]` and `#[arg(...)]` attributes when in NASA mode (to avoid `clap` dependency).
    *   **Why 2**: `rustfmt` occasionally formatted code such that attributes were inline with enum variants: `#[command(...)] Variant { ... },`.
    *   **Why 3**: The line filter deleted the *entire line*, effectively deleting the enum variant definition and leaving orphaned commas/braces.
*   **Resolution**: Refactored `rust_gen.rs` attribute removal:
    1.  Moved attribute removal logic *before* line filtering.
    2.  Implemented token-aware removal for inline `#[arg(...)]` and `#[command(...)]` patterns.
    3.  Removed the destructive line-based filter loop entirely.
    *   **Result**: 100% test pass rate and resolved parse errors.

### 3.29 Strategic Analysis: Breaking the E0308 Stalemate (DEPYLER-1100)
*Status: COMPLETE* (Jan 13, 2026)

*   **Problem**: E0308 (Type Mismatch) remains the dominant blocker at 3321 errors across 198 failing files. Pattern-by-pattern fixing scales linearly, and after months of effort, fundamental architectural changes may be needed.

*   **Five Architectural Strategies Evaluated**:
    1.  **Inverse Lowering** (DepylerValue-first): Generate everything as `DepylerValue`, then optimize to concrete types.
        *   ‚úÖ Guarantees 100% compile rate immediately
        *   ‚ùå Defeats transpilation purpose (users want typed Rust)
        *   ‚ùå Runtime dispatch eliminates performance benefits
        *   *Infrastructure*: `DepylerValue` already exists (Int, Float, Str, Bool, List, Dict, Tuple)

    2.  **Trait-Based Dispatch** (PyOps): Define `PyAdd<Rhs>`, `PyIndex<I>`, `PyTruthy` traits.
        *   ‚úÖ Leverages Rust's trait resolution system
        *   ‚úÖ Architecturally sound, long-term scalable
        *   ‚ùå High implementation effort
        *   *Infrastructure*: Minimal (would need to build from scratch)

    3.  **Global Unification Engine** (Hindley-Milner Lite): Constraint-based type inference with Union-Find.
        *   ‚úÖ Theoretically sound, solves propagation issues
        *   ‚ùå Very high implementation effort
        *   ‚ùå Python's gradual typing incompatible with full H-M
        *   *Infrastructure*: None

    4.  **Profile-Guided Optimization** (MonkeyType): Trace runtime types from execution.
        *   ‚úÖ Resolves ambiguity with actual data
        *   ‚ùå Requires test execution before transpilation
        *   ‚ùå Not universal for all users
        *   *Infrastructure*: None

    5.  **Automated Oracle Loop** (Compiler-Driven Repair): Parse rustc errors, extract constraints, re-transpile.
        *   ‚úÖ Uses rustc as ultimate source of truth
        *   ‚úÖ Builds on existing 70% infrastructure (OracleCategory, ErrorClassifier, OracleQueryLoop)
        *   ‚úÖ Lowest risk, fastest to implement
        *   *Infrastructure*: Substantial (oracle_shim.rs, classifier.rs, depyler_oracle crate)

*   **Recommendation: Phased Hybrid Approach**:
    *   **Phase 1 (Immediate)**: Enhanced Oracle Loop (#5)
        - Parse E0308 `expected X, found Y` messages systematically
        - Extract type constraints to annotation file
        - Re-transpile with learned type hints
    *   **Phase 2 (Medium-term)**: Targeted Trait Dispatch (#2) for hot spots
        - `PyNumeric`: i32/f64 arithmetic coercion
        - `PyIndex`: Collection indexing
        - `PyTruthy`: Boolean coercion

*   **Initial Implementation**: Added `infer_iterable_element_type()` and `with_additional_param()` methods to ExprConverter for generator expression type propagation. Regression tests: `test_depyler_1100_float_comparison_coercion`, `test_depyler_1100_list_comp_type_propagation`.

### 3.30 Root Cause: Inference Black Box (DEPYLER-1148)
*Status: FIXED* (Jan 16, 2026)

*   **Problem**: The transpiler reached a plateau at 43%. While the Oracle identified errors, the internal reasoning for incorrect type mappings (e.g., Slices) was invisible.
*   **Why 1**: Why did `slice_example` become a `String` when base was `Vec<i32>`?
    *   *Answer*: The inference engine lacked base-aware context and defaulted to a generic "Collection" pattern which heuristics misidentified as String.
*   **Why 2**: Why was this hard to debug?
    *   *Answer*: The transpilation pipeline was a "Black Box" with no visibility into alternative paths considered.
*   **Resolution**: Activated the **CITL Flight Recorder**.
    1. Hooked `init_decision_tracing()` into the main CLI entry point.
    2. Enabled the `decision-tracing` feature flag.
    3. Instrumenting the pipeline with `trace_decision!` macros to capture `TypeMapping`, `BorrowStrategy`, and `MethodDispatch` logs.
*   **Result**: Decisions are now captured to `/tmp/depyler_decisions.msgpack` for causal chain analysis, enabling pinpoint precision in fixing semantic gaps.

## 4. Structural Typing Solutions

### 4.1 Automated Oracle Loop (DEPYLER-1101) - Multi-Pass Architecture
To break the type-inference stalemate, Depyler has evolved into a **Multi-Pass Compiler**. It implements a feedback loop using `rustc` itself as the inference engine.

**Workflow**:
1.  **Pass 1 (Heuristic)**: Transpile Python ‚Üí Rust using best-guess heuristics.
2.  **Oracle (Verification)**: Run `cargo check` to generate JSON diagnostics.
3.  **Learning (Constraint Extraction)**: Identify E0308 "expected T, found U" constraints from the compiler output.
4.  **Feedback (Refinement)**: Inject the "expected" type back into the Python-side symbol table.
5.  **Pass 2 (Corrected)**: Re-transpile with guaranteed-correct type hints.

**Theoretical Grounding**:
This architecture ("Compiler-Driven Repair") leverages the destination language's compiler as a static oracle. It parallels techniques found in:
*   **Static JIT**: Profiling types via compilation errors rather than runtime execution (similar to V8/JVM optimization loops).
*   **Type Holes (Haskell/GHC)**: Using the compiler to deduce missing information.
*   **Automated Program Repair**: Iterative generate-test-fix cycles (e.g., SapFix), but applied at the compilation stage for speed.

### 4.2 PyOps Trait Dispatch (DEPYLER-1102)
Instead of manual casting in the transpiler, we shift complexity to Rust's trait system.
*   **Trait**: `PyAdd<Rhs>`, `PyGetItem`, `PyTruthy`.
*   **Impls**: Implement these traits for `i32`, `f64`, `String`, and `DepylerValue`.
*   **Codegen**: Generate `x.py_add(y)` instead of `(x as f64) + y`. The Rust compiler resolves the correct implementation at compile time.

### 4.3 Strategy 6: The Sovereign Type DB (DEPYLER-1111)
**Concept**: A "Type Truth Database" generated deterministically from the top 100 Python libraries using `uv` (logistics) and `rustpython_parser` (extraction). This provides the "Reference Manual" that `depyler` currently lacks.

**See [Section 6: Sovereign Type Database](#6-sovereign-type-database-depyler-1111)** for full specification with:
- Peer-reviewed citations (PEP 484, PEP 561, Apache Parquet)
- Architecture diagram and TypeFact schema
- Strong falsification criteria

**Goal**: Eliminate the remaining 3,459 `E0308` errors by providing ground truth for external library types.

---

## 5. Performance Infrastructure (Giant RAM Strategy)

To mitigate the I/O bottleneck inherent in generating and compiling hundreds of Cargo projects during convergence, Depyler mandates the use of **RAM Disks** on systems with sufficient memory.

**Specification**:
*   **Target Volume**: `/Volumes/DepylerRAM`.
*   **Recommended Size**: 64GB - 256GB.
*   **Enforcement**: All build artifacts and temporary files MUST be redirected to the RAM disk via environment variables.

**Configuration (`.env.ramdisk`)**:
```bash
export TMPDIR=/Volumes/DepylerRAM/tmp
export CARGO_TARGET_DIR=/Volumes/DepylerRAM/cargo_target
mkdir -p $TMPDIR
mkdir -p $CARGO_TARGET_DIR
```

**Impact**: eliminates disk I/O latency for `target/` directories, reducing convergence run times by ~60-80%.

---

## 6. Sovereign Type Database (DEPYLER-1111)

### 6.1 The Architectural Mandate

We are fighting 3,459 E0308 type mismatch errors. We are losing because we are **guessing** types. To win, we must stop guessing and start **knowing**.

The **Sovereign Type Database** is a compact, binary artifact containing function signatures and type definitions of popular Python libraries‚Äîgenerated locally using Pure Rust, without reliance on external CI/CD.

### 6.2 Peer-Reviewed Foundation

| Citation | Year | Relevance |
|----------|------|-----------|
| **PEP 484** (van Rossum, Lehtosalo) | 2014 | Type Hints - Defines annotation syntax |
| **PEP 561** (Smith) | 2017 | Stub Distribution - Defines `.pyi` format |
| **PEP 585** (Langa) | 2019 | Generic Syntax - `list[int]` standardization |
| **typeshed** (Python Core) | 2016+ | Reference stdlib stub implementation |
| **Apache Parquet Spec** (Apache Foundation) | 2013 | Columnar storage format |
| **Arrow Columnar Format** (Apache Foundation) | 2016 | Zero-copy data interchange |
| **uv** (Astral) | 2024 | 10-100x faster deterministic resolution |

### 6.3 Technical Specification

**New Component**: `crates/depyler-knowledge`

**The Sovereign Stack**:
1. **Logistics**: `uv pip install --target` for deterministic package fetching
2. **Extraction**: `rustpython_parser` for `.pyi` stub parsing
3. **Storage**: Apache Parquet via `arrow` crate for efficient queries

**Data Schema** (The Truth):
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TypeFact {
    pub module: String,       // e.g., "requests"
    pub symbol: String,       // e.g., "get"
    pub kind: String,         // "function", "class", "method"
    pub signature: String,    // "(url: str, params: dict = None) -> Response"
    pub return_type: String,  // "requests.models.Response"
}
```

### 6.4 Architecture Diagram

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    SOVEREIGN TYPE DB                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
‚îÇ  ‚îÇ Harvester‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ Extractor ‚îÇ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ Parquet DB   ‚îÇ          ‚îÇ
‚îÇ  ‚îÇ   (uv)   ‚îÇ    ‚îÇ(rustpython‚îÇ    ‚îÇ (arrow v54)  ‚îÇ          ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îÇ  parser)  ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
‚îÇ       ‚îÇ          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ                   ‚îÇ
‚îÇ       ‚ñº                                  ‚ñº                   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ
‚îÇ  ‚îÇ PyPI     ‚îÇ                    ‚îÇ Query API    ‚îÇ           ‚îÇ
‚îÇ  ‚îÇ packages ‚îÇ                    ‚îÇ find_sig()   ‚îÇ           ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ
‚îÇ                                          ‚îÇ                   ‚îÇ
‚îÇ                                          ‚ñº                   ‚îÇ
‚îÇ                                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê           ‚îÇ
‚îÇ                                  ‚îÇ depyler-core ‚îÇ           ‚îÇ
‚îÇ                                  ‚îÇ type_mapper  ‚îÇ           ‚îÇ
‚îÇ                                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### 6.5 CLI Usage

```bash
# Build type database for specific packages
cargo run -p depyler-knowledge --bin build-type-db -- \
    --packages "requests,numpy,pandas" \
    --output crates/depyler-core/src/data/stdlib_types.parquet

# Query the database
depyler type-lookup requests.get
# Output: (url: str, params: Optional[dict] = None, **kwargs) -> Response
```

---

## 7. Falsification Framework

### 7.1 The Popperian Mandate

Per Karl Popper's falsificationism, scientific claims must be **testable and falsifiable**. Each DEPYLER feature includes explicit falsification criteria‚Äîtests that would **disprove** the implementation's correctness.

### 7.2 DEPYLER-1111 Falsification Criteria

The Sovereign Type Database is **REJECTED** if ANY condition is true:

#### Functional Falsifiers

| ID | Criterion | Test | Threshold |
|----|-----------|------|-----------|
| F1 | Harvester cannot fetch `requests` | `cargo test harvest_requests` | MUST pass |
| F2 | Extractor misses `requests.get` | Query validation | Symbol MUST exist |
| F3 | Extractor misses `Response` class | Query validation | Symbol MUST exist |
| F4 | Extractor misses `Response.json` method | Query validation | Symbol MUST exist |
| F5 | Parquet roundtrip loses data | Property test (1000 iter) | 0% loss |
| F6 | `find_signature("requests", "get")` fails | Integration test | MUST return signature |

#### Quality Falsifiers

| ID | Criterion | Tool | Threshold |
|----|-----------|------|-----------|
| Q1 | TDG exceeds limit | `pmat tdg check-quality` | TDG ‚â§ 2.0 |
| Q2 | Cyclomatic complexity | `pmat analyze complexity` | ‚â§ 10/function |
| Q3 | Cognitive complexity | `pmat analyze complexity` | ‚â§ 10/function |
| Q4 | Test coverage | `cargo llvm-cov` | ‚â• 80% |
| Q5 | SATD markers | `pmat analyze satd` | 0 markers |

#### Performance Falsifiers

| ID | Criterion | Measurement | Threshold |
|----|-----------|-------------|-----------|
| P1 | `requests` extraction time | Wall clock | < 30 seconds |
| P2 | Query latency | Benchmark | < 1ms |
| P3 | Parquet file size | File size | < 1MB for requests |

#### Strategic Falsifier (The Gap Test)

| ID | Criterion | Measurement | Threshold |
|----|-----------|-------------|-----------|
| **S1** | **E0308 Error Reduction** | Convergence run before/after | **‚â•10% reduction** |

**The Gap Falsifier**: If `depyler-knowledge` is integrated but E0308 errors (currently 3,459) do not decrease by at least 10%, the Sovereign Type Database strategy is **FALSIFIED**. The database exists to eliminate type guesswork‚Äîif the error count remains static, the implementation has failed its mission regardless of technical correctness.

### 7.3 Validation Protocol

```bash
# Run falsification suite
cargo test -p depyler-knowledge --test falsification

# Expected output:
# F1: harvest_requests ................ PASS
# F2: extractor_finds_get ............. PASS
# F3: extractor_finds_response ........ PASS
# F4: extractor_finds_json_method ..... PASS
# F5: parquet_roundtrip_property ...... PASS (1000/1000)
# F6: query_signature_requests_get .... PASS
# Q1-Q5: quality_gates ................ PASS
# P1-P3: performance_benchmarks ....... PASS
#
# FALSIFICATION RESULT: NOT FALSIFIED (Implementation Valid)
```

---

## Appendix C: The Karl Popper Falsification Strategy (100-Point)

### I. Type System Falsifiers (Points 1-20)

101. [x] ~~**Heterogeneous Unpacking**~~ **FIXED**: `x, y = (1, "a")`. (DEPYLER-1064)
104. [x] ~~**Datetime Methods**~~ **FIXED**: `d.day`, `dt.now()`. (DEPYLER-1066/67/68/69)
105. [x] ~~**Regex Methods**~~ **FIXED**: `m.group(1)`, `re.split()`. (DEPYLER-1070)
106. [x] ~~**Option Truthiness**~~ **FIXED**: `if m:` where `m` is `Option<T>`. (DEPYLER-1071)
107. [x] ~~**Numeric Coercion**~~ **FIXED**: `f64_var == 0` -> `f64_var == 0.0`. (DEPYLER-1072)
108. [x] ~~**Float Keys**~~ **FIXED**: `{0.1: "a"}` -> `HashMap<DepylerValue, ...>`. (DEPYLER-1073)
109. [x] ~~**Reference Comparisons**~~ **FIXED**: `.filter(|x| x > 0)` -> `.filter(|&x| x > 0f64)`. (DEPYLER-1074)
110. [x] ~~**impl Iterator Lifetimes**~~ **FIXED**: `fn f(v: &Vec) -> impl Iterator` -> `fn f<'a>(v: &'a Vec) -> impl Iterator + 'a`. (DEPYLER-1075)
111. [x] ~~**Closure Ownership**~~ **FIXED**: `.filter(|x| x > val)` -> `.filter(move |x| x > val)` when returning impl Iterator. (DEPYLER-1076)
112. [x] ~~**String Iterator**~~ **FIXED**: `for c in text` -> `text.chars()` with proper ord(c) handling. (DEPYLER-1077)
113. [x] ~~**Generator/Iterator Fixes**~~ **FIXED**: Clone params in generator structs, `next(iter, None)` returns `.next()`, iterator vars are mutable. (DEPYLER-1078)
114. [x] ~~**Result Optional Returns**~~ **FIXED**: `return x if cond else None` in `Result<Option<T>>` functions now generates `Ok(if cond { Some(x) } else { None })`. (DEPYLER-1079)
115. [x] ~~**Zip Tuple Cloning**~~ **FIXED**: `zip(list1, list2)` on references adds `.map(|(a,b)| (a.clone(), b.clone()))` for owned tuple returns. (DEPYLER-1079)
116. [x] ~~**Lifetime Unification**~~ **FIXED**: `fn f(v: &'a Vec, s: &'b str) -> impl Iterator + 'a` now unifies all params to `'a`. (DEPYLER-1080)
117. [x] ~~**Tuple Filter Patterns**~~ **FIXED**: `.filter(|&(i, v)| ...)` ‚Üí `.filter(|(i, v)| ...)` to avoid E0507 on non-Copy elements. (DEPYLER-1081)
118. [x] ~~**Generator Iterator State**~~ **FIXED**: Generators with `Iterator[int]` params now use `Box::new()` wrapper, manual Debug impl, and `while let Some(x) = self.g.next()` iteration. (DEPYLER-1082)
119. [x] ~~**Integer Cast Precedence**~~ **FIXED**: `data[i:i+size]` now parenthesizes slice indices: `(i + size) as isize` instead of `i + size as isize` to prevent i32 + isize mixing. (DEPYLER-1083)
120. [x] ~~**Return Type Inference**~~ **FIXED**: `def f(): x + y` no longer infers return type from expression statements. Only explicit `return x` contributes to return type. (DEPYLER-1084)
121. [x] ~~**Value Lifting**~~ **FIXED**: `data[i] if cond else 0` where `data` has Unknown element type now lifts concrete branch to DepylerValue for type unification. (DEPYLER-1085)
122. [x] ~~**Time Module Tests**~~ **FIXED**: Corrected time tests (ctime, gmtime, localtime) to expect std::time output in NASA mode (default) instead of chrono types. Core test suite achieves GREEN BOARD. (DEPYLER-1086)
123. [x] ~~**Parse Errors (Brace Mismatch)**~~ **FIXED**: Root cause was inline `clap` attributes being removed along with their lines in NASA mode. Fixed by reordering attribute removal. (DEPYLER-1088)
124. [x] ~~**Literal Coercion**~~ **FIXED**: Coerce int literals to float in comparisons and inject `.clone()` for ref assignments. (DEPYLER-1100)
125. [x] ~~**Oracle Type Repair**~~ **COMPLETE**: Automate re-transpilation based on `rustc` diagnostic output. (DEPYLER-1101/1102/1133)
126. [x] ~~**PyOps Codegen Integration**~~ **FIXED**: Updated binary_ops.rs and expr_gen.rs to generate `.py_add()`/`.py_sub()` for `DepylerValue`. (DEPYLER-1106)
127. [x] ~~**Sovereign Type DB**~~ **COMPLETE**: `depyler-knowledge` crate built. Validated extraction of 838 facts from `requests`. (DEPYLER-1111)
128. [x] ~~**Type DB Integration**~~ **COMPLETE**: Wired `TypeQuery` into `CodeGenContext` behind `sovereign-types` feature. (DEPYLER-1112)
129. [x] ~~**Activate Sovereign Types**~~ **COMPLETE**: Synapse activation. `expr_gen.rs` queries TypeDB on MethodCall, `stmt_gen.rs` propagates return types to `var_types`. (DEPYLER-1113)
130. [x] ~~**Knowledge Ingestion**~~ **COMPLETE**: Harvested `requests` library (289 type facts, 21KB parquet). TypeQuery validated. (DEPYLER-1114)
131. [x] ~~**Phantom Structure Bindings**~~ **COMPLETE**: Implemented JIT binding generation for external library types. Generates `struct Response(pub serde_json::Value)` wrappers from TypeDB. Eliminates E0412 (Type Not Found). (DEPYLER-1115)
132. [x] ~~**Semantic Method Realization**~~ **COMPLETE**: Implemented Proxy Pattern with `generate_default_return` to replace `todo!()` stubs with sensible defaults (0, "", None). (DEPYLER-1116)
133. [x] ~~**Lambda Type Inference**~~ **COMPLETE**: Added `infer_lambda_param_type()` to analyze lambda body expressions. Detects iterator patterns (ListComp, SetComp) to infer `Vec<i64>` and PyOps arithmetic to infer `i64`. E0282 reduced from 14‚Üí10 (-28.6%). (DEPYLER-1117)
134. [x] ~~**PyStringMethods Trait**~~ **COMPLETE**: Implemented Python string method parity (`lower`, `upper`, `strip`, `startswith`, `endswith`, etc.) for `str`, `String`, and `DepylerValue`. Added `PyMul`/`PyAdd` for `&str`. E0599 reduced from 39‚Üí32 (-17.9%). Compile rate 31.2%‚Üí33.0%. (DEPYLER-1118)
135. [x] ~~**Constraint-Aware Coercion**~~ **COMPLETE**: Generator obeys Oracle types for method calls (e.g., push, append). (DEPYLER-1134)
136. [x] ~~**Alias Stub Generation**~~ **COMPLETE**: Resolved E0425/E0423 by generating Rust module stubs for Python aliases (e.g., `import xml.etree.ElementTree as ET`). (DEPYLER-1136)
137. [x] ~~**Property Promotion**~~ **COMPLETE**: Automatically promoted Python property access (.tag, .text) to Rust method calls (.tag(), .text()) for XML proxies. (DEPYLER-1138)
138. [x] ~~**Stub Signature Refinement**~~ **COMPLETE**: Updated module alias stubs to use variadic-friendly generic signatures (`<S: AsRef<str>>`, `<P>`, `<E>`) instead of hardcoded types. Added XML functions (parse, ElementTree, iterparse, get). E0061 reduced from 16‚Üí15. (DEPYLER-1139)
139. [x] ~~**Numeric Coercion**~~ **COMPLETE**: Unified mixed int/float operations via NumPy NASA mode coercion. All numpy aggregations (sum, mean, dot, min, max, std, var, norm) now coerce to f64. (DEPYLER-1135)
140. [x] ~~**Typed Dict Value Coercion**~~ **COMPLETE**: Dict literals with concrete value type annotations (e.g., Dict[str, float]) now coerce values to target type instead of wrapping in DepylerValue. (DEPYLER-1141)
141. [x] ~~**Inference Black Box**~~ **FIXED**: Activated CITL Flight Recorder (Decision Tracing) to expose internal reasoning for causal chain analysis. (DEPYLER-1148)

**End of Specification**
```