# 1.0 Single-Shot Compile Specification: The Unified Standard

**Version**: 1.10.1 (Clippy Fixes + Metrics Update)
**Date**: 2026-01-09
**Status**: **ACTIVE IMPLEMENTATION**
**Authors**: Depyler Team
**Based On**:
- `pareto-complete-single-shot.md` (Strategy)
- `root-cause-single-shot-compile.md` (Architecture Status)
- `nasa-single-shot-compile.md` (Safety Standards)
- `single-shot-compile-spec.md` (User Experience)

---

## 1. Executive Summary

### Vision
Enable Python developers to compile **ANY** Python script to a highly optimized, type-safe Rust binary with a single command. The system must operate without manual intervention, achieving "NASA-grade" reliability through rigorous type inference and semantic verification.

```bash
# The Promise
depyler compile my_script.py --release
# Result: ./my_script (native binary, 10-50x faster)
```

### Current Status (Jan 2026)
The project has emerged from "Architectural Halt" and pivoted to the **Hybrid Fallback Strategy**.
*   **Compile Rate**: 65/177 (36.7%) â€” verified against depyler examples corpus (Jan 9, 2026)
*   **Verification**: The "Falsification Suite" (designed to break the compiler) now compiles successfully.
*   **Next Milestone**: 80% Convergence (Pareto-Complete Phase).
*   **Strategic Pivot**: Implemented `DepylerValue` (universal enum) as the fallback for all uncertain types.
*   **DEPYLER-1060**: FIXED â€” Module-level constant types now persist across function boundaries.
*   **Clippy Status**: Workspace passes `cargo clippy -- -D warnings` (zero warnings).
*   **Oracle Integration**: The Oracle model (`depyler_oracle.apr`) is currently trained on 12,282 samples with 85% accuracy (last retrained Jan 7, 2026). It serves as the optimization engine for Profile-Guided Type Inference.

### Current Blockers (Top 3 Failure Patterns)
1. **Lambda type inference** (E0282): Lambda parameters lack type annotations causing `type must be known at this point`.
2. **DepylerValue wrapping** (E0308): Return values not consistently wrapped in `DepylerValue::Int()` etc.
3. **Dict key type mismatch**: Return type `HashMap<String, ...>` vs built `HashMap<DepylerValue, ...>`.

### Quick Reference (Live Metrics)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  SINGLE-SHOT COMPILE DASHBOARD                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Compile Rate:  65/177 (36.7%)  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘  37%   â”‚
â”‚  Target:        80%             â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘  80%   â”‚
â”‚                                                             â”‚
â”‚  âœ… DEPYLER-1040b COMPLETE: Const inference fixed           â”‚
â”‚  âœ… DEPYLER-1060 COMPLETE: Module constant types fixed      â”‚
â”‚  âœ… CLIPPY CLEAN: Zero warnings in workspace                â”‚
â”‚  âœ… STRATEGIC PIVOT: Hybrid Fallback Strategy ACTIVE        â”‚
â”‚                                                             â”‚
â”‚  ğŸ§  ORACLE STATUS: v3.21.0 (85% Accuracy)                   â”‚
â”‚   Location: crates/depyler/depyler_oracle.apr               â”‚
â”‚   Last Train: Jan 7, 2026 (12,282 samples)                  â”‚
â”‚                                                             â”‚
â”‚  ğŸ”´ BLOCKERS: Lambda inference, DepylerValue wrapping       â”‚
â”‚  Next Action:   Fix lambda type annotations for 50%+ goal   â”‚
â”‚  Falsification: Point 14 FIXED (Dict integer keys work)     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. User Experience & CLI

### 2.1 Design Principles
1.  **"Just Works"**: No knowledge of Rust, Cargo, or lifetimes required.
2.  **Intelligent Defaults**: Workload detection selects the optimal profile.
3.  **Fast Feedback**: Errors are mapped back to Python source lines.

### 2.2 Command Interface

```bash
USAGE:
    depyler compile [OPTIONS] <SCRIPT>

ARGS:
    <SCRIPT>    Python script to compile (.py file)

OPTIONS:
    --profile <PROFILE>   Optimization profile [auto|release|perf-ultra|min-size]
    --pgo                 Enable Profile-Guided Optimization (Uses DepylerValue Telemetry)
    --verify              Run differential testing (Python vs Rust output)
    --target <TARGET>     Cross-compile (e.g., aarch64-unknown-linux-gnu)
```

---

## 3. Architecture & Root Cause Resolution

### 3.1 Post-Mortem Resolution (RC-1 to RC-3)
We have eradicated the "fragile regex" architecture in favor of robust AST analysis.

| Root Cause | Issue | Fix Implementation | Status |
|------------|-------|--------------------|--------|
| **RC-1** | For-loops destroyed by string matching | `syn::parse2` AST extraction | **FIXED** |
| **RC-2** | Naive `Dict[str, Any]` mapping | `DepylerValue` sum type injection | **FIXED** |
| **RC-3** | `try/except` return type mismatch | Binary expr inference + `Ok()` wrapping | **FIXED** |

### 3.2 Correctness-First Architecture
We adhere to the **Toyota Way** principles: correctness before optimization.

1.  **Renacer Tracing**: Observability into every transpilation decision (AST -> HIR -> Rust).
2.  **Scalar-First Inference**: Hindley-Milner type inference (Algorithm W) is used instead of premature SIMD/ML optimization.
3.  **Differential Testing**: We validate `Output(Python) == Output(Rust)` to ensure semantic equivalence.

### 3.3 Debugging & Observability Protocol
To prevent "Whack-a-Mole" debugging, we utilize **Renacer** for full-stack observability.

**Workflow**:
1.  **Trace Generation**: `depyler transpile input.py --trace > trace.json`
2.  **Source Map Analysis**: `renacer --map input.rs.sourcemap.json --analyze error.log`
3.  **Decision Audit**: Review `trace.json` to see *why* a type was inferred as `Unknown`.

### 3.4 Root Cause Analysis: The Five Whys Standard
Every architectural failure must undergo a "Five Whys" analysis before code is written.

### 3.5 Five-Whys: Heterogeneous Dict Attribute Access (DEPYLER-1040)
*Status: FIXED* - Correctly detects mixed types in dict literals using Attribute access and falls back to `DepylerValue`.

### 3.6 Five-Whys: char vs String Type Mismatch (DEPYLER-1045)
*Status: FIXED* - Resolved 5 sub-issues involving cross-function variable contamination and string iteration mismatches.

### 3.7 Five-Whys Summary Matrix

| Ticket | Root Cause | Files Changed | Validation |
|--------|------------|---------------|------------|
| DEPYLER-1040 | Attribute detection for mixed types | `expr_gen_instance_methods.rs` | `comprehensive_cli.rs` compiles |
| DEPYLER-1040b | Const inference using simplified path | `rust_gen.rs`, `type_hints.rs` | Unary/Binary consts fixed |
| DEPYLER-1045a | `fn_str_params` cross-contamination | `func_gen.rs` | `test_string_module.rs` compiles |
| DEPYLER-1045b | `Type::String` not tracked | `stmt_gen.rs` | Auto-borrow works |
| DEPYLER-1045c | `chr()` precedence | `builtin_functions.rs` | Arithmetic expressions work |
| DEPYLER-1045d | String methods not iterators | `stmt_gen.rs` | `text.lower()` iteration works |
| DEPYLER-1045e | Dict annotation mismatch | `expr_gen_instance_methods.rs` | DepylerValue wrapping correct |
| DEPYLER-1050 | Return typeâ†’DepylerValue propagation | `expr_gen_instance_methods.rs`, `stmt_gen.rs` | Subscript assignments now wrap |
| DEPYLER-1051 | Universal Fallback Implementation | `type_mapper.rs`, `rust_gen.rs` | `DepylerValue` supports Arithmetic/Hash |
| DEPYLER-1060 | Module constant types lost per-function | `context.rs`, `rust_gen.rs`, `expr_gen_instance_methods.rs` | Point 14 dict integer keys compile |

### 3.8 Five-Whys: Module Constant Types (DEPYLER-1060)

**Symptom**: `d = {1: "a"}` at module level compiled, but `val = d[1]` inside `main()` failed with `E0308: expected &DepylerValue, found usize`.

*   **Why 1**: Why did `d[1]` generate `.get(1usize)` instead of `.get(&DepylerValue::Int(1))`?
    *   *Answer:* `is_dict_expr()` returned `false` for variable `d` inside the function.
*   **Why 2**: Why didn't `is_dict_expr()` recognize `d` as a dict?
    *   *Answer:* It checks `var_types` for the variable's type, but `d` wasn't in `var_types`.
*   **Why 3**: Why wasn't `d` in `var_types`?
    *   *Answer:* `var_types.clear()` is called at the start of each function (line 585, `func_gen_inference.rs`) to prevent cross-function type leaking.
*   **Why 4**: Why was the module-level constant type pre-registration in `var_types`?
    *   *Answer:* The original fix (earlier in this session) added constants to `var_types`, not realizing it would be cleared.
*   **Why 5**: Why wasn't there a separate storage for module-level types?
    *   *Answer:* Architectural oversight â€” all type tracking was conflated into `var_types`.

**Corrective Action**: Added `module_constant_types: HashMap<String, Type>` field to `CodeGenContext`. This field is NOT cleared per-function and is checked by `is_dict_expr()`, `is_list_expr()`, and `is_set_var()` after checking `var_types`.

### 3.9 Five-Whys: The Heuristic Purge (DEPYLER-1040b)

**Symptom**: Unary operations in consts like `not True` were inferred as `String`.

*   **Why 1**: Why did `not True` become `pub const x: String = !true`?
    *   *Answer:* `infer_unary_type` defaulted to `String` if the operand wasn't a literal.
*   **Why 2**: Why didn't it use the expression's actual type?
    *   *Answer:* `const_gen` used a "simplified" inference path that didn't recurse into sub-expressions properly.
*   **Why 3**: Why was there a simplified path?
    *   *Answer:* Assumption that consts would be simple literals only.
*   **Why 4**: Why were there variable-name heuristics like `if var_name.contains("path")`?
    *   *Answer:* Historical "Whack-a-Mole" fixes to guess types where inference failed.
*   **Why 5**: Why was this purged now?
    *   *Answer:* "If you write var_name.contains(...), you are fired." Heuristics are the enemy of NASA-grade reliability.

**Corrective Action**: Deleted 20+ lines of heuristics in `type_hints.rs`. Unified `infer_unary_type` to handle all expression types.

### 3.10 Five-Whys: Lambda Type Inference (DEPYLER-1061)

*Status: DOCUMENTED AS LIMITATION* - Requires bidirectional type inference (future work).

**Symptom**: `let double = lambda lst: [x * 2 for x in lst]` fails with E0282 "type annotations needed".

*   **Why 1**: Why does Rust need type annotations for lambda parameters?
    *   *Answer:* The lambda `move |lst| lst.iter()...` is stored in a variable, and Rust can't infer `lst`'s type without context.
*   **Why 2**: Why can't we add DepylerValue type annotations?
    *   *Answer:* We tried! But `move |lst: DepylerValue| ...` breaks call sites that pass raw integers/strings.
*   **Why 3**: Why do call sites break?
    *   *Answer:* `double(numbers)` passes `Vec<i32>`, but the lambda expects `DepylerValue`. No automatic conversion.
*   **Why 4**: Why not infer the type from how the lambda is called?
    *   *Answer:* Requires **bidirectional type inference** - propagating types from usage back to definition. This is complex.
*   **Why 5**: Why not just wrap call site arguments?
    *   *Answer:* Would break lambdas used with different types in different calls. Need full constraint solving.

**Architectural Insight**: Lambda type inference is fundamentally different from function inference because:
1. Lambdas have no type annotations in Python
2. Lambdas can be stored in variables (deferred usage)
3. Same lambda can be called with different types

**Workaround**: Use named functions instead of lambdas for complex cases. Lambdas work when used inline (e.g., `map(lambda x: x*2, lst)`).

**Future Work**: Implement constraint-based type inference (Algorithm W variant) that:
1. Collects all usage sites of a lambda
2. Unifies the types across all usages
3. Falls back to DepylerValue only when types conflict

---

## 4. Strategy: The Path to 80% (Pareto-Complete)

### 4.0 STRATEGIC PIVOT: The Hybrid Fallback Strategy (Jan 2026)

**Status**: APPROVED & ACTIVE

**Principle**: "If unsure, use DepylerValue. Never guess."

| Scenario | Action | Rationale |
|----------|--------|-----------|
| Literal `42`, `"str"`, `true` | Use concrete type (`i32`, `String`, `bool`) | 100% certain |
| Annotated `x: int = ...` | Use annotated type (`i32`) | Explicit constraint |
| Empty/Mixed Containers | Use `HashMap<DepylerValue, DepylerValue>` | Fallback required |
| Unknown/Ambiguous | Use `DepylerValue` | **NEVER GUESS** |

### 4.1 DepylerValue as Active Telemetry (Profile-Guided Type Inference)

We shift `DepylerValue` from a **passive fallback** to an **active probe**.

**Strategic Impact**: The Hybrid Fallback is the **necessary bridge** to optimization. We cannot optimize what we cannot compile.

#### The Oracle Baseline (v3.21.0)
*   **Location**: `crates/depyler/depyler_oracle.apr`
*   **Lineage**: `crates/depyler/.depyler/oracle_lineage.json`
*   **Last Train**: Jan 7, 2026 (12,282 samples)
*   **Accuracy**: 85% on historical defect prediction.

**Insight**: The current Oracle is trained on *failure* data (what broke). The new `DepylerValue` strategy will generate *success* data (runtime type usage). This will allow the Oracle to move from "Predicting Bugs" to "Predicting Types" for the next retraining cycle.

#### The Static Dictionary Key Vulnerability (DEPYLER-1060) â€” RESOLVED
**Status**: âœ… FIXED (Jan 9, 2026)

**Root Cause**: Module-level constant types were registered in `var_types`, but `var_types` was cleared at the start of each function (line 585 in `func_gen_inference.rs`). This caused `is_dict_expr()` to not recognize module-level dict constants when accessed from within functions.

**Solution**: Added `module_constant_types: HashMap<String, Type>` field to `CodeGenContext` that persists across function boundaries. Updated `is_dict_expr()`, `is_list_expr()`, and `is_set_var()` to check this field after `var_types`.

**Files Changed**:
- `context.rs`: Added `module_constant_types` field
- `rust_gen.rs`: Pre-register constants in `module_constant_types`
- `expr_gen_instance_methods.rs`: Check `module_constant_types` in type detection functions

**Validation**: Point 14 test `d = {1: "a"}; def main(): val = d[1]` now compiles correctly with `HashMap<DepylerValue, DepylerValue>` access.

---

## 5. The NASA Standard (95%+ Goal)

For mission-critical reliability, we define a "Falsification Checklist" based on **NASA-GB-8719.13**.

### 5.1 Single-Shot Definition
A compile is only successful if:
1.  `depyler transpile` succeeds.
2.  `rustc` succeeds (exit code 0).
3.  **Constraint**: No manual intervention, no `todo!()` macros, no `#![allow(warnings)]`.

---

## Appendix B: Peer-Reviewed Foundations

The architecture is grounded in the following computer science literature. Each strategy maps directly to a verified concept.

1.  **Type Inference**: Milner, R. (1978). "A Theory of Type Polymorphism in Programming." *Journal of Computer and System Sciences*.
    *   *Application*: Our **Scalar-First Inference** uses Algorithm W (Constraint Solving) rather than ad-hoc heuristics.
2.  **Abstract Interpretation**: Cousot, P. & Cousot, R. (1977). "Abstract Interpretation: A Unified Lattice Model for Static Analysis." *POPL '77*.
    *   *Application*: Our **Flow Analysis** approximates runtime values to determine types (e.g., `Option<T>` vs `T`).
3.  **Differential Testing**: McKeeman, W. M. (1998). "Differential Testing for Software." *Digital Technical Journal*.
    *   *Application*: Our **Verification Suite** compares `Output(Python) == Output(Rust)` to detect semantic drift.
4.  **Technical Debt**: Scully, D., et al. (2015). "Hidden Technical Debt in Machine Learning Systems." *NIPS*.
    *   *Application*: We explicitly rejected "Aprender" (ML-based regression) to avoid the "Pipeline Jungle" antipattern.
5.  **Program Slicing**: Weiser, M. (1984). "Program Slicing." *IEEE Transactions on Software Engineering*.
    *   *Application*: **Renacer Tracing** slices the transpilation process to map output errors back to input source lines.
6.  **Gradual Typing**: Siek, J. G., & Taha, W. (2006). "Gradual Typing for Objects." *ECOOP 2007*.
    *   *Application*: **Hybrid Fallback Strategy** mirrors Gradual Typing, where `DepylerValue` acts as the dynamic `?` type that unifies with everything, allowing static and dynamic code to coexist.
7.  **Soundness of Interoperability**: Matthews, J., & Findler, R. B. (2007). "Operational Semantics for Multi-Language Programs." *POPL '07*.
    *   *Application*: Justifies our use of runtime wrappers (`DepylerValue`) at the boundaries of static inference to maintain soundness.
8.  **Profile-Guided Optimization**: Chen, D., et al. (2010). "Taming Hardware Event Samples for FDO." *CGO '10*.
    *   *Application*: Using **DepylerValue Telemetry** to drive type specialization in the Oracle phase.

---

## Appendix C: The Karl Popper Falsification Strategy (100-Point)

Per Karl Popper's philosophy, we do not prove the compiler works; we exhaustively try to prove it fails. If it survives these 100 falsification attempts, we provisionally accept it as "NASA-Ready".

### I. Type System Falsifiers (Points 1-20)
*If any of these occur, the Type System hypothesis is FALSE.*

1.  [ ] `Type::Unknown` present in generated code (Should be `DepylerValue`).
2.  [ ] `rustc` reports E0308 (Type Mismatch) on valid Python input.
3.  [ ] Generic type parameters (`T`) are undeclared in `impl` blocks.
4.  [ ] Trait bounds (`T: Display`) missing for utilized methods.
5.  [ ] Return type inference fails for branching logic (`if/else` returns diff types).
6.  [ ] `const` declaration infers `String` for non-string expression. âœ… **SOLVED (DEPYLER-1040b)**
7.  [ ] `E0282` (Type annotations needed) emitted by rustc.
8.  [ ] Conflicting trait implementations (`E0119`).
9.  [ ] Associated type missing (`Item` in Iterator).
10. [ ] Sizedness violation (`dyn Trait` without `Box`).
11. [ ] Union type (`int | str`) fails to map to `DepylerValue` or Enum.
12. [ ] `Optional[T]` fails to map to `Option<T>` or `DepylerValue`.
13. [ ] Dict assignment fails to unify key types.
14. [x] ~~**FALSIFIED**~~ **FIXED**: Constant Dict with integer keys `{1: "a"}` now correctly uses `HashMap<DepylerValue, DepylerValue>`. (DEPYLER-1060)
15. [ ] Lambda closure return type inference fails.
16. [ ] Class field types inconsistent across `__init__` paths.
17. [ ] Method overriding breaks signature compatibility.
18. [ ] Nested generics (`List[Dict[str, int]]`) fail to parse.
19. [ ] `TypeVar` remains unsubstituted in output.
20. [ ] `DepylerValue` propagation fails (unwrapped usage in strict context).

### II. Borrow Checker Falsifiers (Points 21-40)
*If any of these occur, the Ownership Model is FALSE.*

21. [ ] `E0596` (Cannot borrow immutable as mutable).
22. [ ] `E0507` (Cannot move out of borrowed content).
23. [ ] `E0382` (Use of moved value).
24. [ ] `E0502` (Mutable borrow occurs while immutable borrow active).
25. [ ] `E0499` (Multiple mutable borrows).
26. [ ] `E0597` (Value does not live long enough).
27. [ ] Lifetime mismatch (`'a` vs `'b`) in function signature.
28. [ ] Missing lifetime specifier (`E0106`).
29. [ ] `Clone` called on non-Clone type.
30. [ ] Unnecessary `clone()` detected by Clippy.
31. [ ] `self` mutation in non-`mut` method.
32. [ ] Field access on moved struct.
33. [ ] Return reference to local variable (`E0515`).
34. [ ] Closure captures variable incorrectly (move vs ref).
35. [ ] Iterator invalidation (modifying collection while iterating).
36. [ ] `RefCell` panic potential (runtime borrow check).
37. [ ] `Rc` cycle potential (memory leak).
38. [ ] Raw pointer usage (`*const`) detected.
39. [ ] `transmute` usage detected (Unsafe!).
40. [ ] `unsafe` block generated without justification.

### III. Semantic Equivalence & Runtime Falsifiers (Points 41-60)
*If output differs or panics, the Translation is FALSE.*

41. [ ] Stdout output differs between Python and Rust.
42. [ ] Integer overflow wraps in Rust but promotes in Python (without handling).
43. [ ] `DepylerValue` operation panics at runtime (e.g., `Add` on incompatible variants).
44. [ ] `DepylerValue` method missing (E0599 at compile time or runtime panic).
45. [ ] Exception not correctly mapped to `Result` or panic.
46. [ ] `None` handling differs (Option unwrapping).
47. [ ] List mutation visibility differs (reference semantics).
48. [ ] Dict iteration order assumptions broken.
49. [ ] Set operation semantics differ.
50. [ ] Slice indexing (negative indices) panics in Rust.
51. [ ] `__str__` / `Display` output format mismatch.
52. [ ] Default argument mutation persistence (Python quirk) missing.
53. [ ] Generator lazy evaluation semantics broken.
54. [ ] Context manager (`with`) cleanup order differs.
55. [ ] Decorator execution order differs.
56. [ ] Class inheritance method resolution order (MRO) differs.
57. [ ] Multiple inheritance flattening fails.
58. [ ] Property getter/setter side-effects missing.
59. [ ] Static/Class method behavior mismatch.
60. [ ] Magic method (`__add__`, etc.) precedence mismatch.

### IV. Context & Recursion Falsifiers (Points 61-80)
*If context leaks or recursion fails, the Architecture is FALSE.*

61. [ ] Variable leakage between function scopes (Context Contamination).
62. [ ] Type inference infinite recursion (Stack Overflow in compiler).
63. [ ] `DepylerValue` infinite nesting (Memory exhaustion).
64. [ ] Mutual recursion causes type inference failure (Requires DepylerValue).
65. [ ] Forward reference fails to resolve (Symbol Table failure).
66. [ ] Shadowed variable type incorrect (Scope resolution failure).
67. [ ] Closure captures wrong `self` context.
68. [ ] Async/Await state machine generation fails.
69. [ ] Global variable mutation propagation fails.
70. [ ] Module-level state initialization order mismatch.
71. [ ] Circular import handling fails.
72. [ ] Generic type monomorphization explosion.
73. [ ] Macro expansion infinite loop.
74. [ ] Conditional compilation (`cfg`) mismatch.
75. [ ] Platform-specific code (`sys.platform`) fails.
76. [ ] Dynamic `eval/exec` not flagged as unsupported.
77. [ ] Runtime reflection (`getattr`) fails or panics.
78. [ ] Garbage collection cycle detection missing (Rc leaks).
79. [ ] Thread safety violation (`Send/Sync` missing).
80. [ ] Process fork/exec behavior mismatch.

### V. Code Quality & Performance Falsifiers (Points 81-100)
*If quality is low, the Engineering is FALSE.*

81. [ ] Cyclomatic Complexity > 10 in generated function.
82. [ ] Cognitive Complexity > 10.
83. [ ] Generated function > 50 lines (without good reason).
84. [ ] TDG Score > 2.0 (Technical Debt).
85. [ ] Test coverage of generated crate < 80%.
86. [ ] Clippy emits ANY warning.
87. [ ] `rustfmt` alters generated code (formatting instability).
88. [ ] Dead code detected (`udeps`).
89. [ ] Duplicate code blocks > 10%.
90. [ ] SATD (Self-Admitted Technical Debt) comments in output.
91. [ ] Rust binary slower than Python (Performance Regression).
92. [ ] Memory usage > 2x Python (Leak/Bloat).
93. [ ] Compile time > 60s for simple script.
94. [ ] Binary size > 10MB for simple script.
95. [ ] Startup time > 100ms.
96. [ ] Panic reachable in safe code (unwrap/expect).
97. [ ] Buffer overflow potential (Miri check).
98. [ ] Data race potential (ThreadSanitizer).
99. [ ] Undefined Behavior detected (Miri).
100. [ ] Security vulnerability (cargo audit) in dependencies.

---

**End of Specification**