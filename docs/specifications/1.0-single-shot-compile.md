# 1.0 Single-Shot Compile Specification: The Unified Standard

**Version**: 1.1.0 (Updated with P0 Implementation)
**Date**: 2026-01-09
**Status**: **ACTIVE IMPLEMENTATION**
**Authors**: Depyler Team
**Based On**:
- `pareto-complete-single-shot.md` (Strategy)
- `root-cause-single-shot-compile.md` (Architecture Status)
- `nasa-single-shot-compile.md` (Safety Standards)
- `single-shot-compile-spec.md` (User Experience)

---

## 1. Executive Summary

### Vision
Enable Python developers to compile **ANY** Python script to a highly optimized, type-safe Rust binary with a single command. The system must operate without manual intervention, achieving "NASA-grade" reliability through rigorous type inference and semantic verification.

```bash
# The Promise
depyler compile my_script.py --release
# Result: ./my_script (native binary, 10-50x faster)
```

### Current Status (Jan 2026)
The project has emerged from "Architectural Halt". The core architectural flaws (fragile string matching, naive type mapping) have been resolved.
*   **Compile Rate**: 54/141 (38.2%) — up from 22% baseline
*   **Verification**: The "Falsification Suite" (designed to break the compiler) now compiles successfully
*   **Next Milestone**: 80% Convergence (Pareto-Complete Phase)
*   **Primary Blocker**: E0308 Type Mismatch (340 errors) — const type inference defaults to `String`

### Quick Reference (Live Metrics)

```
┌─────────────────────────────────────────────────────────────┐
│  SINGLE-SHOT COMPILE DASHBOARD                              │
├─────────────────────────────────────────────────────────────┤
│  Compile Rate:  54/141 (38.2%)  ████████░░░░░░░░░░░░  38%   │
│  Target:        80%             ████████████████░░░░  80%   │
│                                                             │
│  Top Blocker:   E0308 (340 errors) - Const Type Inference   │
│  Next Fix:      DEPYLER-1040 - Expression-based type infer  │
│                                                             │
│  RC Status:     RC-1 ✅  RC-2 ✅  RC-3 ✅                    │
│  Falsification: PASSING                                     │
└─────────────────────────────────────────────────────────────┘
```

---

## 2. User Experience & CLI

### 2.1 Design Principles
1.  **"Just Works"**: No knowledge of Rust, Cargo, or lifetimes required.
2.  **Intelligent Defaults**: Workload detection selects the optimal profile.
3.  **Fast Feedback**: Errors are mapped back to Python source lines.

### 2.2 Command Interface

```bash
USAGE:
    depyler compile [OPTIONS] <SCRIPT>

ARGS:
    <SCRIPT>    Python script to compile (.py file)

OPTIONS:
    --profile <PROFILE>   Optimization profile [auto|release|perf-ultra|min-size]
    --pgo                 Enable Profile-Guided Optimization
    --verify              Run differential testing (Python vs Rust output)
    --target <TARGET>     Cross-compile (e.g., aarch64-unknown-linux-gnu)
```

### 2.3 Optimization Profiles
*   **auto**: Detects workload (CPU vs IO vs CLI) and selects profile.
*   **release**: Balanced (10-20x speedup).
*   **perf-ultra**: Max performance (PGO + native CPU, 25-50x speedup).
*   **min-size**: Smallest binary for embedded/lambda (<500KB).

---

## 3. Architecture & Root Cause Resolution

### 3.1 Post-Mortem Resolution (RC-1 to RC-3)
We have eradicated the "fragile regex" architecture in favor of robust AST analysis.

| Root Cause | Issue | Fix Implementation | Status |
|------------|-------|--------------------|--------|
| **RC-1** | For-loops destroyed by string matching | `syn::parse2` AST extraction | **FIXED** |
| **RC-2** | Naive `Dict[str, Any]` mapping | `DepylerValue` sum type injection | **FIXED** |
| **RC-3** | `try/except` return type mismatch | Binary expr inference + `Ok()` wrapping | **FIXED** |

### 3.2 Correctness-First Architecture
We adhere to the **Toyota Way** principles: correctness before optimization.

1.  **Renacer Tracing**: Observability into every transpilation decision (AST -> HIR -> Rust).
2.  **Scalar-First Inference**: Hindley-Milner type inference (Algorithm W) is used instead of premature SIMD/ML optimization.
3.  **Differential Testing**: We validate `Output(Python) == Output(Rust)` to ensure semantic equivalence.

---

## 4. Strategy: The Path to 80% (Pareto-Complete)

### 4.1 The Diagnosis
The "73-point gap" between feature coverage (95%) and compilation success (22%) was caused by **flow-insensitive type inference**. We are fixing this by implementing **Pareto-Complete Type Inference**.

### 4.2 Error Distribution Analysis
(Based on ~870 errors across 87 failing files, Jan 2026)

| Error Code | Count | Category | Fix Strategy | Status |
|------------|-------|----------|--------------|--------|
| **E0308** | 340 | Type Mismatch | Fix const inference, binary expr unification | **BLOCKING** |
| **E0599** | 110 | Method Not Found | DepylerValue traits, container type detection | Partial |
| **E0277** | 103 | Trait Bounds | Derive `Clone`/`Debug`, fix iterator traits | Pending |
| **E0425** | 80 | Scope Issues | Fix variable hoisting and closure captures | Pending |
| **E0282** | 41 | Type Inference | Turbofish/generic annotation | Pending |
| **E0609** | 38 | No Field | Struct field access | Pending |
| **E0369** | 33 | Binary Ops | Operator trait impls | Pending |

### 4.3 Implementation Phases

**Phase 1: E0308 Type Mismatch (The 40% Fix)** — **IN PROGRESS**
*   **DEPYLER-1040**: Fix const declaration type inference. ⬅️ **CURRENT BLOCKER**
    - Bug: `not_op = not True` → `pub const not_op: String = !true;` (wrong type!)
    - Root Cause: Const type inference defaults to `String` instead of inferring from expression
*   **DEPYLER-1041**: Fix binary expression type unification.
*   **DEPYLER-1042**: Fix `HashMap<String, DepylerValue>` return consistency.

**Phase 2: E0599 Method Not Found** — **PARTIAL**
*   **DEPYLER-1043**: Implement `Display`, `len`, `chars`, `insert` on `DepylerValue`. ✅ **DONE**
    - Commit: `1c1736cf` — Added Display, len, chars, insert, get, contains_key, Index traits
*   **DEPYLER-1044**: Fix container type detection for Attribute access. ✅ **DONE**
    - Commit: `d4ce74a7` — Added HirExpr::Attribute handling to is_list_expr/is_dict_expr
*   **DEPYLER-1044b**: Fix `Result<T,E>` method confusion (`.contains()` → match/is_ok). Pending.

**Phase 3: E0277 Trait Bounds** — **PENDING**
*   **DEPYLER-1046**: Auto-derive `Debug`, `Clone`, `PartialEq` on generated structs.

**Phase 4: Flow & Scope** — **PENDING**
*   **DEPYLER-1048**: Fix variable hoisting in nested blocks.
*   **Bidirectional Propagation**: Infer types from usage (backward) as well as definition (forward).

### 4.4 The Const Type Inference Blocker (DEPYLER-1040)

**Symptom**: Module-level variables without type annotations get `String` type:
```python
# Python
not_op = not True      # bool
bitwise_not = ~0xFF    # int
list_example = [1,2,3] # List[int]
```

```rust
// Generated Rust (WRONG)
pub const not_op: String = !true;        // E0308: expected String, found bool
pub const bitwise_not: String = !255;    // E0308: expected String, found integer
```

**Root Cause**: The const type inference in `rust_gen/` defaults to `String` instead of:
1. Inferring type from the expression (`!true` → `bool`, `~255` → `i32`)
2. Using the actual value's type

**Fix Strategy**:
1. Implement expression-based type inference for const declarations
2. Map Python expression types to Rust types:
   - `not x` → `bool`
   - `~x` → `i32` (or `i64`)
   - `[1,2,3]` → `Vec<i32>`
   - `"str"` → `String`
3. Only use `String` as fallback for genuinely unknown types

---

## 5. The NASA Standard (95%+ Goal)

For mission-critical reliability, we define a "Falsification Checklist" based on **NASA-GB-8719.13**.

### 5.1 Single-Shot Definition
A compile is only successful if:
1.  `depyler transpile` succeeds.
2.  `rustc` succeeds (exit code 0).
3.  **Constraint**: No manual intervention, no `todo!()` macros, no `#![allow(warnings)]`.

---

## 6. Verification & Quality Gates

### 6.1 PMAT Gates (Blocking)
*   **TDG Score**: Must be ≤ 2.0 (Grade A-).
*   **Coverage**: ≥ 85% line coverage.
*   **Mutation Kill Rate**: ≥ 80% (via `cargo-mutants`).

### 6.2 The Falsification Protocol
To ensure we aren't fooling ourselves, we run "Falsification Tests" designed to disprove our progress.

*   **F1 (Type Annotation)**: Does adding explicit types improve convergence? (If not, type inference isn't the root cause).
*   **F2 (Flow Prototype)**: Does bidirectional inference improve convergence by >10%?
*   **F3 (Error Isolation)**: Does fixing all type errors leave >50% files failing?

### 6.3 Automated CI
```yaml
# .github/workflows/nasa-compliance.yml
steps:
  - name: Falsification Suite
    run: ./scripts/run_falsification_checklist.sh
  - name: Convergence Test
    run: depyler converge --target-rate 80
  - name: Differential Testing
    run: cargo test --features certeza-tier2
```

---

## Appendix A: Historical Intelligence Report

**Source**: `.git` history analysis (2024-2026) & Archive Synthesis

### A.1 The "Whack-a-Mole" Era (2024 - Late 2025)
*   **Strategy**: Fix errors as they appear (`fix: resolve E0308 in test_x`).
*   **Outcome**: 257+ commits in 3-day bursts, yet compilation rate stagnated at ~15-22%.
*   **Lesson**: Fixing symptoms (codegen output) without fixing the disease (type inference architecture) leads to infinite regression.
*   **Failure Mode**: "Feature Coverage" was high (95%), but "Integration Success" was low. Features worked in isolation but failed when combined.

### A.2 The "Metaheuristic" Detour (Late 2025)
*   **Strategy**: Use ML ("Aprender") to predict if code would compile and "Hunt Search" for optimal paths.
*   **Outcome**: High compute costs, low value. Regression detection is deterministic; using probabilistic ML models was **Muda** (Waste).
*   **Correction**: Pivot to "Certeza" tiered testing—deterministic, fast, reliable.

### A.3 The "Coverage Hunt" (Jan 2026)
*   **Strategy**: Aggressive push for 95% test coverage.
*   **Outcome**: Achieved high line coverage, but architectural flaws persisted (e.g., regex parsing logic).
*   **Lesson**: High coverage of bad architecture just means the bugs are well-tested.

### A.4 The "Correctness-First" Pivot (Current)
*   **Strategy**: "Toyota Way" - Stop the line. Fix Root Causes (RC-1/2/3).
*   **Key Shift**: From regex/string matching to AST/syn parsing. From "fixing errors" to "fixing inference".
*   **Result**: Compile rate jumped to 38.3% immediately after RC fixes.

### A.5 Recent Commits (Jan 2026)

| Commit | Description | Impact |
|--------|-------------|--------|
| `ab89dc59` | RC-3: Return type inference + Ok() wrapping | Falsification suite compiles |
| `4839b52c` | RC-2: DepylerValue sum type for heterogeneous dicts | E0308 reduction |
| `80fe7372` | RC-1: syn-based AST parsing (replace string matching) | E0425 reduction ~36% |
| `1c1736cf` | DepylerValue traits (Display, len, chars, Index) | E0599 partial fix |
| `d4ce74a7` | Attribute handling in is_list_expr/is_dict_expr | Container type confusion fixed |

---

## Appendix B: Peer-Reviewed Foundations

The architecture is grounded in the following computer science literature:

1.  **Type Inference**: Milner, R. (1978). "A Theory of Type Polymorphism in Programming." *Journal of Computer and System Sciences*. (Basis for our scalar Hindley-Milner approach).
2.  **Abstract Interpretation**: Cousot, P. & Cousot, R. (1977). "Abstract Interpretation: A Unified Lattice Model for Static Analysis." *POPL '77*. (Basis for our flow analysis).
3.  **Differential Testing**: McKeeman, W. M. (1998). "Differential Testing for Software." *Digital Technical Journal*. (Basis for validating Python vs Rust output).
4.  **Technical Debt**: Scully, D., et al. (2015). "Hidden Technical Debt in Machine Learning Systems." *NIPS*. (Applied to our compiler's previous "pipeline jungle").
5.  **Program Slicing**: Weiser, M. (1984). "Program Slicing." *IEEE Transactions on Software Engineering*. (Basis for `Renacer` tracing).

---

## Appendix C: The Karl Popper Falsification Strategy (100-Point)

Per Karl Popper's philosophy, we do not prove the compiler works; we exhaustively try to prove it fails. If it survives these 100 falsification attempts, we provisionally accept it as "NASA-Ready".

### I. Type System Falsifiers (Points 1-20)
*If any of these occur, the Type System hypothesis is FALSE.*

1.  [ ] `Type::Unknown` present in generated code.
2.  [ ] `rustc` reports E0308 (Type Mismatch) on valid Python input.
3.  [ ] Generic type parameters (`T`) are undeclared in `impl` blocks.
4.  [ ] Trait bounds (`T: Display`) missing for utilized methods.
5.  [ ] Return type inference fails for branching logic (`if/else` returns diff types).
6.  [ ] Numeric literals (`42`) cannot infer concrete type (`i32` vs `f64`).
7.  [ ] `E0282` (Type annotations needed) emitted by rustc.
8.  [ ] Conflicting trait implementations (`E0119`).
9.  [ ] Associated type missing (`Item` in Iterator).
10. [ ] Sizedness violation (`dyn Trait` without `Box`).
11. [ ] Union type (`int | str`) fails to map to Enum.
12. [ ] `Optional[T]` fails to map to `Option<T>`.
13. [ ] Dict assignment fails to unify key types.
14. [ ] List comprehension infers `Vec<Any>` instead of `Vec<T>`.
15. [ ] Lambda closure return type inference fails.
16. [ ] Class field types inconsistent across `__init__` paths.
17. [ ] Method overriding breaks signature compatibility.
18. [ ] Nested generics (`List[Dict[str, int]]`) fail to parse.
19. [ ] `TypeVar` remains unsubstituted in output.
20. [ ] Structural typing (Protocols) fails to generate Traits.

### II. Borrow Checker Falsifiers (Points 21-40)
*If any of these occur, the Ownership Model is FALSE.*

21. [ ] `E0596` (Cannot borrow immutable as mutable).
22. [ ] `E0507` (Cannot move out of borrowed content).
23. [ ] `E0382` (Use of moved value).
24. [ ] `E0502` (Mutable borrow occurs while immutable borrow active).
25. [ ] `E0499` (Multiple mutable borrows).
26. [ ] `E0597` (Value does not live long enough).
27. [ ] Lifetime mismatch (`'a` vs `'b`) in function signature.
28. [ ] Missing lifetime specifier (`E0106`).
29. [ ] `Clone` called on non-Clone type.
30. [ ] Unnecessary `clone()` detected by Clippy.
31. [ ] `self` mutation in non-`mut` method.
32. [ ] Field access on moved struct.
33. [ ] Return reference to local variable (`E0515`).
34. [ ] Closure captures variable incorrectly (move vs ref).
35. [ ] Iterator invalidation (modifying collection while iterating).
36. [ ] `RefCell` panic potential (runtime borrow check).
37. [ ] `Rc` cycle potential (memory leak).
38. [ ] Raw pointer usage (`*const`) detected.
39. [ ] `transmute` usage detected (Unsafe!).
40. [ ] `unsafe` block generated without justification.

### III. Semantic Equivalence Falsifiers (Points 41-60)
*If output differs, the Translation is FALSE.*

41. [ ] Stdout output differs between Python and Rust.
42. [ ] Integer overflow wraps in Rust but promotes in Python (without handling).
43. [ ] Float precision differs significantly.
44. [ ] String encoding (UTF-8) handling differs.
45. [ ] Exception not correctly mapped to `Result` or panic.
46. [ ] `None` handling differs (Option unwrapping).
47. [ ] List mutation visibility differs (reference semantics).
48. [ ] Dict iteration order assumptions broken.
49. [ ] Set operation semantics differ.
50. [ ] Slice indexing (negative indices) panics in Rust.
51. [ ] `__str__` / `Display` output format mismatch.
52. [ ] Default argument mutation persistence (Python quirk) missing.
53. [ ] Generator lazy evaluation semantics broken.
54. [ ] Context manager (`with`) cleanup order differs.
55. [ ] Decorator execution order differs.
56. [ ] Class inheritance method resolution order (MRO) differs.
57. [ ] Multiple inheritance flattening fails.
58. [ ] Property getter/setter side-effects missing.
59. [ ] Static/Class method behavior mismatch.
60. [ ] Magic method (`__add__`, etc.) precedence mismatch.

### IV. Stdlib & Ecosystem Falsifiers (Points 61-80)
*If stdlib fails, the Utility is FALSE.*

61. [ ] `os.path` function missing or incorrect.
62. [ ] `json.dumps` output format differs.
63. [ ] `re.match` group capturing differs.
64. [ ] `datetime` arithmetic mismatch.
65. [ ] `collections.defaultdict` behavior missing.
66. [ ] `argparse` output (help text) differs.
67. [ ] `itertools` infinite iterator handling fails.
68. [ ] `functools.partial` semantics broken.
69. [ ] `math` function precision/rounding mismatch.
70. [ ] `random` seeding/distribution mismatch (where relevant).
71. [ ] `hashlib` output mismatch.
72. [ ] `base64` encoding/decoding mismatch.
73. [ ] `struct.pack` endianness mismatch.
74. [ ] `socket` blocking/non-blocking behavior mismatch.
75. [ ] `threading` lock acquisition order differs.
76. [ ] `subprocess` env var inheritance differs.
77. [ ] `pathlib` path normalization differs.
78. [ ] `typing` generics lost in translation.
79. [ ] `enum` values mismatch.
80. [ ] `dataclass` equality logic mismatch.

### V. Code Quality & Performance Falsifiers (Points 81-100)
*If quality is low, the Engineering is FALSE.*

81. [ ] Cyclomatic Complexity > 10 in generated function.
82. [ ] Cognitive Complexity > 10.
83. [ ] Generated function > 50 lines (without good reason).
84. [ ] TDG Score > 2.0 (Technical Debt).
85. [ ] Test coverage of generated crate < 80%.
86. [ ] Clippy emits ANY warning.
87. [ ] `rustfmt` alters generated code (formatting instability).
88. [ ] Dead code detected (`udeps`).
89. [ ] Duplicate code blocks > 10%.
90. [ ] SATD (Self-Admitted Technical Debt) comments in output.
91. [ ] Rust binary slower than Python (Performance Regression).
92. [ ] Memory usage > 2x Python (Leak/Bloat).
93. [ ] Compile time > 60s for simple script.
94. [ ] Binary size > 10MB for simple script.
95. [ ] Startup time > 100ms.
96. [ ] Panic reachable in safe code (unwrap/expect).
97. [ ] Buffer overflow potential (Miri check).
98. [ ] Data race potential (ThreadSanitizer).
99. [ ] Undefined Behavior detected (Miri).
100. [ ] Security vulnerability (cargo audit) in dependencies.

---

**End of Specification**