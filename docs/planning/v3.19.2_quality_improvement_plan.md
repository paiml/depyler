# v3.19.2 Quality Improvement Plan - Incremental Complexity Reduction

**Goal**: Reduce legacy complexity violations through incremental Kaizen improvements
**Approach**: Tackle 10-20% of legacy violations (5-11 violations)
**Duration**: 4-6 hours
**Strategy**: Extract Method pattern + Test-Driven Refactoring

## Current State (Post v3.18.0 Modularization)

### Legacy Complexity Debt

**Total Violations**: 57 functions exceeding complexity â‰¤10 threshold
**Estimated Effort**: 482.0 hours (full remediation)
**Policy**: Tracked for incremental improvement, not blocking

### Module Breakdown

| Module | Violations | Estimated Hours | Priority |
|--------|------------|-----------------|----------|
| `expr_gen.rs` | 44 | 370.8h | P1 (77% of debt) |
| `stmt_gen.rs` | 11 | 60.2h | P2 (19% of debt) |
| `func_gen.rs` | 2 | 51.0h | P3 (4% of debt) |

## v3.19.2 Scope - Incremental Kaizen

### Target: 10% Reduction (5-6 violations)

**Philosophy**: Small, safe, incremental improvements (Toyota Kaizen principle)

### Phase 1: Quick Wins (2h) - expr_gen.rs

**Target**: 3 violations with lowest complexity scores (11-15 range)

Strategy:
1. Identify 3 functions with complexity 11-15 (easiest to fix)
2. Extract helper methods following previous patterns
3. Test each refactoring immediately
4. Aim for 1-2 hour per function

Expected Impact:
- 3 violations reduced (5% of total debt)
- 20-30 hours of estimated effort saved
- expr_gen.rs: 44 â†’ 41 violations

### Phase 2: Medium Impact (2-3h) - stmt_gen.rs

**Target**: 2-3 violations from stmt_gen.rs

Strategy:
1. Target complexity 11-20 range functions
2. Apply Extract Method pattern
3. Follow TDD: test-first approach
4. Leverage existing test suite

Expected Impact:
- 2-3 violations reduced (4-5% of total debt)
- 10-20 hours of estimated effort saved
- stmt_gen.rs: 11 â†’ 8-9 violations

### Phase 3: Documentation & Metrics (0.5h)

Tasks:
- Update roadmap.yaml with new violation counts
- Document refactoring patterns used
- Measure actual complexity reduction
- Update CHANGELOG.md

## Success Criteria

### Minimum (Accept v3.19.2)
- âœ… Reduce violations from 57 â†’ 52 (5 violations, 9% reduction)
- âœ… All tests passing (zero regressions)
- âœ… Zero clippy warnings maintained
- âœ… Zero SATD introduced
- âœ… All new code complexity â‰¤10

### Target (Ideal)
- ğŸ¯ Reduce violations from 57 â†’ 46 (11 violations, 19% reduction)
- ğŸ¯ expr_gen.rs: 44 â†’ 38 violations
- ğŸ¯ stmt_gen.rs: 11 â†’ 8 violations
- ğŸ¯ Estimated hours saved: 50-100h

### Stretch (If time permits)
- ğŸš€ Reduce violations from 57 â†’ 40 (17 violations, 30% reduction)
- ğŸš€ expr_gen.rs: 44 â†’ 32 violations
- ğŸš€ Complete stmt_gen.rs: 11 â†’ 0 violations

## Refactoring Patterns (Proven in v3.18.0)

### Pattern 1: Extract Method
```rust
// BEFORE: Complexity 15
fn complex_function() {
    // 50 lines of nested logic
    if condition1 {
        if condition2 {
            // 20 lines
        }
    }
}

// AFTER: Complexity 5
fn complex_function() {
    handle_case_1();
    handle_case_2();
}

fn handle_case_1() { /* 10 lines */ }
fn handle_case_2() { /* 10 lines */ }
```

### Pattern 2: Early Return Guards
```rust
// BEFORE: Nested if statements (complexity +4)
fn process(value: Option<i32>) -> i32 {
    if let Some(v) = value {
        if v > 0 {
            return v * 2;
        } else {
            return 0;
        }
    }
    0
}

// AFTER: Guard clauses (complexity +1)
fn process(value: Option<i32>) -> i32 {
    let v = match value {
        Some(v) => v,
        None => return 0,
    };

    if v <= 0 {
        return 0;
    }

    v * 2
}
```

### Pattern 3: Method Dispatch
```rust
// BEFORE: Large match with inline logic
fn handle(op: Op) {
    match op {
        Op::Add => { /* 10 lines */ },
        Op::Sub => { /* 10 lines */ },
        // ... 8 more cases
    }
}

// AFTER: Dispatch to helpers
fn handle(op: Op) {
    match op {
        Op::Add => handle_add(),
        Op::Sub => handle_sub(),
        // ...
    }
}
```

## Risk Mitigation

### Risks
1. **Regression risk**: Refactoring could break existing functionality
2. **Time overrun**: Complexity reduction takes longer than estimated
3. **Test failures**: Existing tests may fail after refactoring

### Mitigations
1. **TDD approach**: Run tests after EVERY change
2. **Small commits**: Commit after each function refactored
3. **Backup plan**: If stuck >1h on function, skip and document
4. **Quality gates**: Pre-commit hooks enforce standards

## Timeline

### Week 1 (4-6 hours)
- **Day 1 (2h)**: Phase 1 - expr_gen.rs quick wins (3 violations)
- **Day 2 (2-3h)**: Phase 2 - stmt_gen.rs improvements (2-3 violations)
- **Day 3 (0.5h)**: Phase 3 - Documentation and metrics

## Metrics to Track

### Before v3.19.2
- Total violations: 57
- expr_gen.rs: 44 violations
- stmt_gen.rs: 11 violations
- func_gen.rs: 2 violations
- Estimated hours: 482.0h

### After v3.19.2 (Target)
- Total violations: 52 (minimum) or 46 (target)
- expr_gen.rs: 41 (minimum) or 38 (target)
- stmt_gen.rs: 9 (minimum) or 8 (target)
- func_gen.rs: 2 (unchanged)
- Estimated hours saved: 30-50h (minimum) or 50-100h (target)

## Toyota Way Principles

### Kaizen (æ”¹å–„) - Continuous Improvement
- Small, incremental changes
- Focus on progress, not perfection
- 10% reduction is SUCCESS

### Jidoka (è‡ªåƒåŒ–) - Build Quality In
- Test after every refactoring
- Pre-commit hooks enforce standards
- Zero regressions tolerated

### Genchi Genbutsu (ç¾åœ°ç¾ç‰©) - Go and See
- Measure actual complexity before/after
- Verify tests pass at each step
- Document actual effort vs estimated

## Next Steps After v3.19.2

1. **v3.19.3** (Optional): Another 10% reduction (5-6 violations)
2. **v3.20.0**: Feature work (per Aâ†’Câ†’B strategy)
3. **Future sprints**: Continue Kaizen until <20 violations remain

## References

- v3.18.0 Modularization Sprint (created the 57 violations baseline)
- CLAUDE.md: A+ Code Standards (â‰¤10 complexity mandatory)
- Toyota Way: Kaizen philosophy
