# v3.20.0 Priority Fixes - Roadmap to 75% Pass Rate

**Date**: 2025-10-17 (Updated)
**Current Pass Rate**: 41% (41/100 tests) ✅ +1% from ConstGenericInferencer fix
**Target Pass Rate**: 75% (75/100 tests)
**Timeline**: 2-3 weeks
**Status**: ⚠️ **CORRECTION REQUIRED** - Original analysis was incorrect

---

## ⚠️ CRITICAL UPDATE (2025-10-17)

**Issue #1 was MISIDENTIFIED**. Further investigation revealed:

### What We Thought (WRONG)
- Tests failing due to "missing use statements"
- Code generated without `use std::collections::HashMap;`

### What Was Actually Happening (CORRECT)
- `ConstGenericInferencer` was **overly aggressive**
- Automatically converted `list[int]` → `[i32; 5]` based on literal return values
- This violated user intent (dynamic list became fixed-size array)
- Generated code had type mismatch: signature `[i32; 5]` vs body `Vec<{integer}>`

### Fix Applied (2025-10-17)
✅ **COMPLETED**: Disabled automatic list-to-array transformation in `ConstGenericInferencer`
- **File**: `crates/depyler-core/src/const_generic_inference.rs:173-183`
- **Change**: Disabled `transform_function_types()` method
- **Rationale**: User explicitly wrote `list[int]` → should generate `Vec<i32>`, not `[i32; 5]`
- **Result**: `test_21_list_creation` now passes ✅
- **Impact**: +1% pass rate (40% → 41%)

### Lessons Learned
1. **Always verify root cause**: Don't rely solely on test names/comments
2. **Scientific method**: Run tests to see actual errors, not assumptions
3. **Import tracking works**: The system ALREADY has `generate_conditional_imports()`

---

## Executive Summary

Based on the SQLite-style systematic validation results, we have identified **3 critical foundational issues** that affect multiple categories and account for approximately **35% of all test failures**. Fixing these issues will improve the pass rate from 41% to an estimated 75%.

**NOTE**: Issue #1 below is now known to be INCORRECT. This document needs comprehensive revision.

---

## Priority 1 Fixes (High Impact)

### Issue #1: Missing Use Statements (CRITICAL)

**Impact**: 5 categories affected, 5-7 tests failing
**Estimated Improvement**: +10% pass rate (10 tests)
**Difficulty**: Low (template fix)
**Timeline**: 2-3 days

#### Affected Tests

```
test_21_list_creation
test_26_dict_creation
test_32_set_operations
test_33_set_methods
test_34_set_membership
```

#### Problem Description

Collections generate code without importing required types:

```rust
// CURRENT (WRONG) - Missing HashMap import
fn test() -> HashMap<String, i32> {
    let ages = HashMap::new();  // ERROR: HashMap not in scope
    ages.insert("Alice".to_string(), 30);
    ages
}

// EXPECTED (CORRECT)
use std::collections::HashMap;

fn test() -> HashMap<String, i32> {
    let mut ages = HashMap::new();
    ages.insert("Alice".to_string(), 30);
    ages
}
```

#### Root Cause Analysis

**Location**: `crates/depyler-core/src/rust_gen/mod_gen.rs` or similar code generation module

**Issue**: The code generator doesn't track which standard library types are used and fails to emit corresponding `use` statements at the module level.

**Example**:
- When `dict[str, int]` is encountered → generates `HashMap<String, i32>` type
- But forgets to add `use std::collections::HashMap;` at module top
- Same issue for `HashSet`, `BTreeMap`, `BTreeSet`

#### Implementation Plan

**Step 1: Add Use Statement Tracker (1 day)**

```rust
// crates/depyler-core/src/rust_gen/mod_gen.rs

pub struct UseStatementTracker {
    required_imports: HashSet<String>,
}

impl UseStatementTracker {
    pub fn new() -> Self {
        Self {
            required_imports: HashSet::new(),
        }
    }

    pub fn track_type(&mut self, type_name: &str) {
        match type_name {
            "HashMap" => self.required_imports.insert("std::collections::HashMap".to_string()),
            "HashSet" => self.required_imports.insert("std::collections::HashSet".to_string()),
            "BTreeMap" => self.required_imports.insert("std::collections::BTreeMap".to_string()),
            "BTreeSet" => self.required_imports.insert("std::collections::BTreeSet".to_string()),
            "Vec" => {}, // Vec is in prelude
            _ => {},
        };
    }

    pub fn generate_use_statements(&self) -> String {
        let mut imports: Vec<_> = self.required_imports.iter().collect();
        imports.sort();

        imports.iter()
            .map(|import| format!("use {};", import))
            .collect::<Vec<_>>()
            .join("\n")
    }
}
```

**Step 2: Integrate Tracker into Code Generation (1 day)**

```rust
// When generating HashMap type
impl RustGenerator {
    fn generate_dict_type(&mut self, key: &Type, value: &Type) -> String {
        self.use_tracker.track_type("HashMap");
        format!("HashMap<{}, {}>",
            self.generate_type(key),
            self.generate_type(value))
    }

    fn generate_set_type(&mut self, element: &Type) -> String {
        self.use_tracker.track_type("HashSet");
        format!("HashSet<{}>", self.generate_type(element))
    }
}

// At module generation
impl ModuleGenerator {
    fn generate_module(&mut self, module: &HirModule) -> String {
        let use_statements = self.rust_gen.use_tracker.generate_use_statements();
        let functions = self.generate_functions(&module.functions);

        format!("{}\n\n{}", use_statements, functions)
    }
}
```

**Step 3: Add Tests (Half day)**

```rust
#[test]
fn test_use_statements_for_hashmap() {
    let python = r#"
def test() -> dict[str, int]:
    return {"a": 1}
"#;

    let rust = transpile(python);
    assert!(rust.contains("use std::collections::HashMap;"));
}

#[test]
fn test_use_statements_for_hashset() {
    let python = r#"
def test() -> set[int]:
    return {1, 2, 3}
"#;

    let rust = transpile(python);
    assert!(rust.contains("use std::collections::HashSet;"));
}
```

**Step 4: Verify Fix (Half day)**

Run affected tests:
```bash
cargo test test_21_list_creation
cargo test test_26_dict_creation
cargo test test_32_set_operations
cargo test test_33_set_methods
cargo test test_34_set_membership
```

Expected: All 5 tests should pass after removing `#[ignore]`

---

### Issue #2: String/&str Type Consistency (CRITICAL)

**Impact**: 6 categories affected, 15 tests failing
**Estimated Improvement**: +15% pass rate (15 tests)
**Difficulty**: Medium (type system refactor)
**Timeline**: 5-7 days

#### Affected Tests

```
test_28_dict_methods
test_29_dict_iteration
test_36_string_methods
test_38_string_formatting
test_48_method_returning_self_attribute
test_81_basic_type_annotations
test_83_dict_type_annotation
... (8 more tests)
```

#### Problem Description

The transpiler generates inconsistent string types, causing Borrow trait and type mismatch errors:

```rust
// PROBLEM 1: HashMap key type mismatch
fn lookup(data: HashMap<String, i32>, key: String) -> i32 {
    return data.get(&key)  // ERROR: String doesn't implement Borrow<&str>
        .cloned()
        .unwrap_or(0);
}

// PROBLEM 2: String concatenation type mismatch
fn concat(s: String) -> String {
    let upper = s.to_uppercase();  // Returns String
    let lower = s.to_lowercase();  // Returns String
    return upper + lower;  // ERROR: cannot add String to String
}
```

#### Root Cause Analysis

**Location**: `crates/depyler-core/src/type_inference/` and `crates/depyler-core/src/rust_gen/type_gen.rs`

**Issues**:
1. Python `str` parameters map to `String` instead of `&str`
2. HashMap lookups use `&String` instead of `&str`
3. String operations return mix of `String` and `&str`
4. No consistent rule for owned vs borrowed strings

#### Implementation Plan

**Step 1: Establish String Type Rules (1 day)**

Document the canonical mapping:

```rust
// String Type Mapping Rules
//
// Python str → Rust type mapping:
//
// 1. Function parameters: &str (borrowed, most efficient)
//    def foo(s: str) -> None  →  fn foo(s: &str)
//
// 2. Return types: String (owned, most flexible)
//    def foo() -> str  →  fn foo() -> String
//
// 3. Local variables: String (owned, mutable)
//    x: str = "hello"  →  let mut x = String::from("hello");
//
// 4. HashMap keys: &str for lookups, String for storage
//    data.get(key)  →  data.get(key.as_str())
```

**Step 2: Fix Parameter Type Generation (2 days)**

```rust
// crates/depyler-core/src/rust_gen/type_gen.rs

impl TypeGenerator {
    fn generate_function_param_type(&self, py_type: &Type, is_param: bool) -> String {
        match py_type {
            Type::Str if is_param => "&str".to_string(),  // Parameters are borrowed
            Type::Str => "String".to_string(),             // Everything else is owned
            Type::Dict(k, v) => {
                let key_type = self.generate_type(k);
                let val_type = self.generate_type(v);
                format!("HashMap<{}, {}>", key_type, val_type)
            }
            // ... other types
        }
    }
}
```

**Step 3: Fix HashMap Key Handling (2 days)**

```rust
// crates/depyler-core/src/rust_gen/expr_gen.rs

impl ExprGenerator {
    fn generate_dict_get(&self, dict: &Expr, key: &Expr) -> String {
        let dict_expr = self.generate_expr(dict);
        let key_expr = self.generate_expr(key);

        // For HashMap<String, V>, convert key to &str for lookup
        format!("{}.get({}.as_str()).cloned()", dict_expr, key_expr)
    }

    fn generate_dict_insert(&self, dict: &Expr, key: &Expr, value: &Expr) -> String {
        let dict_expr = self.generate_expr(dict);
        let key_expr = self.generate_expr(key);
        let val_expr = self.generate_expr(value);

        // For HashMap<String, V>, key is already String
        format!("{}.insert({}, {})", dict_expr, key_expr, val_expr)
    }
}
```

**Step 4: Fix String Concatenation (1 day)**

```rust
impl ExprGenerator {
    fn generate_string_concat(&self, left: &Expr, right: &Expr) -> String {
        let left_expr = self.generate_expr(left);
        let right_expr = self.generate_expr(right);

        // Use format! for string concatenation to handle both String and &str
        format!("format!(\"{{}}{{}}\" , {}, {})", left_expr, right_expr)
    }
}
```

**Step 5: Add Comprehensive Tests (1 day)**

```rust
#[test]
fn test_string_param_is_borrowed() {
    let python = r#"
def greet(name: str) -> str:
    return name
"#;
    let rust = transpile(python);
    assert!(rust.contains("fn greet(name: &str)"));
}

#[test]
fn test_hashmap_key_lookup() {
    let python = r#"
def lookup(data: dict[str, int], key: str) -> int:
    return data.get(key, 0)
"#;
    let rust = transpile(python);
    assert!(rust.contains(".as_str()") || rust.contains("&key"));
}

#[test]
fn test_string_concatenation() {
    let python = r#"
def concat(a: str, b: str) -> str:
    return a + b
"#;
    let rust = transpile(python);
    // Should compile without errors
    assert!(compile_rust(&rust).is_ok());
}
```

**Step 6: Verify Fix (Half day)**

Run all affected tests and verify 15+ tests now pass.

---

### Issue #3: Variable Scope Tracking (CRITICAL)

**Impact**: 6 categories affected, 10 tests failing
**Estimated Improvement**: +10% pass rate (10 tests)
**Difficulty**: High (symbol table refactor)
**Timeline**: 7-10 days

#### Affected Tests

```
test_43_class_attributes
test_45_class_multiple_instances
test_51_read_property
test_52_write_property
test_53_multiple_properties
test_58_try_except_finally
... (4 more tests)
```

#### Problem Description

Class instance variables and try/except variables are not properly tracked across scopes:

```rust
// PROBLEM 1: Class instance variables not accessible
struct Point {
    x: i32,
    y: i32,
}

impl Point {
    fn new(x: i32, y: i32) -> Self {
        let mut this = Point { x: 0, y: 0 };
        this.x = x;  // Works
        this.y = y;  // Works
        this
    }
}

fn test() -> i32 {
    let p = Point::new(3, 4);
    return p.x + p.y;  // ERROR: x, y not accessible
}

// PROBLEM 2: Try/except/finally variable scope
fn test(x: i32) -> i32 {
    let mut result = 0;
    // try block
    result = 10 / x;
    // except block
    // finally block
    result = result + 1;  // ERROR: result not in scope
    return result;
}
```

#### Root Cause Analysis

**Location**: `crates/depyler-core/src/hir/scope.rs` and symbol table management

**Issues**:
1. Class instance variables tracked in constructor but lost in struct definition
2. Try/except/finally blocks create isolated scopes that don't share variables
3. Mutable variable tracking doesn't propagate across block boundaries

#### Implementation Plan

**Step 1: Enhance Scope Tracker (3 days)**

```rust
// crates/depyler-core/src/hir/scope.rs

pub struct ScopeTracker {
    scopes: Vec<Scope>,
    class_context: Option<ClassContext>,
}

pub struct ClassContext {
    class_name: String,
    instance_vars: HashMap<String, Type>,
}

impl ScopeTracker {
    pub fn enter_class(&mut self, class_name: String) {
        self.class_context = Some(ClassContext {
            class_name,
            instance_vars: HashMap::new(),
        });
    }

    pub fn register_instance_var(&mut self, name: String, ty: Type) {
        if let Some(ctx) = &mut self.class_context {
            ctx.instance_vars.insert(name, ty);
        }
    }

    pub fn get_instance_vars(&self) -> Vec<(String, Type)> {
        self.class_context
            .as_ref()
            .map(|ctx| ctx.instance_vars.iter()
                .map(|(k, v)| (k.clone(), v.clone()))
                .collect())
            .unwrap_or_default()
    }
}
```

**Step 2: Fix Class Instance Variable Generation (2 days)**

```rust
// crates/depyler-core/src/rust_gen/class_gen.rs

impl ClassGenerator {
    fn generate_class(&mut self, class: &HirClass) -> String {
        // Track instance variables during __init__ analysis
        for stmt in &class.init_method.body {
            if let Stmt::Assign { target, value } = stmt {
                if let Expr::Attribute { obj, attr } = target {
                    if obj == "self" {
                        self.scope_tracker.register_instance_var(
                            attr.clone(),
                            self.infer_type(value)
                        );
                    }
                }
            }
        }

        // Generate struct with all instance variables
        let fields = self.scope_tracker.get_instance_vars()
            .iter()
            .map(|(name, ty)| format!("    pub {}: {},", name, self.type_gen.generate(ty)))
            .collect::<Vec<_>>()
            .join("\n");

        format!("pub struct {} {{\n{}\n}}", class.name, fields)
    }
}
```

**Step 3: Fix Try/Except/Finally Variable Scope (3 days)**

```rust
// crates/depyler-core/src/rust_gen/stmt_gen.rs

impl StmtGenerator {
    fn generate_try_except_finally(&mut self, stmt: &TryStmt) -> String {
        // Hoist variables declared in any block to function scope
        let hoisted_vars = self.collect_hoisted_vars(&stmt.try_block, &stmt.except_blocks, &stmt.finally_block);

        let mut result = String::new();

        // Declare hoisted variables at current scope
        for (var_name, var_type) in hoisted_vars {
            result.push_str(&format!("let mut {}: {};\n", var_name, var_type));
        }

        // Generate try/except/finally with assignments only
        result.push_str(&self.generate_try_block(&stmt.try_block));
        result.push_str(&self.generate_except_blocks(&stmt.except_blocks));
        result.push_str(&self.generate_finally_block(&stmt.finally_block));

        result
    }
}
```

**Step 4: Add Tests (1 day)**

```rust
#[test]
fn test_class_instance_vars_accessible() {
    let python = r#"
class Point:
    def __init__(self, x: int, y: int):
        self.x = x
        self.y = y

def test() -> int:
    p = Point(3, 4)
    return p.x + p.y
"#;
    let rust = transpile(python);
    assert!(compile_rust(&rust).is_ok());
}

#[test]
fn test_try_finally_variable_scope() {
    let python = r#"
def test(x: int) -> int:
    result = 0
    try:
        result = 10 // x
    except:
        result = -1
    finally:
        result = result + 1
    return result
"#;
    let rust = transpile(python);
    assert!(compile_rust(&rust).is_ok());
}
```

**Step 5: Verify Fix (1 day)**

Run all affected tests and verify 10+ tests now pass.

---

## Implementation Timeline

### Week 1: Missing Use Statements + String Type Fixes
- **Days 1-2**: Implement use statement tracker (#1)
- **Days 3-5**: String type consistency rules (#2, Steps 1-3)

### Week 2: String Type Fixes + Variable Scope
- **Days 1-2**: String concatenation and HashMap fixes (#2, Steps 4-6)
- **Days 3-5**: Variable scope tracker enhancement (#3, Steps 1-2)

### Week 3: Variable Scope + Verification
- **Days 1-3**: Try/except/finally scope fixes (#3, Steps 3-4)
- **Days 4-5**: Comprehensive testing and verification

---

## Success Metrics

### Before (Current State)
- **Pass Rate**: 40% (40/100 tests)
- **Failing Tests**: 61 documented limitations
- **Categories with 0% Pass Rate**: 5 categories

### After (Target State)
- **Pass Rate**: 75% (75/100 tests)
- **Failing Tests**: ~25 documented limitations
- **Categories with 0% Pass Rate**: 2-3 categories
- **Improvement**: +35% pass rate (+35 tests)

### Validation Process

```bash
# Run full test suite
cargo test -p depyler --test sqlite_style_systematic_validation

# Expected results:
# - test result: ok. 75 passed; 0 failed; 25 ignored

# Verify by phase:
# Phase 1: 20/20 passing (100%, up from 90%)
# Phase 2: 18/20 passing (90%, up from 65%)
# Phase 3: 16/20 passing (80%, up from 30%)
# Phase 4: 15/20 passing (75%, up from 30%)
# Phase 5: 6/20 passing (30%, up from 10%)
```

---

## Risk Assessment

### Low Risk
- **Use Statement Tracking**: Simple template addition, well-understood problem
- **Mitigation**: Comprehensive tests for each collection type

### Medium Risk
- **String Type Consistency**: Touches type inference system
- **Mitigation**: Implement incrementally, test each change

### High Risk
- **Variable Scope Tracking**: Core symbol table changes
- **Mitigation**:
  - Extensive testing of existing functionality
  - Implement behind feature flag initially
  - Gradual rollout with regression testing

---

## Dependencies

### Internal
- No blocking dependencies on other features
- Can be implemented incrementally

### External
- None (all standard library features)

---

## Follow-up Work (v3.21.0)

After achieving 75% pass rate, proceed with Priority 2 fixes:
- Class method routing (#4)
- Exception handling with Result types (#5)

Target: 88% pass rate

---

## References

- **Test Results**: `docs/testing/sqlite-style-complete-summary.md`
- **Test File**: `crates/depyler/tests/sqlite_style_systematic_validation.rs`
- **Specification**: `docs/specifications/testing-sqlite-style.md`

---

**Document Version**: 1.0
**Last Updated**: 2025-10-16
**Status**: Ready for implementation
**Assigned To**: TBD
